{
    "$schema": "https://json-schema.org/draft/2019-09/schema",
    "$id": "https://raw.githubusercontent.com/EbiEga/ega-metadata-schema/main/schemas/EGA.common-definitions.json",
    "type": "object",
    "title": "EGA common metadata definitions",
    "meta:version": "0.0.0",
    "$async": true,
    "description": "Metadata schema used by the European Genome-phenome Archive (EGA) to store common definitions for other metadata objects. Basically, we are defining here common properties (e.g. instances' aliases) that other metadata objects (e.g. sample) may use. The way we refer to them is by using this object's '$id' field, referencing it in other files (with '$ref' and the relative path of the property - e.g. '$ref': 'https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/objectCoreId'). See structuring documentation (https://json-schema.org/understanding-json-schema/structuring.html). Further details can be found in the EGA-metadata-schema GitHub repository (https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas) and EGA-archive website (https://ega-archive.org/)",
    "definitions": {
      "objectCoreId": {
        "type": "object",
        "title": "Core identifiers of an object",
        "description": "Base definition containing the properties (e.g. Sample's alias) of a minimal identification layer of an EGA object (e.g. Sample).",
        "additionalProperties": false,
        "properties": {
          "alias": {
            "type": "string",
            "title": "Alias of an object",
            "description": "Submitter designated name (e.g. 'my_sample_J13') for the object (e.g. Sample). The name must be unique within the submission account (e.g. 'ega-box-79'), since the aliases and submission accounts are concatenated within our database to obtain the unique alias (e.g. 'ega-box-79::my_sample_J13').",
            "minLength": 1,
            "examples": [ "my_sample_J13" ]
          },
          "centerName": {
            "type": "string",
            "title": "Center name of the submitter",
            "description": "Center name (e.g. 'EBI-TEST') associated to the submitter. In other words, it is the acronym of the submitter's account (provided by the HelpDesk team).",
            "minLength": 1,
            "examples": [ "EBI-TEST" ]
          },
          "egaAccession": {
            "type": "string",
            "title": "EGA's accession of the object",
            "description": "The object accession (i.e. unique identifier) assigned by the archive (EGA). Object accessions can be found in the 'Identifiers' section of the EGA-archive website (https://ega-archive.org/metadata/how-to-use-the-api) and commonly start with EGA, followed by the distinctive letter of the object and finally the numeric ID of the instance.",
            "examples": [ "EGAN00003245489" ]
          },
          "externalAccessions": {
            "type": "array",
            "title": "External accessions array",
            "description": "External accession node to reference objects in other archives (e.g. an already existing sample at BioSamples).",
            "minItems": 1,
            "additionalProperties": false,
            "uniqueItems": true,
            "items": {
              "$ref": "./EGA.common-definitions.json#/definitions/objectExternalAccession"
            }
          }

        },
        "anyOf": [
          { 
            "title": "Check core IDs: combination of Alias and Center name",
            "required": ["alias", "centerName"] 
          },
          { 
            "title": "Check core IDs: EGA accession ID",
            "required": ["egaAccession"] 
          },
          { 
            "title": "Check core IDs: external accessions",
            "required": ["externalAccessions"] 
          }
        ]
      },

      "customAttribute": {
        "type": "object",
        "title": "Custom attribute of an object",
        "description": "Reusable attributes to encode tag-value pairs (e.g. Tag being 'Age' and its Value '40') with optional units (e.g. 'years').",
        "required": ["tag", "value"],
        "additionalProperties": false,
        "properties": {
          "tag": {
            "type": "string",
            "title": "Tag of the custom attribute",
            "description": "The name of the attribute (e.g. 'Age').",
            "minLength": 1,
            "examples": [ "age" ]
          },
          "value": {
            "type": ["string", "number"],
            "title": "Value of the custom attribute",
            "description": "The value of the attribute (e.g. '40').",
            "examples": [ "smoker", 40 ]
          },
          "units": {
            "type": "string",
            "title": "Units of the custom attribute",
            "description": "The optional units of the attribute (e.g. 'years').",
            "minLength": 1,
            "examples": [ "years" ]
          }
        }        
      },

      "fileObject": {
        "type": "object",
        "title": "EGA File object",
        "description": "Object containing the base metadata attributes of a file object in the EGA. These can inherited elsewhere with or without extending them.",
        "required": ["filename", "filetype", "checksumMethod", "unencryptedChecksum", "encryptedChecksum"],
        "additionalProperties": false,
        "properties": {
          "filename": {
            "type": "string",
            "title": "Filename",
            "meta:propertyCurie": "data:1050",
            "description": "The full name of a file, including all of their file extensions (e.g. .gpg, .md5...), that identifies the file (e.g. 'my-bam-file.bam.gpg').",
            "pattern": "^[^<>:;,?\"*|]+$",
            "examples": [ "my-bam-file.bam.gpg" ]
          },
          "fileContent": {
            "type": "array",
            "title": "File content array",
            "description": "Array of file content items. This array exists to clarify what the purpose of a file, regardless of its format, may be. For example, a TXT formatted file could contain multiple types of data, from gene annotations to READMEs. Therefore, select the items from the used ontology that best describe the content of your file.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "object",
              "title": "File content item",
              "description": "Item describing the type of data a file contains or represents.",
              "meta:propertyCurie": "format:2350",
              "allOf": [
                {
                  "title": "Inherited ontologyTerm structure of termId and termLabel",
                  "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
                }
              ],
              "properties": {        
                "termId": {
                  "title": "Ontology constraints for this specific termId",
                  "description": "Property containing just the ontology constraints for the file content. Notice the 'direct' being 'true', which makes the constraint more stringent, and only allows for terms one step below [format:2350].",
                  "graphRestriction ":  {
                    "ontologies" : ["obo:edam"],
                    "classes": ["format:2350"],
                    "relations": ["rdfs:subClassOf"],
                    "direct": true,
                    "include_self": false
                  },
                  "examples": [ "format:1919", "format:3326" ]
                }
              }
            }
          },
          "filetype": {
            "type": "string",
            "title": "Filetype",
            "meta:propertyCurie": "format:1915",
            "description": "The main format in which data is structured and represented in an electronic file. It is normally defined by the file extension of the file (e.g. FASTQ for a '.fastq' file). The string corresponds to the ID or name (e.g. FASTA, TSV...), chosen from a list of controlled vocabulary (CV), associated with the given filetype. If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
            "enum": ["CEL", "TSV", "FASTQ", "FASTA", "VCF", "SRA", "SRF", "SFF", "BAM", "CRAM", "XLSX", "CSV", "BED", "IDAT", "MAP", "PED", "BIM", "FAM", "TXT", "EXP", "GPR", "PY", "SH", "ADF", "SDRF", "IDF", "MD5", "HAP", "CSFASTA", "LOC", "HTML", "HIC", "MD", "MATLAB", "PERL", "TIF", "R", "SNP", "XML", "SVG", "PNG", "JPG", "GTC", "HDF5", "FAST5", "PAIR", "TXT", "BGI", "BGEN", "GEN", "PXF", "LOOM", "BAX.H5", "BAS.H5", "ASM", "CSI", "TBI", "BCF", "qual454", "qualsolid", "FASTQ-illumina", "FASTQ-helicos", "FASTQ-sanger", "FASTQ-solexa", "SAM", "CRAI", "BAI", "MTX", "MEX ", "GMX", "GMT", "GRP"],
            "meta:enum": {
              "CEL": "[format:1638]",
              "TSV": "[format:3475]",
              "FASTQ": "[format:1930]",
              "FASTA": "[format:1929]",
              "VCF": "[format:3016]",
              "SRA": "[format:3698]",
              "SRF": "[format:3698]",
              "SFF": "[format:3284]",
              "BAM": "[format:2572]",
              "CRAM": "[format:3462]",
              "XLSX": "[format:3620]",
              "CSV": "[format:3752]",
              "BED": "[format:3003]",
              "IDAT": "[format:3578]",
              "MAP": "[format:3285]",
              "PED": "[format:3286]",
              "BIM": "[]",
              "FAM": "[]",
              "EXP": "[format:1631]",
              "GPR": "[format:3829]",
              "PY": "[format:3996]",
              "SH": "[]",
              "ADF": "[NCIT:C172213]",
              "SDRF": "[NCIT:C172211]",
              "IDF": "[NCIT:C172212]",
              "MD5": "[data:2190]",
              "HAP": "[]",
              "CSFASTA": "[]",
              "LOC": "[]",
              "HTML": "[format:2331]",
              "HIC": "[]",
              "MD": "[]",
              "MATLAB": "[format:4007]",
              "PERL": "[format:3998]",
              "TIF": "[]",
              "R": "[format:3999]",
              "SNP": "[]",
              "XML": "[format:2332]",
              "SVG": "[format:3604]",
              "PNG": "[format:3603]",
              "JPG": "[format:3579]",
              "GTC": "[]: An Illumina-specific file containing called genotypes in AA/AB/BB format",
              "HDF5": "[format:3590]",
              "FAST5": "[]",
              "PAIR": "[]",
              "TXT": "[format:2330]",
              "BGI": "[]: Index file of a BGEN file",
              "BGEN": "[]: Binary version of a GEN file",
              "GEN": "[format:3812]",
              "PXF": "[]: A phenopacket. An open standard for sharing disease and phenotype information represented as PXF (Phenotype Exchange Format) files, which may be encoded in JSON or YAML.",
              "LOOM": "[format:3913]",
              "BAX.H5": "[]",
              "BAS.H5": "[]",
              "ASM": "[]: The files in the ASM directory describe and annotate the genome assembly with respect to the reference genome.",
              "CSI": "[]",
              "TBI": "[format:3700]",
              "BCF": "[format:3020]",
              "qual454": "[format:3611]",
              "qualsolid": "[format:3610]",
              "FASTQ-illumina": "[format:1931]",
              "FASTQ-helicos": "[]",
              "FASTQ-sanger": "[format:1932]",
              "FASTQ-solexa": "[format:1933]",
              "SAM": "[format:2573]",
              "CRAI": "[]: CRAM indexing format",
              "BAI": "[format:3327]",
              "MTX": "[format:3916]",
              "MEX ": "[]: Market Exchange Format (MEX) for sparse matrices. It  contains a matrix (MTX) file, and also gzipped TSV files with feature and barcode sequences corresponding to row and column indices respectively. Feature-barcode matrix",
              "GMX": "[]",
              "GMT": "[]",
              "GRP": "[]"
            }
          },
          "checksumMethod": {
            "type": "string",
            "title": "Checksum method ID",
            "meta:propertyCurie": "REPR:ChecksumAlgorithm",
            "description": "Node containing both the ID (MD5 or SHA-256), describing the method which yields the checksum from a data input for the purpose of detecting errors. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
            "enum": ["MD5", "SHA-256"],
            "meta:enum": {
              "MD5": "[NCIT:C171276]",
              "SHA-256": "[NCIT:C80226]"
            }
          },
          "unencryptedChecksum": {
            "type": "string",
            "title": "Checksum [NCIT:C43522] of the unencrypted file",
            "description": "A computed value which depends on the contents of a block of data and which is transmitted or stored along with the data in order to detect corruption of the data, computed from the unencrypted files.",
            "examples": [ "46798b5cfca45c46a84b7419f8b74735" ],
            "oneOf": [
              { 
                "title": "Check of MD5 checksum pattern", 
                "$ref": "#/definitions/md5ChecksumPattern"
              },
              { 
                "title": "Check of SHA-256 checksum pattern",
                "$ref": "#/definitions/SHA256ChecksumPattern"
              }
            ]
          },
          "encryptedChecksum": {
            "type": "string",
            "title": "Checksum [NCIT:C43522] of the encrypted file",
            "description": "A computed value which depends on the contents of a block of data and which is transmitted or stored along with the data in order to detect corruption of the data, computed from the encrypted files.",
            "examples": [ "bc527343c7ffc103111f3a694b004e2f" ],
            "oneOf": [
              { 
                "title": "Check of MD5 checksum pattern", 
                "$ref": "#/definitions/md5ChecksumPattern"
              },
              { 
                "title": "Check of SHA-256 checksum pattern",
                "$ref": "#/definitions/SHA256ChecksumPattern"
              }
            ]
          },
          "sequenceQualityDetails": {
            "type": "object",
            "title": "Sequence quality details",
            "description": "Sequencing quality scores measure the probability that a base is called (i.e. sequenced) incorrectly. New sequencing technologies assign a quality score to each of the bases in the sequence.",
            "required": ["qualityScoringSystem"],
            "additionalProperties": false,
            "properties": {
              "qualityScoringSystem": {
                "type": "string",
                "title": "Quality scoring system",
                "description": "How the quality score was computed for the data.",
                "enum": ["phred", "logOdds"],
                "meta:enum": { 
                  "phred": "The quality score is expressed as a probability of error in log form: -10 log(1/p) where p is the probability of error, with value range 0..63 (0 meaning no base call).",
                  "logOdds": "The quality score is expressed as the ratio of error to non-error in log form: -10 log(p/(1-p)) where p is the of error, with value range -40..40. The SRA will convert these into phred scale during loadtime." 
                }
              },
              "qualityEncoding": {
                "type": "string",
                "title": "Quality encoding format",
                "description": "Encoding system used to represent the quality score.",
                "enum": ["ascii", "decimal", "hexadecimal"],
                "meta:enum": {
                  "ascii": "ASCII character based encoding.",
                  "decimal": "Single decimal value per quality score.",
                  "hexadecimal": "Single hexadecimal value per quality score."
                }
              },
              "asciiOffset": {
                "type": "string",
                "title": "ASCII offset",
                "description": "Character used in representing the minimum quality value.  Helps specify how to decode text rendering of quality data.",
                "enum": ["!", "@"],
                "meta:enum": {
                  "!": "ASCII value 33.  Typically used for range 0..63.",
                  "@": "ASCII value 64.  Typically used for range 0..60." 
                }
              }
            }
          }
        },
        "allOf": [
          { 
            "title": "Inherited check of checksum patterns", 
            "$ref": "#/definitions/checksumPatternCheck" 
          },
          { 
            "title": "Inherited check of filetype-filename patterns", 
            "$ref": "#/definitions/filenameFiletypePatternCheck" 
          }
        ]        
      },

      "relationshipObject": {
        "type": "object",
        "title": "EGA Relationships object",
        "description": "Object containing the base metadata attributes of a relationship object in the EGA. Comprises metadata (e.g. Source or Target) of a directional association between two entities. One of the entitis **needs** to be the current instance. For instance, a study JSON document should not contain relationships between a sample and an individual. Therefore, only one end of the relationship is given: if the source is present, the target is inferred to be the current instance; if the target is given, then it's the source the one inferred as the current instance. Examples of common relationships: (1) a sample being referenced in an experiment; (2) an study being the same as another study at a different archive (e.g. in BioStudies); (3) an individual being the parent of another individual; (4) hundreds of samples being grouped with each other for broad reasons.",
        "required": ["rType"],
        "additionalProperties": false,
        "properties": {
          "rType": {
            "type": "string",
            "title": "Relationship type",
            "description": "ID (e.g. sameAs) of the type of the relationship. To be chosen from a controlled vocabulary (CV) list. If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "enum": ["referencedBy", "developsFrom", "sameAs", "memberOf", "groupedWith", "familyRelationshipWith", "childOf", "isAfter", "publishedIn", "submittedBy", "contactOf", "mainContactOf"],
            "meta:enum": {
              "referencedBy": "[SIO:000252]",
              "developsFrom": "[RO:0002202]",
              "sameAs": "[NCIT:C64637]",
              "memberOf": "[RO:0002350]",
              "groupedWith": "",
              "familyRelationshipWith": "[EFO:0004424]",
              "childOf": "[GSSO:000728]",
              "isAfter": "[SIO:000211]",
              "publishedIn": "[EFO:0001796]",
              "submittedBy": "[NCIT:C25695]",
              "contactOf": "[NCIT:C25461]",
              "mainContactOf": "" 
            },
            "examples": [ "referencedBy" ]
          },
          "rSource": {
            "type": "object",
            "title": "Source of the relationship",
            "description": "Object reference of the relationship's source. In other words, the starting point of the relationship: in 'sample_A developsFrom sample_B' the source is 'sample_A'.",
            "allOf": [
              {
                "title": "Inherited oneRelationshipEnd object", 
                "$ref": "./EGA.common-definitions.json#/definitions/oneRelationshipEnd" 
              }
            ]
          },
          "rTarget": {
            "type": "object",
            "title": "Target of the relationship",
            "description": "Object reference of the relationship's target. In other words, the ending point of the relationship: in 'sample_A developsFrom sample_B' the target is 'sample_B'.",
            "allOf": [
              {
                "title": "Inherited oneRelationshipEnd object", 
                "$ref": "./EGA.common-definitions.json#/definitions/oneRelationshipEnd" 
              }
            ]
          },
          "rLabel": {
            "type": "string",
            "title": "Custom label of the relationship",
            "description": "Custom free-form label of the relationship, used to add extra details of the relationship if needed.",
            "minLength": 1,
            "examples": [ 
              "Source individual is the third child of the target individual", 
              "Grouped samples by colour of the medium",
              "Both samples are the same because of an error in the submission at..."
            ]
          }
        },
        "oneOf": [
          {
            "title": "The source is given (i.e. the target is inferred as the current instance)",
            "required": ["rSource"]
          },
          {
            "title": "The target is given (i.e. the source is inferred as the current instance)",
            "required": ["rTarget"]
          }
        ]       
      },

      "arrayLabel": {
        "type": "object",
        "title": "Repeatable arrayLabel node",
        "description": "Chemical conjugated to nucleic acid/proteins to label them before microarray hybridisation. This node defines one single label, and thus should be repeated as an array where inherited if multiple labels are intended to be described.",
        "anyOf": [
          {
            "required": ["arrayLabelIdentifier"]
          },
          {
            "required": ["arrayLabelDescription"]
          }
        ],
        "additionalProperties": false,
        "properties": {
          "arrayLabelIdentifier": {
            "type": "object",
            "title": "Array label identifier",
            "description": "The chosen term (e.g. 'Cy3 dye' [CHEBI:37987]) needs to be a Chemical Entity from the CHEBI ontology, look for yours at: https://www.ebi.ac.uk/ols/search?q=&ontology=chebi",
            "allOf": [
              {
                "title": "Inherited ontologyTerm structure of termId and termLabel",
                "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
              }
            ],
            "properties": {        
              "termId": {
                "title": "Ontology constraints for this specific termId",
                "graphRestriction ":  {
                  "ontologies" : ["obo:chebi"],
                  "classes": ["CHEBI:24431"],
                  "relations": ["rdfs:subClassOf"],
                  "direct": false,
                  "include_self": false
                },
                "examples": [ "CHEBI:37987", "CHEBI:15956" ]
              }
            }
          },
          "arrayLabelDescription": {
            "type": "string",
            "title": "Array label description",
            "description": "Additional description of the used array label, indicating further details: context, purpose of the label, description of the label in the absence of an ontologized term, etcetera.",
            "minLength": 1,
            "examples": [
              "This label was used to dye the control samples",
              "This newly discovered label (yet to be added to an ontology) consists of a compound of type X...",
              "The label ID is unknown because we were given an already dyed kit..." ]
          }
        }          
      },

      "objectIdAndObjectTypeCheck": {
        "type": "object",
        "title": "Check that the objectId's accession pattern and objectType match",
        "description": "This object exists with the only purpose of being a reference as a pattern check of a given objectId and objectType. The constraint consists in asserting that, if the object identifier is an EGA accession, its pattern matches the object type (e.g. if objectType is 'sample', its EGA accession needs to match '^EGAN[0-9]{11}$')",
        "anyOf": [
          {
            "title": "Alias and Centername: objectId and objectType check",
            "description": "A check that ensures that the alias and centername are given as the objectType. Since the alias and centername cannot be checked for specific objectTypes (i.e. each can name their objects in different ways), this block exists here just so that this option is allowed.",
            "properties": {
              "objectId": { 
                "required": ["alias", "centerName"]
              }
            }
          },
          {
            "title": "External accession: objectId and objectType check",
            "description": "A check that ensures that, if 'externalAccession' is given as the objectType, the corresponding node exists within objectId",
            "properties": {
              "objectId": { 
                "required": ["externalAccessions"]
              },
              "objectType": {
                "enum": ["externalAccession"]
              }
            }
          },
          {
            "title": "Experiment: objectId and objectType check",
            "description": "A check that ensures that, if 'experiment' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAExperimentIdPattern" }
                }
              },
              "objectType": {
                "enum": ["experiment"]
              }
            }
          }, 
          {
            "title": "Study: objectId and objectType check",
            "description": "A check that ensures that, if 'study' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAStudyIdPattern" }
                }
              },
              "objectType": {
                "enum": ["study"]
              }
            }
          },          
          {
            "title": "Sample: objectId and objectType check",
            "description": "A check that ensures that, if 'sample' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGASampleIdPattern" }
                }
              },
              "objectType": {
                "enum": ["sample"]
              }
            }
          },          
          {
            "title": "Submission: objectId and objectType check",
            "description": "A check that ensures that, if 'submission' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGASubmissionIdPattern" }
                }
              },
              "objectType": {
                "enum": ["submission"]
              }
            }
          },          
          {
            "title": "Assay: objectId and objectType check",
            "description": "A check that ensures that, if 'assay' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAAssayIdPattern" }
                }
              },
              "objectType": {
                "enum": ["assay"]
              }
            }
          },          
          {
            "title": "Dataset: objectId and objectType check",
            "description": "A check that ensures that, if 'dataset' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGADatasetIdPattern" }
                }
              },
              "objectType": {
                "enum": ["dataset"]
              }
            }
          },          
          {
            "title": "Analysis: objectId and objectType check",
            "description": "A check that ensures that, if 'analysis' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAAnalysisIdPattern" }
                }
              },
              "objectType": {
                "enum": ["analysis"]
              }
            }
          },          
          {
            "title": "Policy: objectId and objectType check",
            "description": "A check that ensures that, if 'policy' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAPolicyIdPattern" }
                }
              },
              "objectType": {
                "enum": ["policy"]
              }
            }
          },          
          {
            "title": "DAC: objectId and objectType check",
            "description": "A check that ensures that, if 'DAC' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGADACIdPattern" }
                }
              },
              "objectType": {
                "enum": ["DAC"]
              }
            }
          },
          {
            "title": "Individual: objectId and objectType check",
            "description": "A check that ensures that, if 'individual' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAIndividualIdPattern" }
                }
              },
              "objectType": {
                "enum": ["individual"]
              }
            }
          },
          {
            "title": "Protocol: objectId and objectType check",
            "description": "A check that ensures that, if 'protocol' is given as the objectType and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "objectId": { 
                "properties": {
                  "egaAccession": { "$ref": "#/definitions/EGAProtocolIdPattern" }
                }
              },
              "objectType": {
                "enum": ["protocol"]
              }
            }
          }
        ]                      
      },
      
      "checksumPatternCheck": {
        "type": "object",
        "title": "Check: checksum checks based on its method",
        "description": "This object exists with the only purpose of being a reference of pattern checks of the given checksum (e.g. 'c6779ec2960296ed9a04f08d67f64423') of a file based on its corresponding method (e.g. if the given checksum method is 'MD5' the checksum shall fit into MD5's format of '^[0-9a-z](?:-?[0-9a-z]){31}$')",
        "anyOf": [
          { 
            "title": "Checksum pattern check - MD5",
            "description": "A check that ensures that, if MD5 is given as a checksumMethodId, the checksums per se (e.g. unencryptedChecksum) follow MD5 patterns (md5ChecksumPattern).",
              "properties": {
                "checksumMethod": {
                      "enum": ["MD5"]
                },
                "unencryptedChecksum": { "$ref": "#/definitions/md5ChecksumPattern" },
                "encryptedChecksum": { "$ref": "#/definitions/md5ChecksumPattern" }
              }
          },
          { 
            "title": "Checksum pattern check - SHA-256",
            "description": "A check that ensures that, if SHA-256 is given as a checksumMethodId, the checksums per se (e.g. unencryptedChecksum) follow SHA-256 patterns (sha-256-checksum-pattern).",
              "properties": {
                "checksumMethod": {
                      "enum": ["SHA-256"]
                },
                "unencryptedChecksum": { "$ref": "#/definitions/SHA256ChecksumPattern" },
                "encryptedChecksum": { "$ref": "#/definitions/SHA256ChecksumPattern" }
              }
          }
        ]                    
      },

      "md5ChecksumPattern": {
        "type": "string",
        "title": "Checksum pattern obtained by MD5",
        "description": "This object exists to hold the pattern that a checksum would have if it was obtained using the algorithm MD5, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[0-9a-z](?:-?[0-9a-z]){31}$",
        "examples": [ "bc527343c7ffc103111f3a694b004e2f" ]
      },

      "SHA256ChecksumPattern": {
        "type": "string",
        "title": "Checksum pattern obtained by SHA-256",
        "description": "This object exists to hold the pattern that a checksum would have if it was obtained using the algorithm SHA-256, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[A-Fa-f0-9]{64}$",
        "examples": [ "c01b39c7a35ccc3b081a3e83d2c71fa9a767ebfeb45c69f08e17dfe3ef375a7b" ]
      },

      "EGAExperimentIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA experiment's ID (EGAX...)",
        "pattern": "^EGAX[0-9]{11}$",
        "examples": [ "EGAX00002189113" ]
      },
      
      "EGAStudyIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA study's ID (EGAS...)",
        "pattern": "^EGAS[0-9]{11}$",
        "examples": [ "EGAS00001004508" ]
      },

      "EGASampleIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA sample's ID (EGAN...)",
        "pattern": "^EGAN[0-9]{11}$",
        "examples": [ "EGAN00003245489" ]
      },

      "EGASubmissionIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA submission's ID (EGAB...)",
        "pattern": "^EGAB[0-9]{11}$",
        "examples": [ "EGAB00001001831" ]
      },

      "EGAAssayIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA assay's ID (EGAR...)",
        "pattern": "^EGAR[0-9]{11}$",
        "examples": [ "EGAR00001314547" ]
      },

      "EGADatasetIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA dataset's ID (EGAD...)",
        "pattern": "^EGAD[0-9]{11}$",
        "examples": [ "EGAD00001004170" ]
      },

      "EGAAnalysisIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA analysis's ID (EGAZ...)",
        "pattern": "^EGAZ[0-9]{11}$",
        "examples": [ "EGAZ00001004170" ]
      },

      "EGAPolicyIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA policy's ID (EGAP...)",
        "pattern": "^EGAP[0-9]{11}$",
        "examples": [ "EGAP00001001831" ]
      },

      "EGADACIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA DAC's ID (EGAC...)",
        "pattern": "^EGAC[0-9]{11}$",
        "examples": [ "EGAC00001000908" ]
      },

      "EGAIndividualIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA Individual's ID (EGAI...)",
        "pattern": "^EGAI[0-9]{11}$",
        "examples": [ "EGAI00001159712" ]
      },

      "EGAProtocolIdPattern": {
        "type": "string",
        "title": "Pattern of an EGA protocol's ID (EGAO...)",
        "pattern": "^EGAO[0-9]{11}$",
        "examples": [ "EGAO00001159483" ]
      },
      
      "EGAISO8601DatePattern": {
        "type": "string",
        "title": "Pattern of EGA ISO 8601 date",
        "description": "Regular expression to check the syntax of a date following 'ISO 8601 date' format. Notice that the Time (denoted by 'T...') is optional. So is the time zone, specified at the end of the string (e.g. 'Z', '+01:00'...). See more detail at 'https://regexpattern.com/iso-8601-dates-times/'.",
        "pattern": "^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])(T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\\.[0-9]+)?(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?)?$",
        "examples": [ "2021-04-30", "2020-12-29T19:30:45.123Z", "2020-12-29", "2020-12-29T19:30:45", "2021-10-13T04:13:00+01:00", "2021-10-13T12:13:00-08:00", "2021-10-13T12:13:00" ]
      },

      "EGAISO8601DurationPattern": {
        "type": "string",
        "title": "Pattern of a partial EGA ISO 8601 duration",
        "description": "Pattern of ISO 8601 durations. It can be used to define time intervals (e.g. 'P3Y6M4DT12H30M5S' represents a duration of three years, six months, four days, twelve hours, thirty minutes, and five seconds). See more at https://en.wikipedia.org/wiki/ISO_8601#Durations.",
        "pattern": "^[-+]?P(?!$)(([-+]?\\d+Y)|([-+]?\\d+\\.\\d+Y$))?(([-+]?\\d+M)|([-+]?\\d+\\.\\d+M$))?(([-+]?\\d+W)|([-+]?\\d+\\.\\d+W$))?(([-+]?\\d+D)|([-+]?\\d+\\.\\d+D$))?(T(?=[\\d+-])(([-+]?\\d+H)|([-+]?\\d+\\.\\d+H$))?(([-+]?\\d+M)|([-+]?\\d+\\.\\d+M$))?([-+]?\\d+(\\.\\d+)?S)?)??$",
        "examples": [ "P3Y6M4DT12H30M5S", "P23DT23H", "PT0S", "P0D", "P0,5Y", "P0.5Y"]
      },

      "filenameFiletypePatternCheck": {
        "type": "object",
        "title": "Check: filetype checks based on its filename",
        "description": "This object exists with the only purpose of being a reference of pattern checks of the given filetype of a file based on its corresponding filename (e.g. if the file is 'alignment.bam.gpg' its filetypeId shall be 'BAM' and not 'XLSX')",
        "anyOf": [
          {
            "title": "CEL Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["CEL"] 
                },
                "filename": { "$ref": "#/definitions/celFileFilenamePattern" }
            }
          },                
          {
            "title": "TSV Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["TSV"] 
                },
                "filename": { "$ref": "#/definitions/tsvFileFilenamePattern" }
            }
          },                
          {
            "title": "ADF Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["ADF"] 
                },
                "filename": { "$ref": "#/definitions/adfFileFilenamePattern" }
            }
          },                
          {
            "title": "FASTQ Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["FASTQ"] 
                },
                "filename": { "$ref": "#/definitions/fastqFileFilenamePattern" }
            }
          },                
          {
            "title": "FASTA Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["FASTA"] 
                },
                "filename": { "$ref": "#/definitions/fastaFileFilenamePattern" }
            }
          },                
          {
            "title": "SDRF Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["SDRF"] 
                },
                "filename": { "$ref": "#/definitions/sdrfFileFilenamePattern" }
            }
          },                
          {
            "title": "IDF Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["IDF"] 
                },
                "filename": { "$ref": "#/definitions/idfFileFilenamePattern" }
            }
          },                
          {
            "title": "VCF Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["VCF"] 
                },
                "filename": { "$ref": "#/definitions/vcfFileFilenamePattern" }
            }
          },                
          {
            "title": "SRA Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["SRA"] 
                },
                "filename": { "$ref": "#/definitions/sraFileFilenamePattern" }
            }
          },                
          {
            "title": "SRF Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["SRF"] 
                },
                "filename": { "$ref": "#/definitions/srfFileFilenamePattern" }
            }
          },                
          {
            "title": "SFF Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["SFF"] 
                },
                "filename": { "$ref": "#/definitions/sffFileFilenamePattern" }
            }
          },                
          {
            "title": "BAM Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["BAM"] 
                },
                "filename": { "$ref": "#/definitions/bamFileFilenamePattern" }
            }
          },                
          {
            "title": "CRAM Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["CRAM"] 
                },
                "filename": { "$ref": "#/definitions/cramFileFilenamePattern" }
            }
          },                
          {
            "title": "XLSX Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["XLSX"] 
                },
                "filename": { "$ref": "#/definitions/xlsxFileFilenamePattern" }
            }
          },                
          {
            "title": "CSV Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["CSV"] 
                },
                "filename": { "$ref": "#/definitions/csvFileFilenamePattern" }
            }
          },                
          {
            "title": "BED Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["BED"] 
                },
                "filename": { "$ref": "#/definitions/bedFileFilenamePattern" }
            }
          },                
          {
            "title": "IDAT Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["IDAT"] 
                },
                "filename": { "$ref": "#/definitions/idatFileFilenamePattern" }
            }
          },                
          {
            "title": "MAP Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["MAP"] 
                },
                "filename": { "$ref": "#/definitions/mapFileFilenamePattern" }
            }
          },                
          {
            "title": "PED Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["PED"] 
                },
                "filename": { "$ref": "#/definitions/pedFileFilenamePattern" }
            }
          },                
          {
            "title": "BIM Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["BIM"] 
                },
                "filename": { "$ref": "#/definitions/bimFileFilenamePattern" }
            }
          },                
          {
            "title": "FAM Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["FAM"] 
                },
                "filename": { "$ref": "#/definitions/famFileFilenamePattern" }
            }
          },
          {
            "title": "TXT Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["TXT"] 
                },
                "filename": { "$ref": "#/definitions/txtFileFilenamePattern" }
            }
          },
          {
            "title": "EXP Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["EXP"] 
                },
                "filename": { "$ref": "#/definitions/expFileFilenamePattern" }
            }
          },
          {
            "title": "GPR Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["GPR"] 
                },
                "filename": { "$ref": "#/definitions/gprFileFilenamePattern" }
            }
          },
          {
            "title": "PY Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["PY"] 
                },
                "filename": { "$ref": "#/definitions/pyFileFilenamePattern" }
            }
          },
          {
            "title": "SH Filename patternCheck",
            "properties": {
                "filetype": {
                   "enum": ["SH"] 
                },
                "filename": { "$ref": "#/definitions/shFileFilenamePattern" }
            }
          },
          {
            "title": "MD5 Filename patternCheck",
            "properties": {
                "filetype": {
                    "enum": ["MD5"]
                },
                "filename": { "$ref": "#/definitions/md5FileFilenamePattern" }
            }
          },
          {
              "title": "HAP Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["HAP"]
                  },
                  "filename": { "$ref": "#/definitions/hapFileFilenamePattern" }
              }
          },
          {
              "title": "CSFASTA Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["CSFASTA"]
                  },
                  "filename": { "$ref": "#/definitions/csfastaFileFilenamePattern" }
              }
          },
          {
              "title": "LOC Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["LOC"]
                  },
                  "filename": { "$ref": "#/definitions/locFileFilenamePattern" }
              }
          },
          {
              "title": "HTML Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["HTML"]
                  },
                  "filename": { "$ref": "#/definitions/htmlFileFilenamePattern" }
              }
          },
          {
              "title": "HIC Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["HIC"]
                  },
                  "filename": { "$ref": "#/definitions/hicFileFilenamePattern" }
              }
          },
          {
              "title": "MD Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["MD"]
                  },
                  "filename": { "$ref": "#/definitions/mdFileFilenamePattern" }
              }
          },
          {
              "title": "MATLAB Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["MATLAB"]
                  },
                  "filename": { "$ref": "#/definitions/matlabFileFilenamePattern" }
              }
          },
          {
              "title": "PERL Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["PERL"]
                  },
                  "filename": { "$ref": "#/definitions/perlFileFilenamePattern" }
              }
          },
          {
              "title": "TIF Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["TIF"]
                  },
                  "filename": { "$ref": "#/definitions/tifFileFilenamePattern" }
              }
          },
          {
              "title": "R Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["R"]
                  },
                  "filename": { "$ref": "#/definitions/rFileFilenamePattern" }
              }
          },
          {
              "title": "SNP Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["SNP"]
                  },
                  "filename": { "$ref": "#/definitions/snpFileFilenamePattern" }
              }
          },
          {
              "title": "XML Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["XML"]
                  },
                  "filename": { "$ref": "#/definitions/xmlFileFilenamePattern" }
              }
          },
          {
              "title": "SVG Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["SVG"]
                  },
                  "filename": { "$ref": "#/definitions/svgFileFilenamePattern" }
              }
          },
          {
              "title": "PNG Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["PNG"]
                  },
                  "filename": { "$ref": "#/definitions/pngFileFilenamePattern" }
              }
          },
          {
              "title": "JPG Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["JPG"]
                  },
                  "filename": { "$ref": "#/definitions/jpgFileFilenamePattern" }
              }
          },
          {
              "title": "GTC Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["GTC"]
                  },
                  "filename": { "$ref": "#/definitions/gtcFileFilenamePattern" }
              }
          },
          {
              "title": "HDF5 Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["HDF5"]
                  },
                  "filename": { "$ref": "#/definitions/hdf5FileFilenamePattern" }
              }
          },
          {
            "title": "FAST5 Filename patternCheck",
            "properties": {
                "filetype": {
                    "enum": ["FAST5"]
                },
                "filename": { "$ref": "#/definitions/fast5FileFilenamePattern" }
            }
          },
          {
              "title": "PAIR Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["PAIR"]
                  },
                  "filename": { "$ref": "#/definitions/pairFileFilenamePattern" }
              }
          },
          {
              "title": "TXT Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["TXT"]
                  },
                  "filename": { "$ref": "#/definitions/txtFileFilenamePattern" }
              }
          },
          {
              "title": "BGI Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["BGI"]
                  },
                  "filename": { "$ref": "#/definitions/bgiFileFilenamePattern" }
              }
          },
          {
              "title": "BGEN Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["BGEN"]
                  },
                  "filename": { "$ref": "#/definitions/bgenFileFilenamePattern" }
              }
          },
          {
              "title": "GEN Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["GEN"]
                  },
                  "filename": { "$ref": "#/definitions/genFileFilenamePattern" }
              }
          },
          {
              "title": "PXF Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["PXF"]
                  },
                  "filename": { "$ref": "#/definitions/pxfFileFilenamePattern" }
              }
          },
          {
              "title": "LOOM Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["LOOM"]
                  },
                  "filename": { "$ref": "#/definitions/loomFileFilenamePattern" }
              }
          },
          {
              "title": "BAX.H5 Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["BAX.H5"]
                  },
                  "filename": { "$ref": "#/definitions/bax.h5FileFilenamePattern" }
              }
          },
          {
              "title": "BAS.H5 Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["BAS.H5"]
                  },
                  "filename": { "$ref": "#/definitions/bas.h5FileFilenamePattern" }
              }
          },
          {
              "title": "ASM Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["ASM"]
                  },
                  "filename": { "$ref": "#/definitions/asmFileFilenamePattern" }
              }
          },
          {
              "title": "CSI Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["CSI"]
                  },
                  "filename": { "$ref": "#/definitions/csiFileFilenamePattern" }
              }
          },
          {
              "title": "TBI Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["TBI"]
                  },
                  "filename": { "$ref": "#/definitions/tbiFileFilenamePattern" }
              }
          },
          {
              "title": "BCF Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["BCF"]
                  },
                  "filename": { "$ref": "#/definitions/bcfFileFilenamePattern" }
              }
          },
          {
              "title": "qual454 Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["qual454"]
                  },
                  "filename": { "$ref": "#/definitions/qual454FileFilenamePattern" }
              }
          },
          {
              "title": "qualsolid Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["qualsolid"]
                  },
                  "filename": { "$ref": "#/definitions/qualsolidFileFilenamePattern" }
              }
          },
          {
              "title": "FASTQ-illumina Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["FASTQ-illumina"]
                  },
                  "filename": { "$ref": "#/definitions/fastqIlluminaFileFilenamePattern" }
              }
          },
          {
              "title": "FASTQ-helicos Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["FASTQ-helicos"]
                  },
                  "filename": { "$ref": "#/definitions/fastqHelicosFileFilenamePattern" }
              }
          },
          {
              "title": "FASTQ-sanger Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["FASTQ-sanger"]
                  },
                  "filename": { "$ref": "#/definitions/fastqSangerFileFilenamePattern" }
              }
          },
          {
              "title": "FASTQ-solexa Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["FASTQ-solexa"]
                  },
                  "filename": { "$ref": "#/definitions/fastqSolexaFileFilenamePattern" }
              }
          },
          {
              "title": "SAM Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["SAM"]
                  },
                  "filename": { "$ref": "#/definitions/samFileFilenamePattern" }
              }
          },
          {
              "title": "CRAI Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["CRAI"]
                  },
                  "filename": { "$ref": "#/definitions/craiFileFilenamePattern" }
              }
          },
          {
              "title": "BAI Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["BAI"]
                  },
                  "filename": { "$ref": "#/definitions/baiFileFilenamePattern" }
              }
          },
          {
              "title": "MTX Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["MTX"]
                  },
                  "filename": { "$ref": "#/definitions/mtxFileFilenamePattern" }
              }
          },
          {
              "title": "MEX Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["MEX"]
                  },
                  "filename": { "$ref": "#/definitions/mexFileFilenamePattern" }
              }
          },
          {
              "title": "GMX Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["GMX"]
                  },
                  "filename": { "$ref": "#/definitions/gmxFileFilenamePattern" }
              }
          },
          {
              "title": "GMT Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["GMT"]
                  },
                  "filename": { "$ref": "#/definitions/gmtFileFilenamePattern" }
              }
          },
          {
              "title": "GRP Filename patternCheck",
              "properties": {
                  "filetype": {
                      "enum": ["GRP"]
                  },
                  "filename": { "$ref": "#/definitions/grpFileFilenamePattern" }
              }
          }
        ]        
      },

      "assayFiletypes": {
        "type": "object",
        "title": "Check: allowed filetypes for an assay",
        "description": "This object exists with the only purpose of being a reference list of the allowed filetypes of an assay (e.g. if the filetype is 'PY', it should not be accepted as raw data). It imitates the 'filetype' property with a subset of the allowed filetypes.",
        "required": ["filetype"],
        "properties": {
          "filetype": {
            "type": "string",
            "enum": [ "BAM", "CRAM", "SAM", "FASTA", "BAI", "CRAI", "CSI", "MD", "TXT", "XML", "MD5", "FASTQ", "FASTQ-helicos", "FASTQ-illumina", "BAS.H5", "BAX.H5", "HDF5", "FASTQ-sanger", "FASTQ-solexa", "IDAT", "CEL", "qualsolid", "qual454", "SRA", "SRF", "SFF", "CSFASTA", "GPR", "ADF", "FAST5" ]
          }
        }
      }
      ,

      "celFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a CEL file",
        "meta:propertyCurie": "format:1638",
        "description": "This object exists to hold the filename pattern that a 'CEL' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.cel(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.cel.gz.gpg" ]
      },

      "tsvFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a TSV file",
        "meta:propertyCurie": "format:3475",
        "description": "This object exists to hold the filename pattern that a 'TSV' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.tsv(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.tsv.gz.gpg" ]
      },

      "fastqFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ file",
        "meta:propertyCurie": "format:1930",
        "description": "This object exists to hold the filename pattern that a 'FASTQ' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(fastq|fq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fastq.gz.gpg" ]
      },

      "fastaFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FASTA file",
        "meta:propertyCurie": "format:1929",
        "description": "This object exists to hold the filename pattern that a 'FASTA' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(fasta|fa|frn|faa|ffn|fna|seq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fasta.gz.gpg" ]
      },

      "sdrfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SDRF file",
        "meta:propertyCurie": "NCIT:C172211",
        "description": "This object exists to hold the filename pattern that a 'SDRF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(tsv|sdrf)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sdrf.gz.gpg" ]
      },

      "idfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a IDF file",
        "meta:propertyCurie": "NCIT:C172212",
        "description": "This object exists to hold the filename pattern that a 'IDF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(tsv|idf)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.idf.gz.gpg" ]
      },

      "vcfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a VCF file",
        "meta:propertyCurie": "format:3016",
        "description": "This object exists to hold the filename pattern that a 'VCF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.vcf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.vcf.gz.gpg" ]
      },

      "sraFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SRA file",
        "meta:propertyCurie": "format:3698",
        "description": "This object exists to hold the filename pattern that a 'SRA' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.sra(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sra.gz" ]
      },

      "srfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SRF file",
        "meta:propertyCurie": "format:3017",
        "description": "This object exists to hold the filename pattern that a 'SRF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.srf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.srf.gz.gpg" ]
      },

      "sffFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SFF file",
        "meta:propertyCurie": "format:3284",
        "description": "This object exists to hold the filename pattern that a 'SFF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.sff(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sff.gz.gpg" ]
      },

      "bamFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BAM file",
        "meta:propertyCurie": "format:2572",
        "description": "This object exists to hold the filename pattern that a 'BAM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.bam(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bam.gpg" ]
      },

      "cramFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a CRAM file",
        "meta:propertyCurie": "format:3462",
        "description": "This object exists to hold the filename pattern that a 'CRAM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.cram(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.cram.gpg" ]
      },

      "xlsxFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a  file",
        "meta:propertyCurie": "format:3620",
        "description": "This object exists to hold the filename pattern that a 'XLSX' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.xlsx(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.xlsx.tar.gpg" ]
      },

      "csvFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a CSV file",
        "meta:propertyCurie": "format:3752",
        "description": "This object exists to hold the filename pattern that a 'CSV' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.csv(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.csv" ]
      },

      "bedFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BED file",
        "meta:propertyCurie": "format:3003",
        "description": "This object exists to hold the filename pattern that a 'BED' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.bed(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bed.gpg" ]
      },

      "idatFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a IDAT file",
        "meta:propertyCurie": "format:3578",
        "description": "This object exists to hold the filename pattern that a 'IDAT' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.idat(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.idat.zip" ]
      },

      "mapFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a MAP file",
        "meta:propertyCurie": "format:3285",
        "description": "This object exists to hold the filename pattern that a 'MAP' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.map(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.map.gpg" ]
      },

      "pedFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a PED file",
        "meta:propertyCurie": "format:3286",
        "description": "This object exists to hold the filename pattern that a 'PED' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(ped|tped)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.ped.gz.gpg" ]
      },

      "bimFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BIM file",
        "description": "This object exists to hold the filename pattern that a 'BIM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.bim(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bim.gz.gpg" ]
      },

      "famFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FAM file",
        "description": "This object exists to hold the filename pattern that a 'FAM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(fam|tfam)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fam.gz.gpg" ]
      },

      "txtFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a TXT file",
        "meta:propertyCurie": "format:2330",
        "description": "This object exists to hold the filename pattern that a 'TXT' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema. It can represent multiple types of data (e.g. an ADF file or a README file)",
        "pattern": "^[^<>:;,?\"*|/]+\\.(txt|TXT)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.txt.gz.gpg" ]
      },

      "expFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a EXP file",
        "meta:propertyCurie": "format:1631",
        "description": "This object exists to hold the filename pattern that a 'EXP' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(exp|EXP)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.exp.gz.gpg" ]
      },

      "gprFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a GPR file",
        "meta:propertyCurie": "format:3829",
        "description": "This object exists to hold the filename pattern that a 'GPR' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(gpr|GPR)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.gpr.gz.gpg" ]
      },

      "pyFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a PY file",
        "meta:propertyCurie": "format:3996",
        "description": "This object exists to hold the filename pattern that a 'PY' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(py|PY|pyc|pyo|pyd|ipynb)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.py.gz.gpg" ]
      },

      "shFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SH file",
        "description": "This object exists to hold the filename pattern that a 'SH' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(sh|SH)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sh.gpg" ]
      },

      "adfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a ADF (Array Design Format) file",
        "meta:propertyCurie": "NCIT:C172213",
        "description": "This object exists to hold the filename pattern that a 'ADF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(adf)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.adf.gz.gpg" ]
      },

      "md5FileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a MD5 file",
        "meta:propertyCurie": "data:2190",
        "description": "This object exists to hold the filename pattern that a 'MD5' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(md5|MD5)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.md5.gz.gpg" ]
      },

      "hapFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a HAP file",
        "description": "This object exists to hold the filename pattern that a 'HAP' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(hap|HAP)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.hap.gz.gpg" ]
      },

      "csfastaFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a CSFASTA file",
        "description": "This object exists to hold the filename pattern that a 'CSFASTA' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.csfasta(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.csfasta.gpg" ]
      },

      "locFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a LOC file",
        "description": "This object exists to hold the filename pattern that a 'LOC' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(loc|tsv)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.loc.gpg" ]
      },

      "tgzFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a TGZ file",
        "description": "This object exists to hold the filename pattern that a 'TGZ' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.tgz(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.tgz.gpg" ]
      },

      "zipFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a ZIP file",
        "meta:propertyCurie": "format:3987",
        "description": "This object exists to hold the filename pattern that a 'ZIP' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.zip(\\.gpg)?$",
        "examples": [ "my_file1.zip.gpg" ]
      },

      "htmlFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a HTML file",
        "meta:propertyCurie": "format:2331",
        "description": "This object exists to hold the filename pattern that a 'HTML' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.html(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.html.gpg" ]
      },

      "hicFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a HIC file",
        "description": "This object exists to hold the filename pattern that a 'HIC' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.hic(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.hic.gpg" ]
      },

      "tifFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a TIF file",
        "description": "This object exists to hold the filename pattern that a 'TIF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.tif(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.tif.gpg" ]
      },

      "mdFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a MD file",
        "description": "This object exists to hold the filename pattern that a 'MD' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(md|markdown)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.md.gpg" ]
      },

      "matlabFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a MATLAB file",
        "meta:propertyCurie": "format:4007",
        "description": "This object exists to hold the filename pattern that a 'MATLAB' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(M|m|MAT|mat)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.mat.gpg" ]
      },

      "perlFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a PERL file",
        "meta:propertyCurie": "format:3998",
        "description": "This object exists to hold the filename pattern that a 'PERL' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(pl|perl)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.pl.gpg" ]
      },

      "rFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a R file",
        "meta:propertyCurie": "format:3999",
        "description": "This object exists to hold the filename pattern that a 'R' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(r|R|rdata|rda)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.r.gpg" ]
      },

      "tarFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a TAR file",
        "meta:propertyCurie": "format:3981",
        "description": "This object exists to hold the filename pattern that a 'TAR' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.tar(\\.(gz|zip|rar|arj|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.tar.gz.gpg" ]
      },

      "snpFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SNP file",
        "description": "This object exists to hold the filename pattern that a 'SNP' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.snp(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.snp.zip.gpg" ]
      },

      "xmlFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a XML file",
        "meta:propertyCurie": "format:2332",
        "description": "This object exists to hold the filename pattern that a 'XML' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.xml(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.xml.gpg" ]
      },

      "svgFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SVG file",
        "meta:propertyCurie": "format:3604",
        "description": "This object exists to hold the filename pattern that a 'SVG' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.svg(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.svg.gpg" ]
      },

      "pngFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a PNG file",
        "meta:propertyCurie": "format:3603",
        "description": "This object exists to hold the filename pattern that a 'PNG' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.png(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.png.gpg" ]
      },

      "jpgFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a JPG file",
        "meta:propertyCurie": "format:3579",
        "description": "This object exists to hold the filename pattern that a 'JPG' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.jpg(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.jpg.gpg" ]
      },

      "gtcFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a GTC file",
        "description": "This object exists to hold the filename pattern that a 'GTC' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.gtc(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.gtc.gpg" ]
      },

      "hdf5FileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a HDF5 file",
        "meta:propertyCurie": "format:3590",
        "description": "This object exists to hold the filename pattern that a 'HDF5' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(h5|hdf5)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.h5.gpg" ]
      },

      "fast5FileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FAST5 file",
        "meta:propertyCurie": "format:3590",
        "description": "This object exists to hold the filename pattern that a 'FAST5' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.fast5(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fast5.gpg" ]
      },

      "pairFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a PAIR file",
        "description": "This object exists to hold the filename pattern that a 'PAIR' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.pair(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.pair.gpg" ]
      },

      "bgiFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BGI file",
        "description": "This object exists to hold the filename pattern that a 'BGI' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bgi(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bgi.gpg" ]
      },

      "bgenFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BGEN file",
        "description": "This object exists to hold the filename pattern that a 'BGEN' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bgen(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bgen.gpg" ]
      },

      "genFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a GEN file",
        "description": "This object exists to hold the filename pattern that a 'GEN' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.gen(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.gen.gpg" ]
      },

      "pxfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a PXF file",
        "description": "This object exists to hold the filename pattern that a 'PXF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(json|yaml)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.json.gpg" ]
      },

      "loomFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a LOOM file",
        "meta:propertyCurie": "format:3913",
        "description": "This object exists to hold the filename pattern that a 'LOOM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.loom(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.loom.gpg" ]
      },

      "bax.h5FileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BAX.H5 file",
        "description": "This object exists to hold the filename pattern that a 'BAX.H5' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(bax\\.h5|h5)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bax.h5.gpg" ]
      },

      "bas.h5FileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BAS.H5 file",
        "description": "This object exists to hold the filename pattern that a 'BAS.H5' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(bas\\.h5|h5)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bas.h5.gpg" ]
      },

      "asmFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a ASM file",
        "description": "This object exists to hold the filename pattern that a 'ASM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.asm(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.asm.gpg" ]
      },

      "csiFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a CSI file",
        "description": "This object exists to hold the filename pattern that a 'CSI' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.csi(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.csi.gpg" ]
      },

      "tbiFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a TBI file",
        "meta:propertyCurie": "format:3700",
        "description": "This object exists to hold the filename pattern that a 'TBI' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.tbi(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.tbi.gpg" ]
      },

      "bcfFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BCF file",
        "meta:propertyCurie": "format:3020",
        "description": "This object exists to hold the filename pattern that a 'BCF' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bcf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bcf.gpg" ]
      },

      "qual454FileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a QUAL454 file",
        "meta:propertyCurie": "format:3611",
        "description": "This object exists to hold the filename pattern that a 'QUAL454' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(qual454|qual)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.qual.gpg" ]
      },

      "qualsolidFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a QUALSOLID file",
        "meta:propertyCurie": "format:3610",
        "description": "This object exists to hold the filename pattern that a 'QUALSOLID' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(qualsolid|qual)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.qualsolid.gpg" ]
      },

      "fastqIlluminaFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ-ILLUMINA file",
        "meta:propertyCurie": "format:1931",
        "description": "This object exists to hold the filename pattern that a 'FASTQ-ILLUMINA' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(fastq|fq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fastq.gpg" ]
      },

      "fastqHelicosFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ-HELICOS file",
        "description": "This object exists to hold the filename pattern that a 'FASTQ-HELICOS' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(fastq|fq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fastq.gpg" ]
      },

      "fastqSangerFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ-SANGER file",
        "meta:propertyCurie": "format:1932",
        "description": "This object exists to hold the filename pattern that a 'FASTQ-SANGER' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(fastq|fq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fastq.gpg" ]
      },

      "fastqSolexaFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ-SOLEXA file",
        "meta:propertyCurie": "format:1933",
        "description": "This object exists to hold the filename pattern that a 'FASTQ-SOLEXA' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(fastq|fq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fastq.gpg" ]
      },

      "samFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a SAM file",
        "meta:propertyCurie": "format:2573",
        "description": "This object exists to hold the filename pattern that a 'SAM' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.sam(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sam.gpg" ]
      },

      "craiFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a CRAI file",
        "description": "This object exists to hold the filename pattern that a 'CRAI' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.crai(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.crai.gpg" ]
      },

      "baiFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a BAI file",
        "meta:propertyCurie": "format:3327",
        "description": "This object exists to hold the filename pattern that a 'BAI' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bai(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bai.gpg" ]
      },

      "mtxFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a MTX file",
        "meta:propertyCurie": "format:3916",
        "description": "This object exists to hold the filename pattern that a 'MTX' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.mtx(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.mtx.gpg" ]
      },

      "mexFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a MEX file",
        "description": "This object exists to hold the filename pattern that a 'MEX' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.mex(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.mex.gpg" ]
      },

      "gmxFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a GMX file",
        "description": "This object exists to hold the filename pattern that a 'GMX' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.gmx(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.gmx.gpg" ]
      },

      "gmtFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a GMT file",
        "description": "This object exists to hold the filename pattern that a 'GMT' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.gmt(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.gmt.gpg" ]
      },

      "grpFileFilenamePattern": {
        "type": "string",
        "title": "Filename pattern of a GRP file",
        "description": "This object exists to hold the filename pattern that a 'GRP' filetypeId would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.grp(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.grp.gpg" ]
      },

      "objectExternalAccession": {
        "type": "object",
        "title": "Object External accession",
        "description": "External accession property defining a reference to an external record in another resource. For example, a reference to a sequence deposited in NCBI's Nucleotide database (e.g. 'https://identifiers.org/nucleotide:T35715.1'); or a sample record in BioSamples (e.g. 'https://identifiers.org/biosample:SAMEA7616999').",
        "additionalProperties": false,
        "properties": {
          "objectExternalAccessionIdentifier": {
            "type": "object",
            "title": "Identifier of the external accession",
            "description": "Unique identifier of an external record. Its 'termId' (e.g. 'biosample:SAMEA7616999', 'pubmed:30962759', 'biostudies:S-EPMC3314381', etc.) shall follow CURIE format of ``prefix``:``accession``, where: (1) the prefix (e.g. 'biosample') is unique and assigned to the external resource at identifiers.org; (2) and the unique accession of the object (e.g. SAMEA7616999) should resolve to an existing record within the resource. If in doubt, use identifiers.org to resolve your external accession: 'https://identifiers.org/' + 'termId', e.g. 'https://identifiers.org/biosample:SAMEA7616999'",
            "allOf": [
              {
                "title": "Inherited ontologyTerm structure of termId and termLabel",
                "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
              }
            ]
          },
          "objectExternalAccessionURI": {
            "type": "string",
            "title": "URI of the external accession",
            "description": "Full or partial URL/URI of the external accession, for systems to resolve it. Should only be used in case identifiers.org does not contain a namespace for the required resource or the mapping to the URI from its identifier is faulty.",
            "allOf": [
              {
                "title": "General pattern of a URL/URI",
                "$ref": "./EGA.common-definitions.json#/definitions/urlUriPattern"
              }
            ],
            "examples": [ 
              "https://www.ebi.ac.uk/biosamples/samples/SAMN11716999",
              "https://pubmed.ncbi.nlm.nih.gov/19491253",
              "https://www.ebi.ac.uk/arrayexpress/experiments/E-MEXP-1712/"
            ]
          },
          "objectExternalAccessionDescription": {
            "type": ["string", "number"],
            "title": "Description of the external accession",
            "description": "Optional description of the external accession, used to add context to the identifier if applicable.",
            "examples": [ 
              "taken from biosample temporarily",
              "Ensembl's part of the accessions",
              "first",
              2,
              "Recurrent Erythema Nodosum in a Child with a SHOC2 Gene Mutation" ]
          }
        },
        "anyOf": [
          {
            "title": "Either the identifier is needed",
            "required": ["objectExternalAccessionIdentifier"]
          },
          {
            "title": "Or the reference is needed",
            "required": ["objectExternalAccessionURI"]
          }
        ]
      },

      "sampleLabelAssociation": {
        "type": "object",
        "title": "Repeatable Sample-label node",
        "description": "The base node of a label-sample association. One form of basic identification of the sample (inherited from objectCoreId - e.g. either the center name and alias or the accession) is required, as well as the label per se.",
        "required": ["arrayLabel", "objectId"],
        "additionalProperties": false,
        "properties": {
          "arrayLabel": { 
            "title": "Labelling dye used with the sample",
            "$ref": "./EGA.common-definitions.json#/definitions/arrayLabel" 
          },
          "objectId": {
            "type": "object",
            "title": "Object's IDs block",
            "allOf": [
              {
                "title": "Inherited objectCoreId object",
                "$ref": "./EGA.common-definitions.json#/definitions/objectCoreId"
              },
              {
                "title": "Check that sample EGA ID (EGAN) pattern is correct",
                "properties": {
                  "egaAccession": {
                    "$ref": "./EGA.common-definitions.json#/definitions/EGASampleIdPattern"
                  }
                }
              }
            ]       
          }
        }
      },

      "oneRelationshipEnd": {
        "type": "object",
        "title": "Relationship's object (either source or target)",
        "description": "Node containing metadata (identifiers and the type of reference) of one of the ends of the relationship, whether it is the source or the target of the relationship.",
        "additionalProperties": false,
        "required": ["objectId", "objectType"],
        "properties": {
          "objectId": {
            "type": "object",
            "title": "Relationship's object's IDs block",
            "description": "Node containing the main identifiers of the relationship's object (e.g. alias, centerName...), inherited from the common definitions (#/definitions/objectCoreId).",
            "allOf": [
              { 
                "title": "Inherited objectCoreId object", 
                "$ref": "./EGA.common-definitions.json#/definitions/objectCoreId" 
              }
            ]
          },
          "objectType": {
            "type": "string",
            "title": "Type of the relationship's object",
            "description": "Type of the relationship's object, chosen from a list of CV (e.g. experiment, dataset, externalURL...). Both the source or target types can be: (1) the object tag of one of EGA's object (e.g. file, sample...); (2) an 'externalAccession'; (3) or an 'externalURL'. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "enum": ["experiment", "study", "sample", "individual", "submission", "assay", "dataset", "analysis", "policy", "DAC", "protocol", "externalAccession", "externalURL"],
            "meta:enum": {
              "experiment": "Contains information about the experimental design of the sequencing",
              "study": "Information about the study",
              "sample": "Information about the used samples",
              "individual": "Information about the participants (i.e. humans) of the study",
              "submission": "Information about the submission actions",
              "assay": "Contains information about the specific assays (either sequencing or array assays) from the experiment",
              "dataset": "Contains the collection of assay/analysis data files to be subject to controlled access",
              "analysis": "Contains the analysis metadata and data files",
              "policy": "Contains information related to the Data Access Agreement (DAA) the dataset is subject to",
              "DAC": "Contains information about the Data Access Committee (DAC)",
              "protocol": "Contains information about a planned process.",
              "externalAccession": "An external accession among the ones Entrez (NCBI's text search) contemplates (search for the terms here: https://www.ncbi.nlm.nih.gov/entrez/eutils/einfo.fcgi?)",
              "externalURL": "An external URL resource, of any type"
            },
            "examples": [ "sample" ]
          }
        },
        "allOf": [
          { 
            "title": "Check for objectId and objectType to match",
            "$ref": "./EGA.common-definitions.json#/definitions/objectIdAndObjectTypeCheck" 
          }
        ]        
      },

      "subjectId": {
        "type": "string",
        "title": "Subject ID",
        "description": "A unique identifier (e.g. 'Donor-10031') for the subject the sample derives from, providing context for the sample to be better understood through its provenance. It **shall not** contain personal sensitive data, since it will be publicly displayed for queries and searches.",
        "minLength": 1,
        "examples": [ "Donor-10031", "ID001", "9001", "AX_Dli" ]
      },

      "biologicalSex": {
        "type": "string",
        "title": "Biological sex of the individual",
        "meta:propertyCurie": "PATO:0000047",
        "description": "An organismal quality inhering in a bearer by virtue of the bearer's physical expression of sexual characteristics. In other words, the trait that determines the individual's (from which the sample derives) reproductive function: mainly male or female. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
        "enum": [ "male", "female", "hermaphrodite", "pseudohermaphrodite","unknown" ],
        "meta:enum": { 
          "male": "[PATO:0000384]: A biological sex quality inhering in an individual or a population whose sex organs contain only male gametes.",
          "female": "[PATO:0000383]: A biological sex quality inhering in an individual or a population that only produces gametes that can be fertilised by male gametes.",
          "hermaphrodite": "[PATO:0001340]: An organism having both male and female sexual characteristics and organs. A biological sex quality inhering in an organism or a population with both male and female sexual organs in one individual.",
          "pseudohermaphrodite": "[PATO:0001827]: A biological sex quality inhering in an individual or a population by virtue of having internal reproductive organs of one sex and external sexual characteristics of the other sex.",
          "unknown": "[NCIT:C17998]: The biological sex is unknown, not assesed or not available." 
        },
        "examples": [ "male" ]
      },

      "organismDescriptor": {
        "type": "object",
        "title": "Organism [OBI:0100026] descriptor block",
        "description": "This property describes the material entity the sample consists in. That is, an individual living system, such as animal, plant, bacteria or virus, that is capable of replicating or reproducing, growth and maintenance in the right environment. An organism may be unicellular or, like humans, made up of many billions of cells divided into specialized tissues and organs. This node is of special interest in case the provenance of the sample is not human (e.g. microbiota taken from a donor). Unless stated otherwise, given the nature of the EGA, it is expected to be of human provenance.",
        "additionalProperties": false,
        "required": ["organismTaxon"],
        "properties": {
          "organismTaxon": {
            "type": "object",
            "title": "NCBI Taxon of the organism",
            "meta:propertyCurie": "APOLLO_SV:00000203",
            "description": "Taxonomic classification of the organism (e.g. 'NCBITaxon:9606' and 'homo sapiens' for humans) curated by the NCBI Taxonomy (search for organisms here: https://www.ncbi.nlm.nih.gov/taxonomy; or use the OLS: https://www.ebi.ac.uk/ols/ontologies/ncbitaxon). You can find further details at 'https://www.uniprot.org/help/taxonomic_identifier'. This is appropriate for individual organisms and some environmental samples.",
            "allOf": [
              {
                "title": "Inherited ontologyTerm structure of termId and termLabel",
                "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
              }
            ],
            "properties": {        
              "termId": {
                "title": "Ontology constraints for this specific termId",
                "graphRestriction":  {
                  "ontologies" : ["obo:ncbitaxon"],
                  "classes": ["NCBITaxon:1"],
                  "relations": ["rdfs:subClassOf"],
                  "direct": false,
                  "include_self": false
                },
                "examples": [ "NCBITaxon:9606", "NCBITaxon:155900", "NCBITaxon:408170", "NCBITaxon:447426" ]
              }
            }
          },
          "commonName": {
            "type": "string",
            "title": "Biologic entity classification common name",
            "meta:propertyCurie": "NCIT:C164690",
            "description": "Common name (e.g. 'human') used to designate a plant, animal or other organism, as opposed to the scientific name.",
            "minLength": 1,
            "examples": [ "human", "goat", "horse" ]
          }
        }
      },

      "schemaDescriptor": {
        "type": "object",
        "title": "Schema descriptor",
        "description": "This node is intended to be used to describe the schemas and standards that a JSON document was based on. For instance, if a sample.json document was created to be validated against EGA.sample.json schema version 1.0.0, such information should be reflected in this block. This way, both a human and a machine can interpret and validate the JSON document efficiently, without the need of guessing versions.",
        "additionalProperties": false,
        "required": ["objectType", "describedBySchemaUri", "objectSchemaVersion", "commonSchemaVersion"],
        "properties": {
          "objectType": {
            "type": "string",
            "title": "Type of the object",
            "description": "Type of the object (e.g. 'sample') the JSON document describes.",
            "enum": [ "experiment", "study", "sample", "individual", "submission", "assay", "dataset", "analysis", "policy", "DAC", "protocol", "object-set" ]
          },
          "describedBySchemaUri": {
            "type": "string",
            "title": "URI of the schema",
            "description": "URI of the schema that describes the JSON document (e.g. 'my_sample.json')",
            "allOf": [
              {
                "title": "General pattern of a URL/URI",
                "$ref": "./EGA.common-definitions.json#/definitions/urlUriPattern"
              }
            ],
            "examples": ["https://raw.githubusercontent.com/EbiEga/ega-metadata-schema/main/schemas/EGA.analysis.json"]
          },
          "objectSchemaVersion": {
            "type": "string",
            "title": "Version of the object's schema",
            "description": "The version of the object's schema, the one specific for the object the JSON document corresponds to (e.g. 'EGA.sample.json'), not the common definitions schema's version (i.e. 'EGA.common-definitions.json').",
            "allOf": [
              {
                "title": "Check semantic versioning pattern",
                "$ref": "./EGA.common-definitions.json#/definitions/semanticVersioningPattern"
              }
            ]
          },
          "commonSchemaVersion": {
            "type": "string",
            "title": "Version of the common definition's schema",
            "description": "The version of the common definition's schema, the one containing all shared definitions (i.e. 'EGA.common-definitions.json'), not the one specific to the object described by the JSON document (e.g. 'EGA.sample.json').",
            "allOf": [
              {
                "title": "Check semantic versioning pattern",
                "$ref": "./EGA.common-definitions.json#/definitions/semanticVersioningPattern"
              }
            ]
          }
        }
      },

      "semanticVersioningPattern": {
        "type": "string",
        "title": "Semantic versioning pattern",
        "description": "This object exists to hold the pattern that semantic versioning has, for it to be referenced elsewhere within this (or other) JSON schema. For further details about semantic versioning check 'https://semver.org/'",
        "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
        "examples": [ "2.5.1" ]
      },
      
      "contactDetails": {
        "type": "object",
        "title": "Contact details",
        "description": "An object to contain the required metadata to identify and reach an individual or institution. Used, for instance, to list who needs to be informed (1) in case of a erroneous submission (2) or in case access to a dataset is requested by a user.",
        "additionalProperties": false,
        "required": ["emailAddress"],
        "properties": {
          "individualFullName": {
            "type": "string",
            "title": "Full name of an individual",
            "description": "A full set of all personal names by which an individual is known and that can be recited as a word-group, with the understanding that, taken together, they all relate to that one individual. In case there are several, separate them with semicolons (;).",
            "minLength": 1,
            "examples": [ "Wayne Jr., Bruce" ]
          },
          "institutionName": {
            "type": "string",
            "title": "Institution name",
            "description": "The full name of an institution the contact belongs to. In case there are several, separate them with semicolons (;).",
            "minLength": 1,
            "examples": [ "European Genome-phenome Archive (EGA)" ]
          },
          "emailAddress": {
            "type": "string",
            "title": "Email address",
            "description": "Current email address that would be used in case the contact needs to be reached. Its expected format is of a local-part (e.g. 'myname'), followed by an 'at' sign (i.e. '@') and the domain of the address (e.g. 'gmail.com' or 'ebi.ac.uk').",
            "pattern": "^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$",
            "examples": [ "myname@ebi.ac.uk" ]
          },
          "phoneNumber": {
            "type": "string",
            "title": "Phone number",
            "description": "Current phone number that would be used in case the contact needs to be reached. Theoretically would only be used in case the email address was not provided, does not exist or is unresponsive.",
            "pattern": "^\\+?\\(?[0-9]{1,4}\\)?[-\\s\\./0-9]+$",
            "examples": [ "+44 7427512529" ]
          }          
        },
        "anyOf": [
          { 
            "title": "Either the individual's name is required.",
            "required": ["individualFullName"]
          },
          {
            "title": "Or the institution's name is required.",
            "required": ["institutionName"]
          }
        ]        
      },

      "studyDesignKeywords": {
        "type": "string",
        "title": "Enumeration of design keywords",
        "meta:propertyCurie": "EFO:0001426",
        "description": "An object containing the enumeration of multiple study-design keywords, to be inherited at their respective nodes. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
        "enum": ["RNA stability design", "binding site identification design", "case control design", "cell component comparison design", "cell cycle design", "cell type comparison design", "cellular modification design", "clinical history design", "compound treatment design", "cross sectional design", "development or differentiation design", "disease state design", "dose response design", "twin design", "genetic modification design", "genotype design", "growth condition design", "imprinting design", "injury design", "innate behavior design", "organism part comparison design", "organism status design", "pathogenicity design", "population based design", "sex design", "species design", "stimulus or stress design", "strain or line design", "time series design", "family based design", "genotyping design", "mobile element identification design", "operon identification design", "secreted protein identification design", "translational bias design", "transposable element identification design", "hardware variation design", "normalization testing design", "operator variation design", "optimization design", "quality control testing design", "reference design", "replicate design", "software variation design", "validation by real time PCR design", "validation by reverse transcription PCR design"],
        "meta:enum": {
          "RNA stability design": "[EFO:0001783]",
          "binding site identification design": "[EFO:0004664]",
          "case control design": "[EFO:0001427]",
          "cell component comparison design": "[EFO:0001743]",
          "cell cycle design": "[EFO:0001744]",
          "cell type comparison design": "[EFO:0001745]",
          "cellular modification design": "[EFO:0004666]",
          "clinical history design": "[EFO:0001780]",
          "compound treatment design": "[EFO:0001755]",
          "cross sectional design": "[EFO:0001428]",
          "development or differentiation design": "[EFO:0001746]",
          "disease state design": "[EFO:0001756]",
          "dose response design": "[EFO:0001757]",
          "twin design": "[EFO:0001431]",
          "genetic modification design": "[EFO:0001758]",
          "genotype design": "[EFO:0001748]",
          "growth condition design": "[EFO:0001759]",
          "imprinting design": "[EFO:0001747]",
          "injury design": "[EFO:0001760]",
          "innate behavior design": "[EFO:0001749]",
          "organism part comparison design": "[EFO:0001750]",
          "organism status design": "[EFO:0001751]",
          "pathogenicity design": "[EFO:0001761]",
          "population based design": "[EFO:0001430]",
          "sex design": "[EFO:0001752]",
          "species design": "[EFO:0001753]",
          "stimulus or stress design": "[EFO:0001762]",
          "strain or line design": "[EFO:0001754]",
          "time series design": "[EFO:0001779]",
          "family based design": "[EFO:0001429]",
          "genotyping design": "[EFO:0001784]",
          "mobile element identification design": "[EFO:0005693]",
          "operon identification design": "[EFO:0001785]",
          "secreted protein identification design": "[EFO:0001786]",
          "translational bias design": "[EFO:0001787]",
          "transposable element identification design": "[EFO:0005692]",
          "hardware variation design": "[EFO:0001767]",
          "normalization testing design": "[EFO:0001771]",
          "operator variation design": "[EFO:0001772]",
          "optimization design": "[EFO:0001773]",
          "quality control testing design": "[EFO:0001774]",
          "reference design": "[EFO:0001775]",
          "replicate design": "[EFO:0001776]",
          "software variation design": "[EFO:0001778]",
          "validation by real time PCR design": "[OBI:0001166]",
          "validation by reverse transcription PCR design": "[OBI:0001162]" 
        },
        "examples": [ "RNA stability design" ]
      },

      "locusIdentifier": {
        "type": "object",
        "title": "Locus identifier",
        "description": "Node to unambiguously identify loci [OGI:0000022]: the unique chromosomal location defining the position of an individual gene or DNA sequence. This node shall be used to precisely define: (1) the organism of said locus; (2) the gene and other genomic feature references in other accessions; (3) the genomic sequence per se, including its assembly and position. These details, in different combinations, shall allow identification of any genomic feature, such as SNPs (e.g. coordinates of a variant) or genes (e.g. PT53).",
        "required": ["organismDescriptor", "lociDescriptor"],
        "additionalProperties": false,
        "properties": {
          "organismDescriptor": {
            "title": "Organism descriptor",
            "description": "Node to identify the specific organism the locus belongs to.",
            "$ref": "./EGA.common-definitions.json#/definitions/organismDescriptor"
          },
          "lociDescriptor": {
            "type": "array",
            "title": "Loci context array",
            "description": "Array of locus context items. Multiple loci can be described in the array if the organism remains the same.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "object",
              "title": "Locus context item",
              "description": "Node providing the context of the locus: its sequence, coordinates, encompassed genes...",
              "properties": {
                "geneDescriptor": {
                  "title": "Gene descriptor",
                  "description": "Node to identify the gene of the locus of interest.",
                  "$ref": "./EGA.common-definitions.json#/definitions/geneDescriptor"
                },
                "genomicSequenceDescriptor": {
                  "title": "Genomic sequence descriptor",
                  "description": "Node to describe the sequence per se, instead of referencing it.",
                  "$ref": "./EGA.common-definitions.json#/definitions/genomicSequenceDescriptor"
                },
                "locusExternalReference": {
                  "title": "External reference of the locus",
                  "description": "If the locus can not be identified by a gene (if so, use 'geneDescriptor'), and it is well represented (i.e. uniquely identifiable and with comprehensive detail) in another resource that is accessible and persistent, one can reference it here instead of providing all their details. In other words, one can reference here ways to access the locus information that is accessible elsewhere. For example miRNA 'MI0039740' (mirbase:MI0039740) that lacks a gene descriptor.",
                  "$ref": "./EGA.common-definitions.json#/definitions/objectExternalAccession"
                },
                "locusAdditionalDescription": {
                  "type": "string",
                  "title": "Additional description of the locus",
                  "description": "Optional free-text description of the locus to add any additional context.",
                  "minLength": 1,
                  "examples": ["Targeted locus number 1 out of 3 possible loci that our experimental procedure aimed at.", "The locus corresponds to a variant version of the defined gene, only existing in patients with X disease."]
                }
              },
              "anyOf": [
                {
                  "title": "Either the gene description is given",
                  "required": ["geneDescriptor"]
                },
                {
                  "title": "Or the genomic sequence context",
                  "required": ["genomicSequenceDescriptor"]
                },
                {
                  "title": "Or an external reference to the locus context",
                  "required": ["locusExternalReference"]
                }
              ]
            }            
          }
        }
      },

      "geneDescriptor": {
        "type": "object",
        "title": "Gene descriptor",
        "description": "Node to uniquely identify a gene [SO:0000704]: a region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. For human genes, the standard is to use nomenclature provided by the HUGO Gene Nomenclature Committee (HGNC).",
        "required": ["geneIdentifier"],
        "additionalProperties": false,
        "properties": {
          "geneIdentifier": {
            "type": "object",
            "title": "Gene identifier",
            "description": "Property uniquely identifying a gene. It consists of a 'termId' and 'termLabel', which correspond to: (1)  'termId': A unique (and typically persistent) identifier of a gene in a database, that is (typically) different to the gene name/symbol (e.g. HGNC:11535 for gene TAF1). There are 2 types of allowed databases to reference: NCBIGene and HGNC. Other archives' accessions (e.g. ensembl:ENSDARG00000035330) can be cross referenced with NCBIGene to obtain its gene ID (e.g. ncbigene:555452). (2) 'termLabel': the official gene symbol (e.g. 'TAF1'). It is typically derived from the gene name. There are several resources to search for a gene of interest, although we recommend [NCBI's service](https://www.ncbi.nlm.nih.gov/gene). For example: in the case of human genes, the symbol follows [HGNC](https://www.genenames.org/)'s nomenclature, while in the case of mice genes they are provided by [MGI](http://www.informatics.jax.org/).",
            "meta:propertyCurie": "data:1025",
            "allOf": [
              {
                "title": "Inherited ontologyTerm structure of termId and termLabel",
                "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
              }
            ],
            "properties": {        
              "termId": {
                "title": "Ontology constraints for this specific termId",
                "anyOf": [
                  {
                    "title": "NCBI Gene pattern (e.g. 'NCBIGene:100010')",
                    "$ref": "./EGA.common-definitions.json#/definitions/curieNcbiGeneIdentifierPattern"
                  },
                  {
                    "title": "HGNC Gene pattern (e.g. 'hgnc:2674')",
                    "$ref": "./EGA.common-definitions.json#/definitions/curieHgncIdentifierPattern"
                  }
                ],
                "examples": [ "NCBIGene:100010", "hgnc:2674" ]
              }
            }
          },
          "geneDescription": {
            "type": "string",
            "title": "Description of the gene",
            "description": "Free-text description of the gene, only to be used to provide additional context that would otherwise be impossible to add encoded in the schema. In other words, kindly refrain from providing alternative gene identifiers in the description, when they could be added at 'alternateGeneIdentifiers'.",
            "minLength": 1,
            "examples": [ 
              "In the mutated cells, the only difference with the reference gene is that at locus ... position +23 was modified: thymine was transitioned to cytosine (T-C)..." 
            ]
          },
          "alternateGeneIdentifiers": {
            "type": "array",
            "title": "Alternate gene identifiers",
            "description": "Array of alternate identifiers for this gene. This array can be used to provide any other alternate gene identifiers that refer to a gene, including previously approved gene symbols, Ensembl identifiers, gene transcripts (e.g. 'ensembl:ENST00000423759'), etcetera.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "object",
              "title": "Alternate gene identifier item",
              "description": "One of the possible alternate gene identifiers for the designated gene. The 'termId' of these elements, contrary to the main identifier, can include references to other resources beyond NCBI and HGNC (e.g. 'OMIM:600296', 'ensembl:ENST00000423759', 'ucsc:uc003ldc.6', etcetera).",
              "meta:propertyCurie": "data:1025",
              "allOf": [
                {
                  "title": "Inherited ontologyTerm structure of termId and termLabel",
                  "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
                }
              ]
            }
          },
          "relatedGeneIdentifiers": {
            "type": "array",
            "title": "Related (not equivalent) gene identifiers",
            "description": "Array of related identifiers (e.g. termIds 'VGNC:97422', 'MGI:2385071', 'RGD:1305712' for gene ETF1). This field can be used to provide identifiers to resources representing related, but not equivalent gene identifiers. For example: paralog, analog or ortholog identifiers.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "object",
              "title": "Related gene identifier item",
              "meta:propertyCurie": "data:1025",
              "allOf": [
                {
                  "title": "Inherited ontologyTerm structure of termId and termLabel",
                  "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
                }
              ]            
            }
          }
        }
      },

      "ncbiAssemblyDescriptor": {
        "type": "object",
        "title": "NCBI's Assembly descriptor",
        "meta:propertyCurie": "topic:0196",
        "description": "Node describing a sequence assembly referenced in [NCBI's Assembly database](https://www.ncbi.nlm.nih.gov/assembly). Assembly is a database providing information on the structure of assembled genomes, assembly names and other meta-data, statistical reports, and links to genomic sequence data. An assembly is defined as the set of chromosomes, unlocalized and unplaced (sometimes called 'random') and alternate sequences used to represent an organism's genome. Assemblies are constructed from 1 or more assembly units.",
        "additionalProperties": false,
        "required": [ "ncbiAssembly" ],
        "properties": {
          "ncbiAssembly": {
            "type": "object",
            "title": "NCBI Assembly",
            "description": "Node defining an Assembly (e.g. 'GCF_000001405.26'). For example, the assembly accession for the GenBank version of the public human reference assembly ('termLabel' being 'GRCh38.p14') is 'GCA_000001405.29' ('termId'). See further details here: https://www.ncbi.nlm.nih.gov/assembly/model/.",
            "allOf": [
              {
                "title": "Inherited ontologyTerm structure of termId and termLabel",
                "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
              }
            ],
            "properties": {        
              "termId": {
                "title": "Ontology constraints for this specific termId",
                "allOf": [
                  {
                    "title": "NCBI's assembly CURIE pattern",
                    "$ref": "./EGA.common-definitions.json#/definitions/curieNcbiAssemblyPattern"
                  }
                ],
                "examples": ["assembly:GCF_000001405.26", "assembly:GCA_000001405.1", "assembly:GCF_000005845.2" ]
              }
            }
          },
          "ncbiAssemblyUnit": {
            "type": "object",
            "title": "NCBI assembly unit",
            "description": "NCBI's identifier of the assembly unit. An assembly unit is defined as the collection of sequences used to define discrete parts of an assembly. Commonly, assembly units are entire chromosomes (e.g. Chromosome 1 of human genome), scaffolds or different types of sequences (e.g. Mitochondrial DNA). Again, it follows an 'ontologyTerm' structure, having a 'termId' (e.g. 'refseq:NC_000001.11') and 'termLabel' (e.g. 'chromosome 1'). See further details here: https://www.ncbi.nlm.nih.gov/assembly/model/.",
                "allOf": [
              {
                "title": "Inherited ontologyTerm structure of termId and termLabel",
                "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
              }
            ],
            "properties": {        
              "termId": {
                "title": "Ontology constraints for this specific termId",
                "examples": ["refseq:NC_000001.11", "refseq:NC_012920.1"]
              }
            }
          }
        }
      },

      "genomicSequenceDescriptor": {
        "type": "object",
        "title": "Genomic sequence descriptor",
        "meta:propertyCurie": "GENO:0000960",
        "description": "Node used to describe with sufficient detail a genomic sequence (e.g. Human Chromosome X: 71366222-71532374 forward strand), defined as a biological sequence that is of genomic origin (i.e. carries sequence from the genome of a cell or organism).",
        "additionalProperties": false,
        "properties": {
          "assemblyDescriptor": {
            "title": "Assembly descriptor",
            "meta:propertyCurie": "topic:0196",
            "description": "Node to identify the assembly of the locus of interest.",
            "$ref": "./EGA.common-definitions.json#/definitions/ncbiAssemblyDescriptor"
          },
          "sequenceCoordinates": {
            "title": "DNA Sequence coordinates",
            "description": "Node to define que specific sequence coordinates of the genomic feature within the assembly.",
            "$ref": "./EGA.common-definitions.json#/definitions/sequenceCoordinates"
          },
          "dnaSequenceStrand": {
            "title": "DNA Sequence strand",
            "$ref": "./EGA.common-definitions.json#/definitions/dnaSequenceStrand"
          },
          "nucleicAcidSequence": {
            "title": "Nucleic acid sequence of the locus",
            "$ref": "./EGA.common-definitions.json#/definitions/nucleicAcidSequence"
          }
        },
        "anyOf": [
          {
            "title": "Either the full position context is given",
            "required": ["assemblyDescriptor", "sequenceCoordinates", "dnaSequenceStrand"]
          },
          {
            "title": "Or at least the sequence itself is given",
            "required": ["nucleicAcidSequence"]
          }
        ]
      },

      "sequenceCoordinates": {
        "type": "object",
        "title": "Sequence coordinates",
        "meta:propertyCurie": "data:2012",
        "description": "A position in a map (for example a genetic map), either a single position (e.g. 71366222) or a region interval (e.g. 71366222-71532374). Used to define coordinates within an assembly unit.",
        "additionalProperties": false,
        "properties": {
          "singlePosition": {
            "title": "Single position",
            "$ref": "./EGA.common-definitions.json#/definitions/singleSequencePosition"
          },
          "sequenceInterval": {
            "type": "object",
            "title": "Sequence interval",
            "meta:propertyCurie": "GENO:0000902",
            "description": "The location of a sequence feature in a genome, defined by its start (e.g. 71366222) and end (e.g. 71532374) position on some reference genomic coordinate system. Positions are always represented by contiguous spans using interbase coordinates or coordinate ranges. Both coordinates are inclusive: the sequence bounds are included in the described genomic feature. In other words, if the sequence interval is 71366222-71532374, both 71366222 and 71532374 coordinates are included in the feature.",
            "required": ["start", "end"],
            "additionalProperties": false,
            "properties": {
              "start": {
                "title": "Start position",
                "$ref": "./EGA.common-definitions.json#/definitions/singleSequencePosition"
              },
              "end": {
                "title": "End position",
                "$ref": "./EGA.common-definitions.json#/definitions/singleSequencePosition"
              }
            }
          }
        },
        "anyOf": [
          {
            "title": "Either a single position is given",
            "required": ["singlePosition"]
          },
          {
            "title": "Or the whole sequence interval",
            "required": ["sequenceInterval"]
          }
        ]
      },

      "dnaSequenceStrand": {
        "type": "string",
        "title": "DNA Sequence strand",
        "description": "DNA sequence is double-stranded. By convention, for a reference chromosome, one whole strand is designated the 'forward strand' and the other the 'reverse strand'. This designation is arbitrary and sometimes the terms 'plus strand' and 'minus strand', respectively, are used instead. A genomic feature can live on a DNA strand in one of two orientations. For instance, a gene is said to have a coding strand (also known as its 'sense strand'), and a template strand (also known as its 'antisense strand'), which can be forward or reverse strands depending on which contain the nucleotide sequence the RNA polymerase reads to create its RNA product. Annotations such as Ensembl and UCSC are concerned with the coding sequences of genes, so when they say a gene is on the forward strand, it means the gene's coding sequence is on the forward strand. To follow through again, that means that during transcription of this forward-strand gene, the gene's template sequence is read from the reverse strand, producing an mRNA that matches the sequence on the forward strand. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
        "enum": ["forward", "reverse"],
        "meta:enum": {
          "forward": "Forward strand [ENSGLOSSARY:0000369]: DNA strand arbitrary defined as the strand with its 5' end at the tip of the short chromosome arm (p). If a gene is forward-stranded, its sense (sequence matching cDNA) is on the forward strand. Forward strand is reverse complementary to the reverse strand.",
          "reverse": "Reverse strand [ENSGLOSSARY:0000370]: DNA strand arbitrary defined as the strand with its 5' end at the tip of the long chromosome arm (q). If a gene is reverse-stranded, its sense (sequence matching cDNA) is on the reverse strand. Reverse strand is reverse complementary to the forward strand." 
        }
      },

      "nucleicAcidSequence": {
        "type": "string",
        "title": "Nucleic acid sequence",
        "meta:propertyCurie": "data:2977",
        "description": "Sequence of characters representing a specific nucleic (i.e. molecular species - e.g. Adenine) or groupings of these (through ambiguity codes), using [one-letter IUPAC abbreviations](https://en.wikipedia.org/wiki/International_Union_of_Pure_and_Applied_Chemistry#Amino_acid_and_nucleotide_base_codes).",
        "pattern": "^([\\.-]*[ACGTURYKMSWBDHVNX]+[\\.-]*)+$",
        "examples": ["ACTGCCG", "CTGCGCGCGCT", "KM-AGT-X-N"]        
      },

      "singleSequencePosition": {
        "type": "number",
        "title": "Single sequence position",
        "description": "A single 1-based (first base of the assembly unit is 1, not 0) sequence coordinate, inclusive. It can be used to describe the start or end coordinates of a sequence interval, or directly a single coordinate within a sequence.",
        "minInclusive": 1,
        "examples": [71366222, 36592394, 1]
      },

      "curieGeneralPattern": {
        "type": "string",
        "title": "Compact URI (CURIE) pattern",
        "description": "A [W3C Compact URI](https://www.w3.org/TR/curie/) formatted string. A CURIE string has the structure ``prefix``:``reference``, as defined by the W3C syntax. Even though we do not restrict prefixes, we recommend that the term used as ``prefix`` is uniformely resolved. In other words, it is better to use prefixes (e.g. 'ensembl') from identifiers.org.",
        "minLength": 1,
        "pattern": "^\\w[^:]*:.+$",
        "examples": ["ensembl:ENSG00000139618", "HGNC:11535", "data:1026", "EFO:0003815"]
      },

      "curieRefseqPattern": {
        "type": "string",
        "title": "RefSeq accessions' [data:1098] CURIE pattern",
        "description": "The Reference Sequence (RefSeq) CURIEs take the structure of ``refseq``:``accession``. [RefSeq accessions](https://registry.identifiers.org/registry/refseq) [data:1098] have special prefixes (e.g. 'NM_' for protein-coding transcripts - mRNA) based on the category of the object. The accession can also have a version attached as a suffix (e.g. '.23'). Their records are integrated into [NCBI's resources](https://www.ncbi.nlm.nih.gov/refseq/) including the Nucleotide, Protein, and BLAST databases and can be easily identified by the keyword 'RefSeq' and by their distinct accession prefixes that define their type (see further details at [doi:10.1093/nar/gkv1189](https://academic.oup.com/nar/article/44/D1/D733/2502674).",
        "pattern": "^(RefSeq|refseq):",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "./EGA.common-definitions.json#/definitions/curieGeneralPattern"
          }
        ],        
        "oneOf": [
          {
            "title": "NC - Molecule type: DNA",
            "Description": "Use context: Chromosomes; Linkage Groups",
            "pattern": "^[^:]+:NC_\\d+(\\.\\d+)?$"
          },
          {
            "title": "AC - Molecule type: DNA",
            "Description": "Use context: Chromosomes; Linkage Groups",
            "pattern": "^[^:]+:AC_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NZ - Molecule type: DNA",
            "Description": "Use context: Chromosomes; Scaffolds; Used predominantly for prokaryotic genomes.",
            "pattern": "^[^:]+:NZ_[A-Z]{2,4}\\d+(\\.\\d+)?$"
          },
          {
            "title": "NT - Molecule type: DNA",
            "Description": "Use context: Scaffolds",
            "pattern": "^[^:]+:NT_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NW - Molecule type: DNA",
            "Description": "Use context: Scaffolds",
            "pattern": "^[^:]+:NW_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NG - Molecule type: DNA",
            "Description": "Use context: Genomic regions; A genomic region record may represent a single or multiple genetic loci (e.g. rRNA targeted locus, RefSeqGene, non-transcribed pseudogene)",
            "pattern": "^[^:]+:NG_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NM - Molecule type: mRNA",
            "Description": "Use context: protein-coding transcripts",
            "pattern": "^[^:]+:NM_\\d+(\\.\\d+)?$"
          },
          {
            "title": "XM - Molecule type: mRNA",
            "Description": "Use context: protein-coding transcripts",
            "pattern": "^[^:]+:XM_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NR - Molecule type: RNA",
            "Description": "Use context: non-protein-coding transcripts including lncRNAs, structural RNAs, transcribed pseudogenes, and transcripts with unlikely protein-coding potential from protein-coding genes",
            "pattern": "^[^:]+:NR_\\d+(\\.\\d+)?$"
          },
          {
            "title": "XR - Molecule type: RNA",
            "Description": "Use context: non-protein-coding transcripts, as above",
            "pattern": "^[^:]+:XR_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on NM_ transcript accessions or annotated on genomic molecules without an instantiated transcript (e.g. some mitochondrial genomes, viral genomes, and reference bacterial genomes",
            "pattern": "^[^:]+:NP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "AP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on AC_ genomic accessions or annotated on genomic molecules without an instantiated transcript record",
            "pattern": "^[^:]+:AP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "XP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on XM_ transcript accessions or annotated on genomic molecules without an instantiated transcript record",
            "pattern": "^[^:]+:XP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "YP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on genomic molecules without an instantiated transcript record",
            "pattern": "^[^:]+:YP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "WP - Molecule type: protein",
            "Description": "Use context: Proteins that are non-redundant across multiple strains and species. A single protein of this type may be annotated on more than one prokaryotic genome",
            "pattern": "^[^:]+:WP_\\d+(\\.\\d+)?$"
          }
        ],
        "examples": ["NC_001502.1", "NZ_AP024564.1", "NG_046887.1", "NP_001006685.1", "NZ_AMGO01000001.1"]
      },

      "curieHgncSymbolPattern": {
        "type": "string",
        "title": "HGNC symbol CURIE pattern",
        "description": "The HGNC (HUGO Gene Nomenclature Committee) provides an approved gene name and symbol (short-form abbreviation) for each known human gene. All approved symbols are stored in the HGNC database, and each symbol is unique. This collection refers to records using the HGNC symbol. See further details here: https://registry.identifiers.org/registry/hgnc.symbol",
        "pattern": "hgnc.symbol:[A-Za-z-0-9_]+(\\@)?$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "./EGA.common-definitions.json#/definitions/curieGeneralPattern"
          }
        ],
        "examples": ["hgnc.symbol:DAPK1", "hgnc.symbol:TAF1"]
      },

      "curieHgncIdentifierPattern": {
        "type": "string",
        "title": "HGNC identifier CURIE pattern",
        "description": "The HGNC (HUGO Gene Nomenclature Committee) provides an approved gene name and symbol (short-form abbreviation) for each known human gene. All approved symbols are stored in the HGNC database, and each symbol is unique. HGNC identifiers refer to records in the HGNC symbol database. See further details here: https://registry.identifiers.org/registry/hgnc",
        "pattern": "^((HGNC|hgnc):)?\\d{1,5}$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "./EGA.common-definitions.json#/definitions/curieGeneralPattern"
          }
        ],
        "examples": ["hgnc:2674", "HGNC:11535"]
      },

      "curieNcbiGeneIdentifierPattern": {
        "type": "string",
        "title": "NCBI Gene identifier CURIE pattern",
        "description": "Entrez Gene is the NCBI's database for gene-specific information, focusing on completely sequenced genomes, those with an active research community to contribute gene-specific information, or those that are scheduled for intense sequence analysis. See further details here: https://registry.identifiers.org/registry/ncbigene",
        "pattern": "^ncbigene:\\d+$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "./EGA.common-definitions.json#/definitions/curieGeneralPattern"
          }
        ],
        "examples": ["ncbigene:100010", "ncbigene:270627"]
      },

      "curieNcbiAssemblyPattern": {
        "type": "string",
        "title": "NCBI Assembly CURIE pattern",
        "description": "The assembly accession starts with a three letter prefix, GCA for GenBank assemblies and GCF for RefSeq assemblies. This is followed by an underscore and 9 digits (e.g. '_000001405'). A version (e.g. '.26') is then added to the accession. See further details here: https://registry.identifiers.org/registry/assembly",
        "pattern": "^assembly:(GCF|GCA)_\\d+(\\.\\d+)?$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "./EGA.common-definitions.json#/definitions/curieGeneralPattern"
          }
        ],
        "examples": ["assembly:GCF_000001405.26", "assembly:GCA_000001405.1", "assembly:GCF_000005845.2" ]
      },

      "assayTechnologyDescriptor": {
        "type": "object",
        "title": "Assay technology",
        "meta:propertyCurie": "EFO:0000548",
        "description": "Metadata of the assay instrument (e.g. sequencer Illumina NextSeq 500) used to obtain the raw data (e.g. sequence files) of an assay.",
        "required": ["assayInstrument", "assayInstrumentPlatform"],
        "additionalProperties": false,
        "properties": {
          "assayInstrument": {
            "type": "string",
            "title": "Assay's instrument category",
            "meta:propertyCurie": "EFO:0002773",
            "description": "The general categories (e.g. sequencer) in which assay instruments are categorized. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
            "enum": [ "array", "sequencer" ],
            "meta:enum": {
              "array": "[EFO:0002698][Array instrument](http://www.ebi.ac.uk/efo/EFO_0002698), an instrument which consists of nucleic acid or protein molecules bound to a substrate",
              "sequencer": "[EFO:0003739][Sequencer instrument](http://www.ebi.ac.uk/efo/EFO_0003739), an instrument that determines the order of nucleic acids in their sequences." 
            }
          },
          "assayInstrumentPlatform": {
            "type": "string",
            "title": "Assay instrument platform",
            "description": "Platform of the used instrument (e.g. 'Illumina HiSeq 2500'). Given the heterogenity in sequencing and array platforms (power of thousands), this property is not restricted by a CV list (i.e. it is free text).",
            "minLength": 1,
            "examples": ["Illumina HiSeq 2500", "[HuGene-1_1-st] Affymetrix Human Gene 1.1 ST Array [probe set (exon) version]", "DNBSEQ-G400 FAST"]
          }
        }
      },

      "libraryLayout": {
        "type": "string",
        "title": "Sequencing library layout",
        "description": "Whether the sequenced reads are paired or single. In other words, if the sequencing assay is paired- (OBI:0001850) or single-end (OBI:0002485). Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
        "enum": ["paired-end", "single-end"],
        "meta:enum": {
          "paired-end": "[OBI:0001850]: A transcription profiling assay that determines transcripts, gene structures, and gene expressions using Paired-End Tags and sequencing technology. Allows to sequence both ends of a fragment and generate high-quality, alignable sequence data. Paired-end sequencing facilitates detection of genomic rearrangements and repetitive sequence elements, as well as gene fusions and novel transcripts.",
          "single-end": "[OBI:0002485]: A sequencing assay that incorporates single-end reads and sequencing technology to determine transcripts, gene structures, and gene expressions. Single-read sequencing involves sequencing DNA from only one end." 
        }
      },

      "spotDescriptor": {
        "type": "array",
        "title": "Spot descriptor",
        "description": "The 'spotDescriptor' specifies how to decode the individual reads of interest from the monolithic spot sequence. The spot descriptor contains aspects of the experimental design, platform, and processing information. There will be two methods of specification: one will be an index into a table of typical decodings, the other being an exact specification. This construct is needed for loading data and for interpreting the loaded sequencing assays. It can be omitted if the loader can infer read layout (from multiple input files or from one input files).",
        "minItems": 1,
        "additionalProperties": false,
        "uniqueItems": true,
        "items": {
          "type": "object",
          "title": "Spot decode spec",
          "description": "",
          "additionalProperties": false,
          "required": ["readSpecs"],
          "properties": {
            "spotLength": {
              "type": "integer",
              "title": "Spot length",
              "description": "Number of base/color calls, cycles, or flows per spot (raw sequence length or flow length including all application and technical tags and mate pairs, but not including gap lengths). This value will be platform dependent, library dependent, and possibly run dependent. Variable length platforms will still have a constant flow/cycle length.",
              "minInclusive": 0
            },
            "readSpecs": {
              "type": "array",
              "title": "Read specs",
              "description": "",
              "minItems": 1,
              "uniqueItems": true,
              "items": {
                "type": "object",
                "title": "Read spec",
                "description": "",
                "additionalProperties": false,
                "required": [""],
                "properties": {
                  "readIndex": {
                    "type": "string",
                    "title": "Read index",
                    "description": "READ_INDEX starts at 0 and is incrementally increased for each sequential READ_SPEC within a SPOT_DECODE_SPEC.",
                    "minLength": 1
                  },
                "readLabel": {
                  "type": "string",
                  "title": "Read label",
                  "description": "READ_LABEL is a name for this tag, and can be used to on output to determine read name, for example F or R.",
                  "minLength": 1
                },
                "readClass": {
                  "type": "string",
                  "title": "Read class",
                  "description": "",
                  "enum": ["Application Read", "Technical Read" ],
                  "meta:enum": {
                    "Application Read": "",
                    "Technical Read": ""
                  }
                },
                "readType": {
                  "type": "string",
                  "title": "Read type",
                  "description": "",
                  "enum": ["Forward", "Reverse", "Adapter", "Primer", "Linker", "BarCode", "Other"],
                  "meta:enum": {
                    "Forward": "",
                    "Reverse": "",
                    "Adapter": "",
                    "Primer": "",
                    "Linker": "",
                    "BarCode": "",
                    "Other": "" 
                  }
                },
                "relativeOrder": {
                  "type": "object",
                  "title": "Relative order",
                  "description": "The read is located beginning at the offset or cycle relative to another read. This choice is appropriate for example when specifying a read that follows a variable length expected sequence(s).",
                  "additionalProperties": false,
                  "required": [""],        
                  "properties": {
                    "followsReadIndex": {
                      "type": "integer",
                      "title": "Follows read index",
                      "description": "Specify the read index that precedes this read.",
                      "minInclusive": 0      
                    },
                    "precedesReadIndex": {
                      "type": "integer",
                      "title": "Precedes read index",
                      "description": "Specify the read index that follows this read.",
                      "minInclusive": 0
                    }
                  }                    
                },
                "baseCoord": {
                  "type": "integer",
                  "title": "Base coord",
                  "description": "The location of the read start in terms of base count (1 is beginning of spot)"
                },
                "expectedBasecallTable": {
                  "type": "object",
                  "title": "Expected basecall table",
                  "description": "A set of choices of expected basecalls for a current read. Read will be zero-length if none is found.",    
                  "additionalProperties": false,
                  "required": ["basecalls"],        
                  "properties": {
                    "defaultLength": {
                      "type": "integer",
                      "title": "Default length",
                      "description": "Specify whether the spot should have a default length for this tag if the expected base cannot be matched.",
                      "minInclusive": 0
                    },
                    "baseCoord": {
                      "type": "integer",
                      "title": "Base coord",
                      "description": "Specify an optional starting point for tag (base offset from 1).",   
                      "minInclusive": 0
                    },
                    "basecalls": {
                      "type": "array",
                      "title": "Basecalls array",
                      "description": "Element's body contains a basecall, attribute provide description of this read meaning as well as matching rules.",
                      "minItems": 1,
                      "uniqueItems": true,
                      "items": {
                        "type": "object",
                        "title": "Basecall",
                        "description": "",
                        "additionalProperties": false,
                        "required": [""],              
                        "properties": {
                          "readGroupTag": {
                            "type": "string",
                            "title": "Read group tag",
                            "description": "When match occurs, the read will be tagged with this group membership.",
                            "minLength": 1  
                          },
                          "minMatch": {
                            "type": "integer",
                            "title": "Min match",
                            "description": "Minimum number of matches to trigger identification.",   
                            "minInclusive": 0            
                          },
                          "maxMismatch": {
                            "type": "integer",
                            "title": "Max mismatch",
                            "description": "Maximum number of mismatches",   
                            "minInclusive": 0         
                          },
                          "matchEdge": {
                            "type": "string",
                            "title": "Match edge",
                            "description": "Where the match should occur. Changes the rules on how minMatch and maxMismatch are counted.",
                            "enum": ["full", "start", "end"],
                            "meta:enum": {
                              "full": "Only @maxMismatch influences matching process", 
                              "start": "Both matches and mismatches are counted. When @maxMismatch is exceeded - it is not a match. When @minMatch is reached - match is declared.", 
                              "end": "Both matches and mismatches are counted. When @maxMismatch is exceeded - it is not a match. When @minMatch is reached - match is declared." 
                            }
                          }
                        }    
                      }
                    }
                    }
                  } 
                }
              }
            }
          }                    
        }        
      },
      
      "typeOfData": {
        "type": "string",
        "title": "Type of data",
        "meta:propertyCurie": "IAO:0000100",
        "description": "Type of data an experiment or analysis can produce (i.e. output), or an analysis can use as input. For example, in a sequencing experiment the output data would be 'genomic data', while that same type of data could be the input type of data for an analysis, which would then output 'processed sequencing data'. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema/issues/new/choose) proposing its addition.",
        "enum": ["gene list", "genomic data", "metagenomic data", "metatranscriptomic data", "synthetic DNA data", "transcriptomic data", "viral RNA data", "processed sequencing data", "processed array data"],
        "meta:enum": {
          "gene list": "[OBI:0000118]",
          "genomic data": "[EFO:0004600]",
          "metagenomic data": "[EFO:0004602]",
          "metatranscriptomic data": "[EFO:0004603]",
          "synthetic DNA data": "[EFO:0004604]",
          "transcriptomic data": "[EFO:0004601]",
          "viral RNA data": "[EFO:0004605]",
          "processed sequencing data": "[EFO:0004663]: raw sequencing data (e.g. FastQ files) were processed in any way (e.g. normalization, noise reduction, alignment...) and transformed into processed genotype data files [EFO:0004663].",
          "processed array data": "[EFO:0004096]: raw array data (e.g. CEL files) were processed in any way (e.g. normalization, noise reduction...) and transformed into processed array data files [EFO:0004096]." 
        }
      },

      "referenceAlignmentDetails": {
        "type": "array",
        "title": "Reference assembly and sequence details",
        "description": "Node containing the information of the reference assembly that was used to obtain the sequence alignment. For example, processing raw sequence FastQ files aligning it to a reference sequence (e.g. human Chromosome X of GRCh38's assembly), obtaining aligned sequences (e.g. BAM format). In this array one can list the used assembly (e.g. GRCh38.p14), the used assembly units (e.g. refseq:NC_000001.11), or a combination of both. In order to ease the interpretation of the data, it is important to notice that the field 'assemblyUnitName' shall correspond to how the Reference Sequence is labelled in submission file(s) (e.g. '1' for chromosome 1). This name is equivalent to the SQ label (the reference sequence dictionary) in BAM (see [documentation for v1](https://samtools.github.io/hts-specs/SAMv1.pdf)) and optional when submitted file uses INSDC accession.version",
        "additionalProperties": false,
        "uniqueItems": true,
        "minItems": 1,
        "items": {
          "title": "One item containing metadata of the assembly or assembly unit.",
          "$ref": "./EGA.common-definitions.json#/definitions/ncbiAssemblyDescriptor"
        }
      },

      "materialAnatomicalEntity": {
        "type": "object",
        "title": "Material anatomical entity",
        "meta:propertyCurie": "UBERON:0000465",
        "description": "The part of organism's anatomy or substance arising from an organism from which the biomaterial was derived, exlucing cell types. For example: tissues, organs, systems, fluids (e.g. semen, blood), body locations (e.g. arm skin, eye), etcetera. Search for yours at: http://purl.obolibrary.org/obo/UBERON_0000465. This property can be used to describe a sampling site or the morphological site of a disease, for example.",
        "allOf": [
          {
            "title": "Inherited ontologyTerm structure of termId and termLabel",
            "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
          }
        ],
        "properties": {        
          "termId": {
            "title": "Ontology constraints for this specific termId",
            "graphRestriction":  {
              "ontologies" : ["obo:uberon"],
              "classes": ["UBERON:0000465"],
              "relations": ["rdfs:subClassOf"],
              "direct": false,
              "include_self": false
            },
            "examples": [ "UBERON:0000956", "UBERON:0006530" ]
          }
        }        
      },

      "rTypeReferencedBy": {
        "type": "object",
        "title": "Relationship type: referencedBy",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "referencedBy"
          } 
        }
      },

      "rTypeGroupedWith": {
        "type": "object",
        "title": "Relationship type: groupedWith",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "groupedWith"
          } 
        }
      },

      "rTypeMemberOf": {
        "type": "object",
        "title": "Relationship type: memberOf",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "memberOf"
          } 
        }
      },

      "rTypeIsAfter": {
        "type": "object",
        "title": "Relationship type: isAfter",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "isAfter"
          } 
        }
      },

      "rTypeChildOf": {
        "type": "object",
        "title": "Relationship type: childOf",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "childOf"
          } 
        }
      },

      "rTypeDevelopsFrom": {
        "type": "object",
        "title": "Relationship type: developsFrom",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "developsFrom"
          } 
        }
      },

      "rTypeFamilyRelationshipWith": {
        "type": "object",
        "title": "Relationship type: familyRelationshipWith",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "familyRelationshipWith"
          } 
        }
      },

      "rTypeSameAs": {
        "type": "object",
        "title": "Relationship type: sameAs",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "required": [ "rType" ],
        "properties": {
          "rType": {
            "const": "sameAs"
          } 
        }
      },

      "rTargetPolicy": {
        "type": "object",
        "title": "Relationship target: Policy",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "policy" 
              }
            }
          } 
        }
      },

      "rSourcePolicy": {
        "type": "object",
        "title": "Relationship source: Policy",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "policy" 
              }
            }
          } 
        }
      },

      "rTargetDAC": {
        "type": "object",
        "title": "Relationship target: DAC",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "DAC" 
              }
            }
          } 
        }
      },

      "rSourceDAC": {
        "type": "object",
        "title": "Relationship source: DAC",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "DAC" 
              }
            }
          } 
        }
      },

      "rTargetDataset": {
        "type": "object",
        "title": "Relationship target: dataset",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "dataset" 
              }
            }
          } 
        }
      },

      "rSourceDataset": {
        "type": "object",
        "title": "Relationship source: dataset",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "dataset" 
              }
            }
          } 
        }
      },

      "rTargetAnalysis": {
        "type": "object",
        "title": "Relationship target: analysis",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "analysis" 
              }
            }
          } 
        }
      },

      "rSourceAnalysis": {
        "type": "object",
        "title": "Relationship source: analysis",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "analysis" 
              }
            }
          } 
        }
      },

      "rTargetSample": {
        "type": "object",
        "title": "Relationship target: sample",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "sample" 
              }
            }
          } 
        }
      },

      "rSourceSample": {
        "type": "object",
        "title": "Relationship source: sample",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "sample" 
              }
            }
          } 
        }
      },

      "rTargetExperiment": {
        "type": "object",
        "title": "Relationship target: experiment",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "experiment" 
              }
            }
          } 
        }
      },

      "rSourceExperiment": {
        "type": "object",
        "title": "Relationship source: experiment",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "experiment" 
              }
            }
          } 
        }
      },

      "rSourceIndividual": {
        "type": "object",
        "title": "Relationship source: individual",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "individual" 
              }
            }
          } 
        }
      },

      "rTargetIndividual": {
        "type": "object",
        "title": "Relationship target: individual",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "individual" 
              }
            }
          } 
        }
      },

      "rSourceProtocol": {
        "type": "object",
        "title": "Relationship source: protocol",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "protocol" 
              }
            }
          } 
        }
      },

      "rTargetProtocol": {
        "type": "object",
        "title": "Relationship target: protocol",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "protocol" 
              }
            }
          } 
        }
      },

      "rSourceSubmission": {
        "type": "object",
        "title": "Relationship source: submission",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "submission" 
              }
            }
          } 
        }
      },

      "rTargetSubmission": {
        "type": "object",
        "title": "Relationship target: submission",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "submission" 
              }
            }
          } 
        }
      },

      "rSourceExternalAccession": {
        "type": "object",
        "title": "Relationship source: externalAccession",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "externalAccession" 
              }
            }
          } 
        }
      },

      "rTargetExternalAccession": {
        "type": "object",
        "title": "Relationship target: externalAccession",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "externalAccession" 
              }
            }
          }
        }
      },

      "rSourceExternalURL": {
        "type": "object",
        "title": "Relationship source: externalURL",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "externalURL" 
              }
            }
          } 
        }
      },

      "rTargetExternalURL": {
        "type": "object",
        "title": "Relationship target: externalURL",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "externalURL" 
              }
            }
          } 
        }
      },

      "rSourceStudy": {
        "type": "object",
        "title": "Relationship source: study",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "study" 
              }
            }
          } 
        }
      },

      "rTargetStudy": {
        "type": "object",
        "title": "Relationship target: study",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "study" 
              }
            }
          } 
        }
      },

      "rTargetAssay": {
        "type": "object",
        "title": "Relationship target: assay",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rTarget" ],
        "properties": {
          "rTarget": {
            "properties": {
              "objectType": {
                "const": "assay" 
              }
            }
          } 
        }
      },

      "rSourceAssay": {
        "type": "object",
        "title": "Relationship source: assay",
        "description": "Node to be used as an object type for relationship contraints.",
        "required": [ "rSource" ],
        "properties": {
          "rSource": {
            "properties": {
              "objectType": {
                "const": "assay" 
              }
            }
          } 
        }
      },

      "rConstraintOneSourcedSubmission": {
        "title": "Relationship constraint of 1 submission as source",
        "description": "This node defines a relationship item containing a 'submission' as a source and of type 'referencedBy'. This node can be used with the keyword 'contains' at each relationship array of all objects (but submission), in order to assert that all objects have a submission object (EGAB...) linked to them.",
        "allOf": [
          {
            "$ref": "./EGA.common-definitions.json#/definitions/rTypeReferencedBy"
          },
          {
            "$ref": "./EGA.common-definitions.json#/definitions/rSourceSubmission"
          }
        ]
      },

      "urlUriPattern": {
        "type": "string",
        "title": "URL/URI pattern",
        "description": "This object exists to hold the pattern that a URL or URI should have. For it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^((http|https)://)(www.)?[a-zA-Z0-9@:%._\\+~#?&//=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%._\\+~#?&//=]*)$",
        "examples": [ "https://phenopacket-schema.readthedocs.io/en/latest/externalreference.html", "https://www.ebi.ac.uk/arrayexpress/experiments/E-MEXP-1712/", "https://www.geeksforgeeks.org/check-if-an-url-is-valid-or-not-using-regular-expression/" ]
      },

      "individualAge": {
        "type": "string",
        "title": "Individual's age",
        "meta:propertyCurie": "EFO:0000246",
        "description": "Precise age in ISO8601 format of the individual. For example, 'P3Y6M4D' represents a duration of three years, six months and four days.",
        "allOf": [
          {
            "title": "ISO8601 Date pattern",
            "$ref": "./EGA.common-definitions.json#/definitions/EGAISO8601DurationPattern"
          }
        ],
        "examples": [ "P3Y6M4D", "P23DT23H", "P4Y" ]
      },

      "cellType": {
        "type": "object",
        "title": "Cell type",
        "description": "Property to describe a cell type: a distinct morphological or functional form of cell.",
        "meta:propertyCurie": "EFO:0000324",
        "allOf": [
          {
            "title": "Inherited ontologyTerm structure of termId and termLabel",
            "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
          }
        ],
        "properties": {        
          "termId": {
            "title": "Ontology constraints for this specific termId",
            "graphRestriction":  {
              "ontologies" : ["obo:efo"],
              "classes": ["EFO:0000324"],
              "relations": ["rdfs:subClassOf"],
              "direct": false,
              "include_self": false
            },
            "examples": [ "CL:0002092", "CL:0000127", "CL:0000128" ]
          }
        }
      },

      "phenotypicAbnormality": {
        "type": "object",
        "title": "Phenotypic abnormality",
        "description": "Property to describe any abnormal (i.e. deviation from normal or average) phenotype (i.e. detectable outward manifestations of a specific genotype).",
        "meta:propertyCurie": "HP:0000118",
        "allOf": [
          {
            "title": "Inherited ontologyTerm structure of termId and termLabel",
            "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
          }
        ],
        "properties": {        
          "termId": {
            "title": "Ontology constraints for this specific termId",
            "anyOf": [
              {
                "title": "Ontology validation of phenotypic abnormality",
                "graphRestriction":  {
                  "ontologies" : ["obo:hp"],
                  "classes": ["HP:0000118"],
                  "relations": ["rdfs:subClassOf"],
                  "direct": false,
                  "include_self": false
                }
              },
              { 
                "title": "In case the phenotypic abnormality is unknown or there is none",
                "enum": ["NCIT:C17998", "NCIT:C94232"],
                "meta:enum": {
                  "NCIT:C17998": "Unknown",
                  "NCIT:C94232": "Unaffected"
                }
              }
            ],
            "examples": [ "HP:0003003", "HP:0010442", "HP:0002515", "NCIT:C17998", "NCIT:C94232" ]
          }
        }
      },

      "disease": {
        "type": "object",
        "title": "Disease",
        "description": "Property to describe a disease (i.e. a disposition to undergo pathological processes because of one or more disorders).",
        "meta:propertyCurie": "EFO:0000408",
        "allOf": [
          {
            "title": "Inherited ontologyTerm structure of termId and termLabel",
            "$ref": "./EGA.common-definitions.json#/definitions/ontologyTerm"
          }
        ],
        "properties": {        
          "termId": {
            "title": "Ontology constraints for this specific termId",
            "anyOf": [
              {
                "title": "Ontology validation of 'disease' - EFO",
                "graphRestriction":  {
                  "ontologies" : ["obo:efo"],
                  "classes": ["EFO:0000408"],
                  "relations": ["rdfs:subClassOf"],
                  "direct": false,
                  "include_self": false
                }
              },
              {
                "title": "Ontology validation of 'disease' - ORDO",
                "graphRestriction":  {
                  "ontologies" : ["obo:ordo"],
                  "classes": ["Orphanet:377788"],
                  "relations": ["rdfs:subClassOf"],
                  "direct": false,
                  "include_self": false
                }
              },
              {
                "title": "Ontology validation of 'human disease or disorder' - MONDO",
                "graphRestriction":  {
                  "ontologies" : ["obo:mondo"],
                  "classes": ["MONDO:0700096"],
                  "relations": ["rdfs:subClassOf"],
                  "direct": false,
                  "include_self": false
                }
              },
              { 
                "title": "In case the phenotypic abnormality is unknown or there is none",
                "enum": ["NCIT:C17998", "NCIT:C94232"],
                "meta:enum": {
                  "NCIT:C17998": "Unknown",
                  "NCIT:C94232": "Unaffected"
                }
              }
            ],
            "examples": [ "MONDO:0100096", "EFO:0003101", "NCIT:C17998", "NCIT:C94232" ]
          }
        }
      },

      "ontologyTerm": {
        "type": "object",
        "title": "Ontology term",
        "description": "This property represents an ontology term (a.k.a. class). It consists on two properties: the term identifier (termId) and its label (termLabel). This property and its structure is inherited across many other elements in the schemas. It is there, when inherited, where the real ontology constraint is put in place (e.g. using 'graphRestriction' keywords). Based on phenopacket's [OntologyClass](https://phenopacket-schema.readthedocs.io/en/latest/ontologyclass.html)",
        "additionalProperties": false,
        "required": ["termId", "termLabel"],
        "properties": {
          "termId": {
            "type": "string",
            "title": "ID of the term",
            "description": "The identifier of an ontology term must be in CURIE format (check property 'curieGeneralPattern'). Whether a specific term is valid or not according to an ontology hierarchy is checked at each specific termId using ontology validation keywords (e.g. 'graphRestriction').",
            "minLength": 1,
            "allOf": [
              {
                "title": "General CURIE pattern",
                "$ref": "./EGA.common-definitions.json#/definitions/curieGeneralPattern"
              }
            ],
            "examples": [ "MONDO:0100096", "EFO:0003101", "EFO:0005518",  "EFO:0002944",  "EFO:0003813" ]
          },
          "termLabel": {
            "type": "string",
            "title": "Label of the term",
            "description": "The label of a term is the human-readable string associated with the identifier. It is not required that it matches the label of the termId within the referenced ontology, although it should. This is due to the fact that the source of truth will always be the termId, and not the label, which adds more context.",
            "minLength": 1,
            "examples": [ "COVID-19", "Axila skin", "bone marrow cell", "astrocyte", "oligodendrocyte", "Unknown", "Unaffected", "homo sapiens" ]
          }
        }
      }
    }
}