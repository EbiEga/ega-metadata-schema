{
    "$schema": "https://json-schema.org/draft/2019-09/schema",
    "type": "object",
    "$id": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json",
    "title": "EGA common metadata definitions",
    "meta:version": "0.0.0",
    "description": "Metadata schema used by the European Genome-phenome Archive (EGA) to store common definitions for other metadata objects. Basically, we are defining here common properties (e.g. instances' aliases) that other metadata objects (e.g. sample) may use. The way we refer to them is by using this object's '$id' field, referencing it in other files (with '$ref' and the relative path of the property - e.g. '$ref': 'https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_core_id'). See structuring documentation (https://json-schema.org/understanding-json-schema/structuring.html). Further details can be found in the EGA-metadata-schema GitHub repository (https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas) and EGA-archive website (https://ega-archive.org/)",
    "definitions": {

      "object_core_id": {
        "type": "object",
        "title": "Core identifiers of an object",
        "description": "Base definition containing the properties (e.g. Sample's alias) of a minimal identification layer of an EGA object (e.g. Sample).",
        "additionalProperties": false,
        "properties": {
          "alias": {
            "type": "string",
            "title": "Alias of an object",
            "description": "Submitter designated name (e.g. 'my_sample_J13') for the object (e.g. Sample). The name must be unique within the submission account (e.g. 'ega-box-79'), since the aliases and submission accounts are concatenated within our database to obtain the unique alias (e.g. 'ega-box-79::my_sample_J13').",
            "examples": [ "my_sample_J13" ]
          },
          "center_name": {
            "type": "string",
            "title": "Center name of the submitter",
            "description": "Center name (e.g. 'EBI-TEST') associated to the submitter. In other words, it is the acronym of the submitter's account (provided by the HelpDesk team).",
            "examples": [ "EBI-TEST" ]
          },
          "ega_accession": {
            "type": "string",
            "title": "EGA's accession of the object",
            "description": "The object accession (i.e. unique identifier) assigned by the archive (EGA). Object accessions can be found in the 'Identifiers' section of the EGA-archive website (https://ega-archive.org/metadata/how-to-use-the-api) and commonly start with EGA, followed by the distinctive letter of the object and finally the numeric ID of the instance.",
            "examples": [ "EGAN00003245489" ]
          },
          "external_accessions": {
            "type": "array",
            "title": "External accessions array",
            "description": "Custom attributes of an ArrayExperiment: reusable attributes to encode tag-value pairs (e.g. Tag being 'Targeted loci' and its Value '5:63256183-63258334') with optional units (e.g. 'base pairs'). Its properties are inherited from the common-definitions.json schema.",
            "minItems": 1,
            "additionalProperties": false,
            "items": {
              "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_external_accession"
            }
          }

        },
        "anyOf": [
          { 
            "title": "Check core IDs: combination of Alias and Center name",
            "required": ["alias", "center_name"] 
          },
          { 
            "title": "Check core IDs: EGA accession ID",
            "required": ["ega_accession"] 
          },
          { 
            "title": "Check core IDs: external accessions",
            "required": ["external_accessions"] 
          }
        ]
      },

      "custom_attribute": {
        "type": "object",
        "title": "Custom attribute of an object",
        "description": "Reusable attributes to encode tag-value pairs (e.g. Tag being 'Age' and its Value '40') with optional units (e.g. 'years').",
        "required": ["tag", "value"],
        "additionalProperties": false,
        "properties": {
          "tag": {
            "type": "string",
            "title": "Tag of the custom attribute",
            "description": "The name of the attribute (e.g. 'Age').",
            "examples": [ "age" ]
          },
          "value": {
            "type": ["string", "number"],
            "title": "Value of the custom attribute",
            "description": "The value of the attribute (e.g. '40').",
            "examples": [ "40" ]
          },
          "units": {
            "type": "string",
            "title": "Units of the custom attribute",
            "description": "The optional units of the attribute (e.g. 'years').",
            "examples": [ "years" ]
          }
        }        
      },

      "file_object": {
        "type": "object",
        "title": "EGA File object",
        "description": "Object containing the base metadata attributes of a file object in the EGA. These can inherited elsewhere with or without extending them.",
        "required": ["filename", "filetype", "checksum_method", "unencrypted_checksum", "encrypted_checksum"],
        "additionalProperties": false,
        "properties": {
          "filename": {
            "type": "string",
            "title": "Filename [data:1050]",
            "description": "The full name of a file, including all of their file extensions (e.g. .gpg, .md5...), that identifies the file (e.g. 'my-bam-file.bam.gpg').",
            "pattern": "^[^<>:;,?\"*|/]+$",
            "examples": [ "my-bam-file.bam.gpg" ]
          },
          "filetype": {
            "type": "object",
            "title": "Filetype [NCIT:C172272]",
            "description": "The nature of the content stored in an electronic file. Contains up to two properties, the name (e.g. CEL or TSV) and the CURIE (e.g. EFO:0005630 or NCIT:C164049), chosen from a list of CVs.",
            "required": ["filetype_id"],
            "additionalProperties": false,
            "properties": {
              "filetype_id": {
                "type": "string",
                "title": "Filetype ID",
                "description": "The ID or name (e.g. FASTA or TSV) associated with the given filetype.",
                "enum": ["CEL", "TSV", "ADF", "FASTQ", "FASTA", "SDRF", "IDF", "VCF", "SRA", "SRF", "SFF", "BAM", "CRAM", "XLSX", "CSV", "BED", "IDAT", "MAP", "PED", "BIM", "FAM"],
                "meta:enum": ["CEL__EFO:0005630: ", "TSV__NCIT:C164049", "ADF__NCIT:C172213", "FASTQ__EFO:0004155", "FASTA__NCIT:C47845", "SDRF__NCIT:C172211", "IDF__NCIT:C172212", "VCF__NCIT:C172216", "SRA__format:3698", "SRF__EFO:0004154", "SFF__EFO:0004156", "BAM__EFO:0004157", "CRAM__format:3462", "XLSX__format:3620", "CSV__format:3752", "BED__format:3003", "IDAT__format:3578", "MAP__format:3285", "PED__format:3286", "BIM__", "FAM__"],
                "examples": [ "TSV" ]
              },
              "filetype_curie": {
                "type": "string",
                "title": "Filetype CURIE",
                "description": "The CURIE (i.e. ontologized term - e.g. NCIT:C47845 or NCIT:C164049) associated with the given filetype.",
                "enum": ["EFO:0005630", "NCIT:C164049", "NCIT:C172213", "EFO:0004155", "NCIT:C47845", "NCIT:C172211", "NCIT:C172212", "NCIT:C172216", "format:3698", "EFO:0004154", "EFO:0004156", "EFO:0004157", "format:3462", "format:3620", "format:3752", "format:3003", "format:3578", "format:3285", "format:3286"],
                "examples": [ "NCIT:C164049" ]
              }
            }
          },
          "checksum_method": {
            "type": "object",
            "title": "Checksum method [ChecksumAlgorithm]",
            "description": "Node containing both the ID (MD5 or SHA-256) and the CURIE (NCIT:C171276 or NCIT:C80226), describing the method which yields the checksum from a data input for the purpose of detecting errors.",
            "additionalProperties": false,
            "properties": {
              "checksum_method_id": {
                "type": "string",
                "title": "Checksum method ID",
                "description": "The ID or name (MD5 or SHA-256) associated with the used checksum method.",
                "enum": ["MD5", "SHA-256"],
                "meta:enum": ["MD5__NCIT:C171276", "SHA-256__NCIT:C80226"],
                "examples": [ "MD5" ]
              },
              "checksum_method_curie": {
                "type": "string",
                "title": "Checksum method CURIE",
                "description": "The CURIE (i.e. ontologized term - NCIT:C171276 or NCIT:C80226) associated with the used checksum method.",
                "enum": ["NCIT:C171276", "NCIT:C80226"],
                "examples": [ "NCIT:C171276" ]
              }
            }
          },
          "unencrypted_checksum": {
            "type": "string",
            "title": "Checksum [NCIT:C43522] of the unencrypted file",
            "description": "A computed value which depends on the contents of a block of data and which is transmitted or stored along with the data in order to detect corruption of the data, computed from the unencrypted files.",
            "examples": [ "46798b5cfca45c46a84b7419f8b74735" ],
            "oneOf": [
              { 
                "title": "Check of MD5 checksum pattern", 
                "$ref": "#/definitions/md5-checksum-pattern"
              },
              { 
                "title": "Check of SHA-256 checksum pattern",
                "$ref": "#/definitions/SHA-256-checksum-pattern"
              }
            ]
          },
          "encrypted_checksum": {
            "type": "string",
            "title": "Checksum [NCIT:C43522] of the encrypted file",
            "description": "A computed value which depends on the contents of a block of data and which is transmitted or stored along with the data in order to detect corruption of the data, computed from the encrypted files.",
            "examples": [ "bc527343c7ffc103111f3a694b004e2f" ],
            "oneOf": [
              { 
                "title": "Check of MD5 checksum pattern", 
                "$ref": "#/definitions/md5-checksum-pattern"
              },
              { 
                "title": "Check of SHA-256 checksum pattern",
                "$ref": "#/definitions/SHA-256-checksum-pattern"
              }
            ]
          }
        },
        "allOf": [
          { 
            "title": "Inherited check of checksum patterns", 
            "$ref": "#/definitions/checksum-pattern-check" 
          },
          { 
            "title": "Inherited check of filetype-filename patterns", 
            "$ref": "#/definitions/filename-filetype-pattern-check" 
          }
        ]        
      },

      "relationship_object": {
        "type": "object",
        "title": "EGA Relationships object",
        "description": "Object containing the base metadata attributes of a relationship object in the EGA. Comprises metadata (e.g. Source and Target) of a directional association between two entities. Ontologies of each type of connection are stored the meta:enum field, and details of each in its corresponding record within the ontologies.",
        "required": ["r_type", "r_source", "r_target"],
        "additionalProperties": false,
        "properties": {
          "r_type": {
            "type": "object",
            "title": "Type of the relationship",
            "description": "The Type of the relationship, containing both its ID (e.g. same_as and the CURIE (e.g. NCIT:C64637), that summarises its purpose. #! The list of CV shall be agreed on, improved and enlarged.",
            "anyOf": [
              { 
                "title": "Check that r_type is present",
                "required": ["r_type_id"] 
              },
              { 
                "title": "Check that r_type_curie is present", 
                "required": ["r_type_curie"] 
              }
            ],
            "additionalProperties": false,
            "properties": {
              "r_type_id": {
                "type": "string",
                "title": "Type of the relationship - ID",
                "description": "The human readable ID (e.g. same_as), chosen from a list of CVs, of the type of the relationship.",
                "enum": ["referenced_by", "develops_from", "same_as", "member_of", "grouped_with", "family_relationship_with", "child_of", "parent_of", "is_after", "published_in", "submitted_by", "contact_of", "main_contact_of"],
                "meta:enum": ["referenced_by__SIO:000252", "develops_from__RO:0002202", "same_as__NCIT:C64637", "member_of__RO:0002350", "grouped_with__", "family_relationship_with__EFO:0004424", "child_of__GSSO:000728", "parent_of__GSSO:001986", "is_after__SIO:000211", "published_in__EFO:0001796", "submitted_by__NCIT:C25695", "contact_of__NCIT:C25461", "main_contact_of__"],
                "examples": [ "referenced_by" ]
              },
              "r_type_curie": {
                "type": "string",
                "title": "Type of the relationship - CURIE",
                "description": "The CURIE (i.e. ontologized term - e.g. NCIT:C64637), chosen from a list of CVs, of the type of the relationship.",
                "enum": ["SIO:000252", "RO:0002202", "NCIT:C64637", "RO:0002350", "EFO:0004424", "GSSO:000728", "GSSO:001986", "SIO:000211", "EFO:0001796", "NCIT:C25695", "NCIT:C25461"],
                "examples": [ "RO:0002202" ]
              }
            }
          },
          "r_source": {
            "type": "object",
            "title": "Source of the relationship",
            "description": "Object reference of the relationship’s source. In other words, the starting point of the relationship: in 'sample_A develops_from sample_B' the source is 'sample_A'.",
            "allOf": [
              {
                "title": "Inherited one-relationship-end object", 
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/one-relationship-end" 
              }
            ]
          },
          "r_target": {
            "type": "object",
            "title": "Target of the relationship",
            "description": "Object reference of the relationship’s target. In other words, the ending point of the relationship: in 'sample_A develops_from sample_B' the target is 'sample_B'.",
            "allOf": [
              {
                "title": "Inherited one-relationship-end object", 
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/one-relationship-end" 
              }
            ]
          }
        }        
      },

      "protocols_object": {
        "type": "object",
        "title": "EGA Protocols object",
        "description": "Object containing the base metadata attributes of a Protocol object in the EGA. Comprises metadata (e.g. Type of protocol) of a plan specification, with sufficient level of detail and quantitative information to communicate it (and thus reproduce it) between investigation agents.",
        "required": ["protocol_type", "protocol_description"],
        "additionalProperties": false,
        "properties": {
          "protocol_name": {
            "type": "string",
            "title": "Name of the protocol [NCIT:C42614]",
            "description": "Name of the protocol (e.g. 'myProtocol-13'). To be defined by the user.",
            "examples": [ "myProtocol-13" ]
          },
          "protocol_type": {
            "type": "string",
            "title": "Type of protocol [OBI:0000272] ",
            "description": "Classification by type of the protocol (e.g. 'Sample collection'), to be chosen from a controlled vocabulary list (to be upgraded on demand).",
            "enum": ["Sample collection",  "Nucleic acid extraction",  "Nucleic acid labeling",  "Nucleic acid hybridization to array",  "Array scanning and feature extraction",  "Nucleic acid library construction",  "Growth",  "Dissociation", "Enrichment", "Treatment", "Conversion", "Clinical treatment", "Dissection", "Gene expression"],
            "meta:enum": ["Sample collection__EFO:0005518", "Nucleic acid extraction__EFO:0002944", "Nucleic acid labeling__EFO:0003813", "Nucleic acid hybridization to array__EFO:0003815", "Array scanning and feature extraction__EFO:0003814", "Nucleic acid library construction__EFO:0004184", "Growth__EFO:0003789", "Dissociation__EFO:0009088", "Enrichment__EFO:0009089", "Treatment__EFO:0003969", "Conversion__EFO:0005520", "Clinical treatment__EFO:0000355", "Dissection__EFO:0005519", "Gene expression__EFO:0003788"],
            "examples": [ "Sample collection" ]
          },
          "protocol_curie": {
            "type": "string",
            "title": "Name of the protocol type [NCIT:C21270]",
            "description": "Ontology term (e.g. 'EFO:0005518') of the Type of protocol.",
            "enum": ["EFO:0005518",  "EFO:0002944",  "EFO:0003813",  "EFO:0003815",  "EFO:0003814",  "EFO:0004184",  "EFO:0003789",  "EFO:0009088", "EFO:0009089", "EFO:0003969", "EFO:0005520", "EFO:0000355", "EFO:0005519", "EFO:0003788"],
            "examples": [ "EFO:0005518" ]
          },
          "protocol_description": {
            "type": "string",
            "title": "Description of the protocol [NCIT:C25365]",
            "description": "Description of the protocol (e.g. 'First tilt the cell culture flask... ...and finally let it still for 2 hours.'), being descriptive enough to be replicated by anyone who is granted access.",
            "examples": [ "First tilt the cell culture flask... ...and finally let it still for 2 hours." ]
          }
        }
      },

      "array_label": {
        "type": "object",
          "title": "Repeatable array_label node",
          "description": "Chemicals conjugated to nucleic acid/proteins to label them before microarray hybridisation. This node corresponds to the basic description of one single label, and thus should be repeated as an array where inherited if multiple labels are intended to be described. Its basic structure is a label ID and its optional CURIE.",
          "required": ["array_label_id", "array_label_curie"],
          "additionalProperties": false,
          "properties": {
            "array_label_id": {
              "type": "string",
              "title": "Array label of the ArrayExperiment - ID",
              "description": "Human readable ID/name (e.g. 'Cy3 dye' or 'Biotin') of the Array label used for the experiment.",
              "examples": [ "Cy3 dye" ]
            },
            "array_label_curie": {
              "type": "string",
              "title": "Array label of the ArrayExperiment - CURIE",
              "description": "CURIE (i.e. ontologized term - e.g. 'CHEBI:37987' or 'CHEBI:15956') of the Array label used for the experiment.",
              "examples": [ "CHEBI:37987" ]
            }
          }
      },

      "object-id-and-object-type-check": {
        "type": "object",
        "title": "Check that the object_id's accession pattern and object_type match",
        "description": "This object exists with the only purpose of being a reference as a pattern check of a given object_id and object_type. The constraint consists in asserting that, if the object identifier is an EGA accession, its pattern matches the object type (e.g. if object_type is 'sample', its EGA accession needs to match '^EGAN[0-9]{11}$')",
        "anyOf": [
          {
            "title": "Alias and Centername: object_id and object_type check",
            "description": "A check that ensures that the alias and centername are given as the object_type. Since the alias and centername cannot be checked for specific object_types (i.e. each can name their objects in different ways), this block exists here just so that this option is allowed.",
            "properties": {
              "object_id": { 
                "required": ["alias", "center_name"]
              }
            }
          },
          {
            "title": "External accession: object_id and object_type check",
            "description": "A check that ensures that, if 'external_accession' is given as the object_type, the corresponding node exists within object_id",
            "properties": {
              "object_id": { 
                "required": ["external_accessions"]
              },
              "object_type": {
                "enum": ["external_accession"]
              }
            }
          },
          {
            "title": "Experiment: object_id and object_type check",
            "description": "A check that ensures that, if 'experiment' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-experiment-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["experiment"]
              }
            }
          }, 
          {
            "title": "Study: object_id and object_type check",
            "description": "A check that ensures that, if 'study' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-study-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["study"]
              }
            }
          },          
          {
            "title": "Sample: object_id and object_type check",
            "description": "A check that ensures that, if 'sample' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-sample-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["sample"]
              }
            }
          },          
          {
            "title": "Submission: object_id and object_type check",
            "description": "A check that ensures that, if 'submission' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-submission-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["submission"]
              }
            }
          },          
          {
            "title": "Run: object_id and object_type check",
            "description": "A check that ensures that, if 'run' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-run-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["run"]
              }
            }
          },          
          {
            "title": "Dataset: object_id and object_type check",
            "description": "A check that ensures that, if 'dataset' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-dataset-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["dataset"]
              }
            }
          },          
          {
            "title": "Analysis: object_id and object_type check",
            "description": "A check that ensures that, if 'analysis' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-analysis-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["analysis"]
              }
            }
          },          
          {
            "title": "Policy: object_id and object_type check",
            "description": "A check that ensures that, if 'policy' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-policy-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["policy"]
              }
            }
          },          
          {
            "title": "DAC: object_id and object_type check",
            "description": "A check that ensures that, if 'DAC' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-DAC-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["DAC"]
              }
            }
          },          
          {
            "title": "ArrayExperiment: object_id and object_type check",
            "description": "A check that ensures that, if 'ArrayExperiment' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-ArrayExperiment-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["ArrayExperiment"]
              }
            }
          },
          {
            "title": "ArrayAssay: object_id and object_type check",
            "description": "A check that ensures that, if 'ArrayAssay' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-ArrayAssay-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["ArrayAssay"]
              }
            }
          },
          {
            "title": "Individual: object_id and object_type check",
            "description": "A check that ensures that, if 'individual' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-individual-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["individual"]
              }
            }
          }
        ]                      
      },
      
      "checksum-pattern-check": {
        "type": "object",
        "title": "Check: checksum checks based on its method",
        "description": "This object exists with the only purpose of being a reference of pattern checks of the given checksum (e.g. 'c6779ec2960296ed9a04f08d67f64423') of a file based on its corresponding method (e.g. if the given checksum method is 'MD5' the checksum shall fit into MD5's format of '^[0-9a-z](?:-?[0-9a-z]){31}$')",
        "anyOf": [
          { 
            "title": "Checksum pattern check - MD5",
            "description": "A check that ensures that, if MD5 is given as a checksum_method_id, the checksums per se (e.g. unencrypted_checksum) follow MD5 patterns (md5-checksum-pattern).",
              "properties": {
                "checksum_method": { 
                  "properties": {
                    "checksum_method_id": {
                      "enum": ["MD5"]
                    } 
                  }
                },
                "unencrypted_checksum": { "$ref": "#/definitions/md5-checksum-pattern" },
                "encrypted_checksum": { "$ref": "#/definitions/md5-checksum-pattern" }
              }
          },
          { 
            "title": "Checksum pattern check - SHA-256",
            "description": "A check that ensures that, if SHA-256 is given as a checksum_method_id, the checksums per se (e.g. unencrypted_checksum) follow SHA-256 patterns (sha-256-checksum-pattern).",
              "properties": {
                "checksum_method": { 
                  "properties": {
                    "checksum_method_id": {
                      "enum": ["SHA-256"]
                    } 
                  }
                },
                "unencrypted_checksum": { "$ref": "#/definitions/SHA-256-checksum-pattern" },
                "encrypted_checksum": { "$ref": "#/definitions/SHA-256-checksum-pattern" }
              }
          }
        ]                    
      },

      "md5-checksum-pattern": {
        "type": "string",
        "title": "Checksum pattern obtained by MD5",
        "description": "This object exists to hold the pattern that a checksum would have if it was obtained using the algorithm MD5, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[0-9a-z](?:-?[0-9a-z]){31}$",
        "examples": [ "bc527343c7ffc103111f3a694b004e2f" ]
      },

      "SHA-256-checksum-pattern": {
        "type": "string",
        "title": "Checksum pattern obtained by SHA-256",
        "description": "This object exists to hold the pattern that a checksum would have if it was obtained using the algorithm SHA-256, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[A-Fa-f0-9]{64}$",
        "examples": [ "c01b39c7a35ccc3b081a3e83d2c71fa9a767ebfeb45c69f08e17dfe3ef375a7b" ]
      },

      "EGA-experiment-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA experiment's ID (EGAX...)",
        "pattern": "^EGAX[0-9]{11}$",
        "examples": [ "EGAX00002189113" ]
      },
      
      "EGA-study-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA study's ID (EGAS...)",
        "pattern": "^EGAS[0-9]{11}$",
        "examples": [ "EGAS00001004508" ]
      },

      "EGA-sample-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA sample's ID (EGAN...)",
        "pattern": "^EGAN[0-9]{11}$",
        "examples": [ "EGAN00003245489" ]
      },

      "EGA-submission-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA submission's ID (EGAB...)",
        "pattern": "^EGAB[0-9]{11}$",
        "examples": [ "EGAB00001001831" ]
      },

      "EGA-run-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA run's ID (EGAR...)",
        "pattern": "^EGAR[0-9]{11}$",
        "examples": [ "EGAR00001314547" ]
      },

      "EGA-dataset-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA dataset's ID (EGAD...)",
        "pattern": "^EGAD[0-9]{11}$",
        "examples": [ "EGAD00001004170" ]
      },

      "EGA-analysis-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA analysis's ID (EGAZ...)",
        "pattern": "^EGAZ[0-9]{11}$",
        "examples": [ "EGAZ00001004170" ]
      },

      "EGA-policy-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA policy's ID (EGAP...)",
        "pattern": "^EGAP[0-9]{11}$",
        "examples": [ "EGAP00001001831" ]
      },

      "EGA-DAC-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA DAC's ID (EGAC...)",
        "pattern": "^EGAC[0-9]{11}$",
        "examples": [ "EGAC00001000908" ]
      },

      "EGA-ArrayExperiment-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA ArrayExperiment's ID (EGAE...)",
        "pattern": "^EGAE[0-9]{11}$",
        "examples": [ "EGAE00001004508" ]
      },

      "EGA-ArrayAssay-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA ArrayAssay's ID (EGAA...)",
        "pattern": "^EGAA[0-9]{11}$",
        "examples": [ "EGAA00002189113" ]
      },

      "EGA-individual-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA Individual's ID (EGAI...)",
        "pattern": "^EGAI[0-9]{11}$",
        "examples": [ "EGAI00001159712" ]
      },

      "EGA-ISO-date-YYYY-MM-DD-pattern": {
        "type": "string",
        "title": "Pattern of an EGA ISO date (YYYY-MM-DD)",
        "pattern": "^[0-9]{4}-(0[0-9]|1[0-2])-([012][0-9]|3[01])$",
        "examples": [ "2021-04-30" ]
      },

      "filename-filetype-pattern-check": {
        "type": "object",
        "title": "Check: filetype checks based on its filename",
        "description": "This object exists with the only purpose of being a reference of pattern checks of the given filetype of a file based on its corresponding filename (e.g. if the file is 'alignment.bam.gz.gpg' its filetype_id shall be 'BAM' and not 'XLSX')",
        "anyOf": [
          {
            "title": "CEL Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["CEL"] }
                  }
                },
                "filename": { "$ref": "#/definitions/cel-file-filename-pattern" }
              }
          },                
          {
            "title": "TSV Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["TSV"] }
                  }
                },
                "filename": { "$ref": "#/definitions/tsv-file-filename-pattern" }
              }
          },                
          {
            "title": "ADF Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["ADF"] }
                  }
                },
                "filename": { "$ref": "#/definitions/adf-file-filename-pattern" }
              }
          },                
          {
            "title": "FASTQ Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["FASTQ"] }
                  }
                },
                "filename": { "$ref": "#/definitions/fastq-file-filename-pattern" }
              }
          },                
          {
            "title": "FASTA Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["FASTA"] }
                  }
                },
                "filename": { "$ref": "#/definitions/fasta-file-filename-pattern" }
              }
          },                
          {
            "title": "SDRF Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["SDRF"] }
                  }
                },
                "filename": { "$ref": "#/definitions/sdrf-file-filename-pattern" }
              }
          },                
          {
            "title": "IDF Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["IDF"] }
                  }
                },
                "filename": { "$ref": "#/definitions/idf-file-filename-pattern" }
              }
          },                
          {
            "title": "VCF Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["VCF"] }
                  }
                },
                "filename": { "$ref": "#/definitions/vcf-file-filename-pattern" }
              }
          },                
          {
            "title": "SRA Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["SRA"] }
                  }
                },
                "filename": { "$ref": "#/definitions/sra-file-filename-pattern" }
              }
          },                
          {
            "title": "SRF Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["SRF"] }
                  }
                },
                "filename": { "$ref": "#/definitions/srf-file-filename-pattern" }
              }
          },                
          {
            "title": "SFF Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["SFF"] }
                  }
                },
                "filename": { "$ref": "#/definitions/sff-file-filename-pattern" }
              }
          },                
          {
            "title": "BAM Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["BAM"] }
                  }
                },
                "filename": { "$ref": "#/definitions/bam-file-filename-pattern" }
              }
          },                
          {
            "title": "CRAM Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["CRAM"] }
                  }
                },
                "filename": { "$ref": "#/definitions/cram-file-filename-pattern" }
              }
          },                
          {
            "title": "XLSX Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["XLSX"] }
                  }
                },
                "filename": { "$ref": "#/definitions/xlsx-file-filename-pattern" }
              }
          },                
          {
            "title": "CSV Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["CSV"] }
                  }
                },
                "filename": { "$ref": "#/definitions/csv-file-filename-pattern" }
              }
          },                
          {
            "title": "BED Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["BED"] }
                  }
                },
                "filename": { "$ref": "#/definitions/bed-file-filename-pattern" }
              }
          },                
          {
            "title": "IDAT Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["IDAT"] }
                  }
                },
                "filename": { "$ref": "#/definitions/idat-file-filename-pattern" }
              }
          },                
          {
            "title": "MAP Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["MAP"] }
                  }
                },
                "filename": { "$ref": "#/definitions/map-file-filename-pattern" }
              }
          },                
          {
            "title": "PED Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["PED"] }
                  }
                },
                "filename": { "$ref": "#/definitions/ped-file-filename-pattern" }
              }
          },                
          {
            "title": "BIM Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["BIM"] }
                  }
                },
                "filename": { "$ref": "#/definitions/bim-file-filename-pattern" }
              }
          },                
          {
            "title": "FAM Filename pattern-check",
            "properties": {
                "filetype": {
                  "properties": {
                      "filetype_id": { "enum": ["FAM"] }
                  }
                },
                "filename": { "$ref": "#/definitions/fam-file-filename-pattern" }
            }
          }
        ]        
    },

      "cel-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a CEL file",
        "description": "This object exists to hold the filename pattern that a 'CEL' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.cel(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.cel.gz.gpg" ]
      },

      "tsv-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a TSV file",
        "description": "This object exists to hold the filename pattern that a 'TSV' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.tsv(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.tsv.gz.gpg" ]
      },

      "adf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a ADF file",
        "description": "This object exists to hold the filename pattern that a 'ADF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.adf(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.adf.gz.gpg" ]
      },

      "fastq-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ file",
        "description": "This object exists to hold the filename pattern that a 'FASTQ' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.fastq(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.fastq.gz.gpg" ]
      },

      "fasta-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a FASTA file",
        "description": "This object exists to hold the filename pattern that a 'FASTA' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.fasta(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.fasta.gz.gpg" ]
      },

      "sdrf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SDRF file",
        "description": "This object exists to hold the filename pattern that a 'SDRF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.sdrf(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.sdrf.gz.gpg" ]
      },

      "idf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a IDF file",
        "description": "This object exists to hold the filename pattern that a 'IDF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.idf(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.idf.gz.gpg" ]
      },

      "vcf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a VCF file",
        "description": "This object exists to hold the filename pattern that a 'VCF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.vcf(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.vcf.gz.gpg" ]
      },

      "sra-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SRA file",
        "description": "This object exists to hold the filename pattern that a 'SRA' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.sra(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.sra.gz" ]
      },

      "srf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SRF file",
        "description": "This object exists to hold the filename pattern that a 'SRF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.srf(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.srf.gz.gpg" ]
      },

      "sff-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SFF file",
        "description": "This object exists to hold the filename pattern that a 'SFF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.sff(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.sff.gz.gpg" ]
      },

      "bam-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a BAM file",
        "description": "This object exists to hold the filename pattern that a 'BAM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bam(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.bam.arj.gpg" ]
      },

      "cram-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a CRAM file",
        "description": "This object exists to hold the filename pattern that a 'CRAM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.cram(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.cram.gz.gpg" ]
      },

      "xlsx-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a XLSX file",
        "description": "This object exists to hold the filename pattern that a 'XLSX' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.xlsx(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.xlsx.tar.gpg" ]
      },

      "csv-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a CSV file",
        "description": "This object exists to hold the filename pattern that a 'CSV' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.csv(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.csv" ]
      },

      "bed-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a BED file",
        "description": "This object exists to hold the filename pattern that a 'BED' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bed(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.bed.gz.gpg" ]
      },

      "idat-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a IDAT file",
        "description": "This object exists to hold the filename pattern that a 'IDAT' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.idat(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.idat.zip" ]
      },

      "map-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a MAP file",
        "description": "This object exists to hold the filename pattern that a 'MAP' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.map(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.map.gpg" ]
      },

      "ped-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a PED file",
        "description": "This object exists to hold the filename pattern that a 'PED' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.ped(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.ped.gz.gpg" ]
      },

      "bim-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a BIM file",
        "description": "This object exists to hold the filename pattern that a 'BIM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.bim(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.bim.gz.gpg" ]
      },

      "fam-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a FAM file",
        "description": "This object exists to hold the filename pattern that a 'FAM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.fam(.gz|.zip|.rar|.arj|.tar|.7z)?(.gpg)?$",
        "examples": [ "my_file1.fam.gz.gpg" ]
      },

      "object_external_accession": {
        "type": "object",
        "title": "Object of external accession of the object",
        "description": "External accession node containing the object accession (i.e. unique identifier -  each following their respective formats) assigned by other archives, the name of the archive (e.g. biosample, ena, ensembl...) and an optional label.",
        "additionalProperties": false,
        "required": ["external_accession", "accession_archive"],
        "properties": {
          "external_accession": {
            "type": ["string", "number"],
            "title": "External accession of the object",
            "description": "Unique identifier of the object (e.g. SAMEA7616999), assigned by other archives (e.g. biosample).",
            "examples": [ "SAMEA7616999" ]
          },
          "accession_archive": {
            "type": "string",
            "title": "Name of the archive",
            "description": "Name of the archive (e.g. biosample) from which the external accession is taken.",
            "enum": ["ensembl", "ena", "pubmed", "protein", "nuccore", "ipg", "nucleotide", "structure", "genome", "annotinfo", "assembly", "bioproject", "biosample", "blastdbinfo", "books", "cdd", "clinvar", "gap", "gapplus", "grasp", "dbvar", "gene", "gds", "geoprofiles", "homologene", "medgen", "mesh", "ncbisearch", "nlmcatalog", "omim", "orgtrack", "pmc", "popset", "proteinclusters", "pcassay", "protfam", "biosystems", "pccompound", "pcsubstance", "seqannot", "snp", "sra", "taxonomy", "biocollections", "gtr"],
            "meta:enum": ["ensembl__#! description TBD", "ena__#! description TBD", "pubmed__#! description TBD", "protein__#! description TBD", "nuccore__#! description TBD", "ipg__#! description TBD", "nucleotide__#! description TBD", "structure__#! description TBD", "genome__#! description TBD", "annotinfo__#! description TBD", "assembly__#! description TBD", "bioproject__#! description TBD", "biosample__#! description TBD", "blastdbinfo__#! description TBD", "books__#! description TBD", "cdd__#! description TBD", "clinvar__#! description TBD", "gap__#! description TBD", "gapplus__#! description TBD", "grasp__#! description TBD", "dbvar__#! description TBD", "gene__#! description TBD", "gds__#! description TBD", "geoprofiles__#! description TBD", "homologene__#! description TBD", "medgen__#! description TBD", "mesh__#! description TBD", "ncbisearch__#! description TBD", "nlmcatalog__#! description TBD", "omim__#! description TBD", "orgtrack__#! description TBD", "pmc__#! description TBD", "popset__#! description TBD", "proteinclusters__#! description TBD", "pcassay__#! description TBD", "protfam__#! description TBD", "biosystems__#! description TBD", "pccompound__#! description TBD", "pcsubstance__#! description TBD", "seqannot__#! description TBD", "snp__#! description TBD", "sra__#! description TBD", "taxonomy__#! description TBD", "biocollections__#! description TBD", "gtr__#! description TBD"],
            "examples": [ "biosample" ]
          },
          "accession_label": {
            "type": ["string", "number"],
            "title": "Label of the external accession",
            "description": "Optional label (e.g. 'taken from biosample temporarily') of the external accession, used to add extra information to the identifier.",
            "examples": [ "taken from biosample temporarily" ]
          }
        }
      },

      "sample-label-association": {
        "type": "object",
        "title": "Repeatable Sample-label node",
        "description": "The base node of a label-sample association. One form of basic identification of the sample (inherited from object_core_id - e.g. either the center name and alias or the accession) is required, as well as the label per se.",
        "required": ["label", "object_id"],
        "additionalProperties": false,
        "properties": {
          "label": { "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/array_label" },
          "object_id": {
            "type": "object",
            "title": "Object's IDs block",
            "allOf": [
              {
                "title": "Inherited object_core_id object",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_core_id"
              },
              {
                "title": "Check that sample EGA ID (EGAN) pattern is correct",
                "properties": {
                  "ega_accession": {
                    "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/EGA-sample-id-pattern"
                  }
                }
              }
            ]       
          }
        }
      },

      "one-relationship-end": {
        "type": "object",
        "title": "Relationship's object (either source or target)",
        "description": "Node containing metadata (identifiers and the type of reference) of one of the ends of the relationship, whether it is the source or the target of the relationship.",
        "additionalProperties": false,
        "required": ["object_id", "object_type"],
        "properties": {
          "object_id": {
            "type": "object",
            "title": "Relationship's object's IDs block",
            "description": "Node containing the main identifiers of the relationship's object (e.g. alias, center_name...), inherited from the common definitions (#/definitions/object_core_id).",
            "allOf": [
              { 
                "title": "Inherited object_core_id object", 
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_core_id" 
              }
            ]
          },
          "object_type": {
            "type": "string",
            "title": "Type of the relationship's object",
            "description": "Type of the relationship's object, chosen from a list of CV (e.g. arrayExperiment, dataset, external_URL...). Both the source or target types can be: (1) the object tag of one of EGA’s object (e.g. file, sample…); (2) an 'external_accession'; (3) or an 'external_URL'.",
            "enum": ["experiment", "study", "sample", "individual", "submission", "run", "dataset", "analysis", "policy", "DAC", "ArrayExperiment", "ArrayAssay", "external_accession", "external_URL"],
            "meta:enum": ["Contains information about the experimental design of the sequencing", "Information about the study", "Information about the used samples", "Information about the submission actions", "Contains information about the specific sequencing runs from the experiment", "Contains the collection of runs/analysis/ArrayAssay data files to be subject to controlled access", "Contains the analysis metadata and data files", "Contains information related to the Data Access Agreement (DAA) the dataset is subject to", "Contains information about the Data Access Committee (DAC)", "Contains information about the experimental design of the Array", "Contains information about the probed assay from the array", "An external accession among the ones Entrez (NCBI's text search) contemplates (search for the terms here: https://www.ncbi.nlm.nih.gov/entrez/eutils/einfo.fcgi?)", "An external URL resource, of any type"],
            "examples": [ "sample" ]
          }
        },
        "allOf": [
          { 
            "title": "Check for object_id and object_type to match",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object-id-and-object-type-check" 
          }
        ]        
      },

      "subject_id": {
        "type": "string",
        "title": "Subject ID",
        "description": "A unique identifir (e.g. 'Donor-10031') for the subject the sample derives from, providing context for the sample to be better understood through its provenance.",
        "examples": [ "Donor-10031", "ID001", "9001", "AX_Dli" ]
      },

      "biological_sex": {
        "type": "string",
        "title": "Biological sex of the individual [PATO:0000047]",
        "description": "An organismal quality inhering in a bearer by virtue of the bearer's physical expression of sexual characteristics. In other words, the trait that determines the individual's (from which the sample derives) reproductive function: mainly male or female.",
        "enum": [ "male", "female", "hermaphrodite", "unknown" ],
        "meta:enum": [ "A biological sex quality inhering in an individual or a population whose sex organs contain only male gametes.", "A biological sex quality inhering in an individual or a population that only produces gametes that can be fertilised by male gametes.", "An organism having both male and female sexual characteristics and organs. A biological sex quality inhering in an organism or a population with both male and female sexual organs in one individual.", "The biological sex is unknown." ],
        "examples": [ "male" ]
      },

      "experimental_condition_descriptor": {
        "type": "object",
        "title": "Experimental condition [XCO:0000000]",
        "description": "A state of being, an external or environmental factor or a treatment observed or administered prior to or concurrent with an investigative procedure such as an assessment of a morphological or physiological state or property in a single individual or sample or in a group of individuals or samples, especially a state, factor or treatment which has the potential to influence the outcome of such an assessment. We highly recommend the usage of ontologies to describe experimental conditions (search at 'https://www.ebi.ac.uk/ols/ontologies/efo').",
        "additionalProperties": false,
        "required": ["experimental_condition_term"],
        "properties": {
          "experimental_condition_term": {
            "type": "string",
            "title": "Experimental condition term",
            "description": "Human-readable term that specifies the experimental condition (e.g. 'fibroadenoma').",
            "examples": [ "control", "fibroadenoma", "osteonecrosis" ]
          },
          "experimental_condition_curie": {
            "type": "string",
            "title": "Experimental condition curie",
            "description": "Curie (i.e. ontologised term - e.g. 'EFO:0001461') of the experimental condition.",
            "examples": [ "EFO:0001461", "EFO:1000254", "EFO:0004259" ]
          },
          "experimental_condition_description": {
            "type": "string",
            "title": "Experimental condition description",
            "description": "Broad description of the experimental condition, providing further details and context over the ontologised term.",
            "examples": [
              "A control role is borne by a material in a process in which results obtained from an experimental sample and a control sample are compared.",
              "A benign tumor of the breast characterized by the presence of stromal and epithelial elements.", 
              "A none disease characterized by death of bone tissue due to a lack of blood supply."
            ]
          }
        }
      },

      "organism_descriptor": {
        "type": "object",
        "title": "Organism [OBI:0100026] descriptor block",
        "description": "This node describes the material entity the sample consists in. That is, an individual living system, such as animal, plant, bacteria or virus, that is capable of replicating or reproducing, growth and maintenance in the right environment. An organism may be unicellular or made up, like humans, of many billions of cells divided into specialized tissues and organs. This node is of special interest in case the provenance of the sample is not human (e.g. microbiota taken from a donor). Unless stated otherwise, given the nature of the EGA, it is expected to be of human provenance by default.",
        "additionalProperties": false,
        "properties": {
          "taxon_id": {
            "type": "string",
            "title": "Taxon identifier [APOLLO_SV:00000203]",
            "description": "Taxonomy Identifier (e.g. '9606' for humans) curated by the NCBI Taxonomy (search for your sample's here: https://www.ncbi.nlm.nih.gov/taxonomy). You can find further details at 'https://www.uniprot.org/help/taxonomic_identifier'. This is appropriate for individual organisms and some environmental samples.",
            "pattern": "^[0-9]{1,7}$",
            "examples": [ "9606" ]
          },
          "scientific_name": {
            "type": "string",
            "title": "Biologic entity classification scientific name [NCIT:C43459]",
            "description": "The name applied to a plant, animal, or other organism, according to the Codes of Nomenclature, consisting of a Genus and species (e.g. 'homo sapiens').",
            "examples": [ "homo sapiens" ]
          },
          "common_name": {
            "type": "string",
            "title": "Biologic entity classification common name [NCIT:C164690]",
            "description": "Common name (e.g. 'human') used to designate a plant, animal or other organism, as opposed to the scientific name.",
            "examples": [ "human" ]
          }
        },
        "anyOf": [
          {
            "title": "Either the taxon ID is provided", 
            "required": ["taxon_id"] 
          },
          {
            "title": "Or the scientific name is provided", 
            "required": ["scientific_name"] 
          }          
        ]
      }

    }    
  }