{
    "$schema": "https://json-schema.org/draft/2019-09/schema",
    "type": "object",
    "$id": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json",
    "title": "EGA common metadata definitions",
    "meta:version": "0.0.0",
    "description": "Metadata schema used by the European Genome-phenome Archive (EGA) to store common definitions for other metadata objects. Basically, we are defining here common properties (e.g. instances' aliases) that other metadata objects (e.g. sample) may use. The way we refer to them is by using this object's '$id' field, referencing it in other files (with '$ref' and the relative path of the property - e.g. '$ref': 'https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_core_id'). See structuring documentation (https://json-schema.org/understanding-json-schema/structuring.html). Further details can be found in the EGA-metadata-schema GitHub repository (https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas) and EGA-archive website (https://ega-archive.org/)",
    "definitions": {

      "object_core_id": {
        "type": "object",
        "title": "Core identifiers of an object",
        "description": "Base definition containing the properties (e.g. Sample's alias) of a minimal identification layer of an EGA object (e.g. Sample).",
        "additionalProperties": false,
        "properties": {
          "alias": {
            "type": "string",
            "title": "Alias of an object",
            "description": "Submitter designated name (e.g. 'my_sample_J13') for the object (e.g. Sample). The name must be unique within the submission account (e.g. 'ega-box-79'), since the aliases and submission accounts are concatenated within our database to obtain the unique alias (e.g. 'ega-box-79::my_sample_J13').",
            "minLength": 1,
            "examples": [ "my_sample_J13" ]
          },
          "center_name": {
            "type": "string",
            "title": "Center name of the submitter",
            "description": "Center name (e.g. 'EBI-TEST') associated to the submitter. In other words, it is the acronym of the submitter's account (provided by the HelpDesk team).",
            "minLength": 1,
            "examples": [ "EBI-TEST" ]
          },
          "ega_accession": {
            "type": "string",
            "title": "EGA's accession of the object",
            "description": "The object accession (i.e. unique identifier) assigned by the archive (EGA). Object accessions can be found in the 'Identifiers' section of the EGA-archive website (https://ega-archive.org/metadata/how-to-use-the-api) and commonly start with EGA, followed by the distinctive letter of the object and finally the numeric ID of the instance.",
            "examples": [ "EGAN00003245489" ]
          },
          "external_accessions": {
            "type": "array",
            "title": "External accessions array",
            "description": "External accession node to reference objects in other archives (e.g. an already existing sample at BioSamples).",
            "minItems": 1,
            "additionalProperties": false,
            "uniqueItems": true,
            "items": {
              "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_external_accession"
            }
          }

        },
        "anyOf": [
          { 
            "title": "Check core IDs: combination of Alias and Center name",
            "required": ["alias", "center_name"] 
          },
          { 
            "title": "Check core IDs: EGA accession ID",
            "required": ["ega_accession"] 
          },
          { 
            "title": "Check core IDs: external accessions",
            "required": ["external_accessions"] 
          }
        ]
      },

      "custom_attribute": {
        "type": "object",
        "title": "Custom attribute of an object",
        "description": "Reusable attributes to encode tag-value pairs (e.g. Tag being 'Age' and its Value '40') with optional units (e.g. 'years').",
        "required": ["tag", "value"],
        "additionalProperties": false,
        "properties": {
          "tag": {
            "type": "string",
            "title": "Tag of the custom attribute",
            "description": "The name of the attribute (e.g. 'Age').",
            "minLength": 1,
            "examples": [ "age" ]
          },
          "value": {
            "type": ["string", "number"],
            "title": "Value of the custom attribute",
            "description": "The value of the attribute (e.g. '40').",
            "examples": [ "smoker", 40 ]
          },
          "units": {
            "type": "string",
            "title": "Units of the custom attribute",
            "description": "The optional units of the attribute (e.g. 'years').",
            "minLength": 1,
            "examples": [ "years" ]
          }
        }        
      },

      "file_object": {
        "type": "object",
        "title": "EGA File object",
        "description": "Object containing the base metadata attributes of a file object in the EGA. These can inherited elsewhere with or without extending them.",
        "required": ["filename", "filetype", "checksum_method", "unencrypted_checksum", "encrypted_checksum"],
        "additionalProperties": false,
        "properties": {
          "filename": {
            "type": "string",
            "title": "Filename",
            "meta:property_curie": "data:1050",
            "description": "The full name of a file, including all of their file extensions (e.g. .gpg, .md5...), that identifies the file (e.g. 'my-bam-file.bam.gpg').",
            "pattern": "^[^<>:;,?\"*|]+$",
            "examples": [ "my-bam-file.bam.gpg" ]
          },
          "filetype": {
            "type": "string",
            "title": "Filetype",
            "meta:property_curie": "NCIT:C172272",
            "description": "The nature of the content stored in an electronic file. The string corresponds to the ID or name (e.g. FASTA or TSV), chosen from a list of controlled vocabulary (CV), associated with the given filetype. If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "required": ["filetype_id"],
            "additionalProperties": false,
            "enum": ["CEL", "TSV", "ADF", "FASTQ", "FASTA", "SDRF", "IDF", "VCF", "SRA", "SRF", "SFF", "BAM", "CRAM", "XLSX", "CSV", "BED", "IDAT", "MAP", "PED", "BIM", "FAM", "TXT", "EXP", "GPR", "PY", "SH"],
            "meta:enum": ["CEL__EFO:0005630: ", "TSV__NCIT:C164049. Tab delimited text file commonly used to deliver certain phenotype or auxiliary data along with sequencing submissions (only needed for certain use cases). The first line is normally devoted to column headers. When used along sequencing files in a sequencing assay, each column is dedicated to an INDSC data series type.", "ADF__NCIT:C172213", "FASTQ__EFO:0004155", "FASTA__NCIT:C47845", "SDRF__NCIT:C172211", "IDF__NCIT:C172212", "VCF__NCIT:C172216", "SRA__format:3698", "SRF__EFO:0004154", "SFF__EFO:0004156", "BAM__EFO:0004157", "CRAM__format:3462", "XLSX__format:3620", "CSV__format:3752", "BED__format:3003", "IDAT__format:3578", "MAP__format:3285", "PED__format:3286", "BIM__", "FAM__", "EXP__format:1631", "GPR__format:3829", "PY__format:3996", "SH__ - Bash scripts"]
          },
          "checksum_method": {
            "type": "string",
            "title": "Checksum method ID",
            "meta:property_curie": "REPR:ChecksumAlgorithm",
            "description": "Node containing both the ID (MD5 or SHA-256), describing the method which yields the checksum from a data input for the purpose of detecting errors. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "additionalProperties": false,
            "enum": ["MD5", "SHA-256"],
            "meta:enum": ["MD5__NCIT:C171276", "SHA-256__NCIT:C80226"]
          },
          "unencrypted_checksum": {
            "type": "string",
            "title": "Checksum [NCIT:C43522] of the unencrypted file",
            "description": "A computed value which depends on the contents of a block of data and which is transmitted or stored along with the data in order to detect corruption of the data, computed from the unencrypted files.",
            "examples": [ "46798b5cfca45c46a84b7419f8b74735" ],
            "oneOf": [
              { 
                "title": "Check of MD5 checksum pattern", 
                "$ref": "#/definitions/md5-checksum-pattern"
              },
              { 
                "title": "Check of SHA-256 checksum pattern",
                "$ref": "#/definitions/SHA-256-checksum-pattern"
              }
            ]
          },
          "encrypted_checksum": {
            "type": "string",
            "title": "Checksum [NCIT:C43522] of the encrypted file",
            "description": "A computed value which depends on the contents of a block of data and which is transmitted or stored along with the data in order to detect corruption of the data, computed from the encrypted files.",
            "examples": [ "bc527343c7ffc103111f3a694b004e2f" ],
            "oneOf": [
              { 
                "title": "Check of MD5 checksum pattern", 
                "$ref": "#/definitions/md5-checksum-pattern"
              },
              { 
                "title": "Check of SHA-256 checksum pattern",
                "$ref": "#/definitions/SHA-256-checksum-pattern"
              }
            ]
          },
          "sequence_quality_details": {
            "type": "object",
            "title": "Sequence quality details",
            "description": "Sequencing quality scores measure the probability that a base is called (i.e. sequenced) incorrectly. New sequencing technologies assign a quality score to each of the bases in the sequence.",
            "required": ["quality_scoring_system"],
            "additionalProperties": false,
            "properties": {
              "quality_scoring_system": {
                "type": "string",
                "title": "Quality scoring system",
                "description": "How the quality score was computed for the data.",
                "enum": ["phred", "log-odds"],
                "meta:enum": [ "phred: The quality score is expressed as a probability of error in log form: -10 log(1/p) where p is the probability of error, with value range 0..63 (0 meaning no base call).", "log-odds: The quality score is expressed as the ratio of error to non-error in log form: -10 log(p/(1-p)) where p is the of error, with value range -40..40. The SRA will convert these into phred scale during loadtime." ]
              },
              "quality_encoding": {
                "type": "string",
                "title": "Quality encoding format",
                "description": "Encoding system used to represent the quality score.",
                "enum": ["ascii", "decimal", "hexadecimal"],
                "meta:enum": ["ascii: ASCII character based encoding.", "decimal: Single decimal value per quality score.", "hexadecimal: Single hexadecimal value per quality score."]
              },
              "ascii_offset": {
                "type": "string",
                "title": "ASCII offset",
                "description": "Character used in representing the minimum quality value.  Helps specify how to decode text rendering of quality data.",
                "enum": ["!", "@"],
                "meta:enum": ["!: ASCII value 33.  Typically used for range 0..63.", "@: ASCII value 64.  Typically used for range 0..60."]
              }
            }
          }
        },
        "allOf": [
          { 
            "title": "Inherited check of checksum patterns", 
            "$ref": "#/definitions/checksum-pattern-check" 
          },
          { 
            "title": "Inherited check of filetype-filename patterns", 
            "$ref": "#/definitions/filename-filetype-pattern-check" 
          }
        ]        
      },

      "relationship_object": {
        "type": "object",
        "title": "EGA Relationships object",
        "description": "Object containing the base metadata attributes of a relationship object in the EGA. Comprises metadata (e.g. Source or Target) of a directional association between two entities. One of the entitis **needs** to be the current instance. For instance, a study JSON document should not contain relationships between a sample and an individual. Therefore, only one end of the relationship is given: if the source is present, the target is inferred to be the current instance; if the target is given, then it's the source the one inferred as the current instance. Examples of common relationships: (1) a sample being referenced in an experiment; (2) an study being the same as another study at a different archive (e.g. in BioStudies); (3) an individual being the parent of another individual; (4) hundreds of samples being grouped with each other for broad reasons.",
        "required": ["r_type"],
        "additionalProperties": false,
        "properties": {
          "r_type": {
            "type": "string",
            "title": "Relationship type",
            "description": "ID (e.g. same_as) of the type of the relationship. To be chosen from a controlled vocabulary (CV) list. If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "enum": ["referenced_by", "develops_from", "same_as", "member_of", "grouped_with", "family_relationship_with", "child_of", "is_after", "published_in", "submitted_by", "contact_of", "main_contact_of"],
            "meta:enum": ["referenced_by__SIO:000252", "develops_from__RO:0002202", "same_as__NCIT:C64637", "member_of__RO:0002350", "grouped_with__", "family_relationship_with__EFO:0004424", "child_of__GSSO:000728", "is_after__SIO:000211", "published_in__EFO:0001796", "submitted_by__NCIT:C25695", "contact_of__NCIT:C25461", "main_contact_of__"],
            "examples": [ "referenced_by" ]
          },
          "r_source": {
            "type": "object",
            "title": "Source of the relationship",
            "description": "Object reference of the relationship's source. In other words, the starting point of the relationship: in 'sample_A develops_from sample_B' the source is 'sample_A'.",
            "allOf": [
              {
                "title": "Inherited one-relationship-end object", 
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/one-relationship-end" 
              }
            ]
          },
          "r_target": {
            "type": "object",
            "title": "Target of the relationship",
            "description": "Object reference of the relationship's target. In other words, the ending point of the relationship: in 'sample_A develops_from sample_B' the target is 'sample_B'.",
            "allOf": [
              {
                "title": "Inherited one-relationship-end object", 
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/one-relationship-end" 
              }
            ]
          },
          "r_label": {
            "type": "string",
            "title": "Custom label of the relationship",
            "description": "Custom free-form label of the relationship, used to add extra details of the relationship if needed.",
            "minLength": 1,
            "examples": [ 
              "Source individual is the third child of the target individual", 
              "Grouped samples by colour of the medium",
              "Both samples are the same because of an error in the submission at..."
            ]
          }
        },
        "oneOf": [
          {
            "title": "The source is given (i.e. the target is inferred as the current instance)",
            "required": ["r_source"]
          },
          {
            "title": "The target is given (i.e. the source is inferred as the current instance)",
            "required": ["r_target"]
          }
        ]       
      },

      "protocols_object": {
        "type": "object",
        "title": "EGA Protocols object",
        "description": "A protocol is an information entity which is a set of instructions that describe an how a procedure, analysis or experiment is done. Comprises metadata (e.g. Type of protocol) of a plan specification, with sufficient level of detail and quantitative information to communicate it (and thus reproduce it) between investigation agents.",
        "required": ["protocol_step_index", "previous_protocol_step_index", "protocol_type_descriptor", "protocol_description"],
        "additionalProperties": false,
        "properties": {
          "protocol_name": {
            "type": "string",
            "title": "Name of the protocol",
            "meta:property_curie": "NCIT:C42614",
            "description": "Name of the protocol (e.g. 'myProtocol-13'). To be defined by the user.",
            "minLength": 1,
            "examples": [ "myProtocol-13", "Treatment for leukemia patients C30", "Sample collection from infected patients" ]
          },

          "protocol_step_index": {
            "type": "number",
            "title": "Protocol step index",
            "description": "Lexically ordered value (greater than 0) that allows for the protocol section to be sequentially ordered. The float primitive data type is used to allow for pipe sections to be inserted later on. In other words, adding a new intermediate step 1.1 between steps 1 and 2 afterwards. For example, in an experiment where we treated samples before its DNA extraction, the sample treatment protocol would have a lower 'protocol_step_index' than the DNA extraction.",
            "min": 0,
            "examples": [ 0.5, 1, 2.5, 2, 30 ]
          },

          "previous_protocol_step_index": {
            "type": "number",
            "title": "Previous protocol step index",
            "description": "The 'protocol_step_index' of the previous protocol, if hierarchically ordered. Set to '0' if this protocol is the first step. In case several protocols are not sequential, both can share the same 'previous_protocol_step_index'.",
            "minInclusive": 0,
            "examples": [ 0, 0.5, 1, 2.5, 2, 30 ]
          },

          "protocol_type_descriptor": {
            "type": "object",
            "title": "Protocol type descriptor",
            "description": "Node to contain the information about the type and subtype of the protocol. References to ontologies allow for a clear provenance and documentation of the protocol type, and hence we highly recommend their usage.",
            "required": ["protocol_type", "protocol_subtype_curie"],
            "additionalProperties": false,
            "properties": {
              "protocol_type": {
                "type": "string",
                "title": "Type of protocol",
                "meta:property_curie": "OBI:0000272",
                "description": "Classification by type of the protocol (e.g. 'Sample collection'), to be chosen from a controlled vocabulary (CV) list. If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
                "enum": ["high Content Screen (HCS)", "conversion", "delivery method", "dissection", "dissociation", "enrichment", "extraction", "gene expression", "growth", "hybridization", "hydrolysis collection", "labelling", "nucleic acid library construction", "nucleic acid sequencing", "sample collection", "single cell isolation", "treatment", "data transformation"],
                "meta:enum": ["High Content Screen (HCS)__EFO:0007570", "Conversion__EFO:0005520", "Delivery method_EFO:0000395", "Dissection__EFO:0005519", "Dissociation__EFO:0009088", "Enrichment__EFO:0009089", "Extraction__EFO:0002944", "Gene expression__EFO:0003788", "Growth__EFO:0003789", "Hybridization__EFO:0003815", "Hydrolysis collection__EFO:0010892", "Labelling__EFO:0003813", "Nucleic acid library construction__EFO:0004184", "Nucleic acid sequencing__EFO:0004170", "Sample collection__EFO:0005518", "Single cell isolation__EFO:0010214", "Treatment__EFO:0003969", "Data transformation__OBI:0200000"]
              },

              "protocol_subtype": {
                "type": "string",
                "title": "Subtype of the protocol",
                "description": "Name of the protocol's subtype. We highly recommend the usage of names given to ontologized protocols, specially those at the [Experimental Factor Ontology (EFO)](https://www.ebi.ac.uk/ols/ontologies/efo). For example, if the protocol corresponds to a data transformation of a genome, you may find your subtype at [genome analysis](http://edamontology.org/operation_3918); while treating a patient with a drug would correspond to a [clinical treatment](http://www.ebi.ac.uk/efo/EFO_0007056).",
                "examples": [ "clinical treatment", "array scanning and feature extraction", "Genome alignment", "Genome annotation", "Genome assembly", "Genome comparison", "Genome feature comparison", "Genome indexing", "Genome visualisation", "Whole genome methylation analysis" ]    
              },

              "protocol_subtype_curie": {
                "type": "string",
                "title": "Compact URI (CURIE) of the protocol subtype",
                "description": "Ontology term in CURIE format (e.g. 'EFO:0005518') of the protocol subtype. Search for the ontologized term at the [Ontology Lookup Service (OLS)](https://www.ebi.ac.uk/ols/index). This allows for a specific designation of the protocol within the overall general of the 'protocol_type' field. For instance, the CURIE for Treatment's subtype 'clinical treatment' would be 'EFO:0003814'. If the protocol does not require a subtype, use the CURIE for the protocol type per se (e.g. 'EFO:0005518' for 'Sample collection').",
                "allOf": [
                  {
                    "title": "General CURIE pattern",
                    "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
                  }
                ],
                "examples": ["EFO:0005518",  "EFO:0002944",  "EFO:0003813",  "EFO:0003815",  "EFO:0003814",  "EFO:0004184",  "EFO:0003789",  "EFO:0009088", "EFO:0009089", "EFO:0003969", "EFO:0005520", "EFO:0000355", "EFO:0005519", "EFO:0003788", "EFO:0000395", "EFO:0010892", "EFO:0010214"]
              }
            }
          },

          "protocol_performers": {
            "type": "array",
            "title": "Protocol performers array",
            "description": "Array of performers' descriptions of those individuals, groups, or institutions that executed the protocol.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "string",
              "title": "Performer of the protocol",
              "description": "Free form text to specify the institution, group, or individuals that performed the protocol.",
              "minLength": 1,
              "examples": ["EGA's Operational bioinformatics group", "Lab technician"]             
            }
          },

          "protocol_instrument": {
            "type": "array",
            "title": "Protocol instrument array",
            "meta:property_curie": "EFO:0000548",
            "description": "Array of instruments used in the protocol.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "string",
              "title": "Instrument used in the protocol",
              "meta:property_curie": "EFO:0000548",
              "description": "Free form text to specify the device, which provides a mechanical or electronic function, and was used by the performer of the protocol. We highly recommend the usage of ontologized terms (e.g. 'Oligonucleotide synthesizer') from the [Experimental Factor Ontology (EFO)](http://www.ebi.ac.uk/efo/EFO_0000548) along their CURIEs between square brackets (e.g. '[OBI:0400113]').",
              "minLength": 1,
              "examples": ["Computer [OBI:0400107]", "Oligonucleotide synthesizer [OBI:0400113]", "Sonicator [OBI:0400114]"]             
            }
          },

          "protocol_software": {
            "type": "array",
            "title": "Protocol software array",
            "meta:property_curie": "IAO:0000010",
            "description": "Array of software descriptions used in the protocol.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "string",
              "title": "Software descriptions used in the protocol",
              "meta:property_curie": "IAO:0000010",
              "description": "Free form text to specify the programs and other operating information (including bespoken scripts) used by a computer that were used by the performer of the protocol. Include the version of the program, if applicable. We highly recommend the usage of ontologized terms (e.g. 'SAMtools') from the [Software Ontology (SWO)](https://www.ebi.ac.uk/ols/ontologies/swo) along their versions (e.g. 'v3.0.1') and CURIEs between square brackets (e.g. '[SWO:1100143]').",
              "minLength": 1,
              "examples": ["SAMtools v3.0.1 [SWO:1100143]", "MATLAB [SWO:0000005]"]         
            }
          },
          
          "protocol_description": {
            "type": "string",
            "title": "Description of the protocol",
            "meta:property_curie": "NCIT:C25365",
            "description": "Description of the protocol (e.g. 'First tilt the cell culture flask... ...and finally let it still for 2 hours.'), being descriptive enough to be replicated between institutions or performers.",
            "examples": [ "First tilt the cell culture flask... ...and finally let it still for 2 hours.", "Patients were given a ketogenic diet for 3 weeks at intervals consisting in..." ]
          }
        }
      },

      "array_label": {
        "type": "object",
          "title": "Repeatable array_label node",
          "description": "Chemicals conjugated to nucleic acid/proteins to label them before microarray hybridisation. This node corresponds to the basic description of one single label, and thus should be repeated as an array where inherited if multiple labels are intended to be described. Its basic structure is a label ID and its optional CURIE.",
          "required": ["array_label_id"],
          "additionalProperties": false,
          "properties": {
            "array_label_id": {
              "type": "string",
              "title": "Array label of the array experiment - ID",
              "description": "ID/name (e.g. 'Cy3 dye' or 'Biotin') of the Array label used for the experiment.",
              "examples": [ "Cy3 dye" ]
            },
            "array_label_curie": {
              "type": "string",
              "title": "Array label of the array experiment - CURIE",
              "description": "CURIE (i.e. ontologized term - e.g. 'CHEBI:37987' or 'CHEBI:15956') of the Array label used for the experiment. Search for the ontologized term at the [Ontology Lookup Service (OLS)](https://www.ebi.ac.uk/ols/index).",
              "allOf": [
                {
                  "title": "General pattern of a CURIE",
                  "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
                }
              ],
              "examples": [ "CHEBI:37987" ]
            },
            "label_description": {
              "type": "string",
              "title": "Array label of the array experiment - Description",
              "description": "Additional description of the used label, indicating further details: context, purpose of the label, description of the label in the absence of an ontologized term, etc.",
              "examples": [ 
                "This label was use to dye the control samples",
                "This newly discovered label (yet to be added to an ontology) consists in a compound of type X...",
                "The label ID is unknown because we were given the RNA already dyed..." ]
            }
          }
      },

      "object-id-and-object-type-check": {
        "type": "object",
        "title": "Check that the object_id's accession pattern and object_type match",
        "description": "This object exists with the only purpose of being a reference as a pattern check of a given object_id and object_type. The constraint consists in asserting that, if the object identifier is an EGA accession, its pattern matches the object type (e.g. if object_type is 'sample', its EGA accession needs to match '^EGAN[0-9]{11}$')",
        "anyOf": [
          {
            "title": "Alias and Centername: object_id and object_type check",
            "description": "A check that ensures that the alias and centername are given as the object_type. Since the alias and centername cannot be checked for specific object_types (i.e. each can name their objects in different ways), this block exists here just so that this option is allowed.",
            "properties": {
              "object_id": { 
                "required": ["alias", "center_name"]
              }
            }
          },
          {
            "title": "External accession: object_id and object_type check",
            "description": "A check that ensures that, if 'external_accession' is given as the object_type, the corresponding node exists within object_id",
            "properties": {
              "object_id": { 
                "required": ["external_accessions"]
              },
              "object_type": {
                "enum": ["external_accession"]
              }
            }
          },
          {
            "title": "Experiment: object_id and object_type check",
            "description": "A check that ensures that, if 'experiment' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-experiment-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["experiment"]
              }
            }
          }, 
          {
            "title": "Study: object_id and object_type check",
            "description": "A check that ensures that, if 'study' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-study-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["study"]
              }
            }
          },          
          {
            "title": "Sample: object_id and object_type check",
            "description": "A check that ensures that, if 'sample' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-sample-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["sample"]
              }
            }
          },          
          {
            "title": "Submission: object_id and object_type check",
            "description": "A check that ensures that, if 'submission' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-submission-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["submission"]
              }
            }
          },          
          {
            "title": "Assay: object_id and object_type check",
            "description": "A check that ensures that, if 'assay' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-assay-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["assay"]
              }
            }
          },          
          {
            "title": "Dataset: object_id and object_type check",
            "description": "A check that ensures that, if 'dataset' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-dataset-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["dataset"]
              }
            }
          },          
          {
            "title": "Analysis: object_id and object_type check",
            "description": "A check that ensures that, if 'analysis' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-analysis-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["analysis"]
              }
            }
          },          
          {
            "title": "Policy: object_id and object_type check",
            "description": "A check that ensures that, if 'policy' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-policy-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["policy"]
              }
            }
          },          
          {
            "title": "DAC: object_id and object_type check",
            "description": "A check that ensures that, if 'DAC' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-DAC-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["DAC"]
              }
            }
          },
          {
            "title": "Individual: object_id and object_type check",
            "description": "A check that ensures that, if 'individual' is given as the object_type and an EGA accession for it is given, it matches the corresponding EGA ID pattern.",
            "properties": {
              "object_id": { 
                "properties": {
                  "ega_accession": { "$ref": "#/definitions/EGA-individual-id-pattern" }
                }
              },
              "object_type": {
                "enum": ["individual"]
              }
            }
          }
        ]                      
      },
      
      "checksum-pattern-check": {
        "type": "object",
        "title": "Check: checksum checks based on its method",
        "description": "This object exists with the only purpose of being a reference of pattern checks of the given checksum (e.g. 'c6779ec2960296ed9a04f08d67f64423') of a file based on its corresponding method (e.g. if the given checksum method is 'MD5' the checksum shall fit into MD5's format of '^[0-9a-z](?:-?[0-9a-z]){31}$')",
        "anyOf": [
          { 
            "title": "Checksum pattern check - MD5",
            "description": "A check that ensures that, if MD5 is given as a checksum_method_id, the checksums per se (e.g. unencrypted_checksum) follow MD5 patterns (md5-checksum-pattern).",
              "properties": {
                "checksum_method": {
                      "enum": ["MD5"]
                },
                "unencrypted_checksum": { "$ref": "#/definitions/md5-checksum-pattern" },
                "encrypted_checksum": { "$ref": "#/definitions/md5-checksum-pattern" }
              }
          },
          { 
            "title": "Checksum pattern check - SHA-256",
            "description": "A check that ensures that, if SHA-256 is given as a checksum_method_id, the checksums per se (e.g. unencrypted_checksum) follow SHA-256 patterns (sha-256-checksum-pattern).",
              "properties": {
                "checksum_method": {
                      "enum": ["SHA-256"]
                },
                "unencrypted_checksum": { "$ref": "#/definitions/SHA-256-checksum-pattern" },
                "encrypted_checksum": { "$ref": "#/definitions/SHA-256-checksum-pattern" }
              }
          }
        ]                    
      },

      "md5-checksum-pattern": {
        "type": "string",
        "title": "Checksum pattern obtained by MD5",
        "description": "This object exists to hold the pattern that a checksum would have if it was obtained using the algorithm MD5, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[0-9a-z](?:-?[0-9a-z]){31}$",
        "examples": [ "bc527343c7ffc103111f3a694b004e2f" ]
      },

      "SHA-256-checksum-pattern": {
        "type": "string",
        "title": "Checksum pattern obtained by SHA-256",
        "description": "This object exists to hold the pattern that a checksum would have if it was obtained using the algorithm SHA-256, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[A-Fa-f0-9]{64}$",
        "examples": [ "c01b39c7a35ccc3b081a3e83d2c71fa9a767ebfeb45c69f08e17dfe3ef375a7b" ]
      },

      "EGA-experiment-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA experiment's ID (EGAX...)",
        "pattern": "^EGAX[0-9]{11}$",
        "examples": [ "EGAX00002189113" ]
      },
      
      "EGA-study-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA study's ID (EGAS...)",
        "pattern": "^EGAS[0-9]{11}$",
        "examples": [ "EGAS00001004508" ]
      },

      "EGA-sample-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA sample's ID (EGAN...)",
        "pattern": "^EGAN[0-9]{11}$",
        "examples": [ "EGAN00003245489" ]
      },

      "EGA-submission-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA submission's ID (EGAB...)",
        "pattern": "^EGAB[0-9]{11}$",
        "examples": [ "EGAB00001001831" ]
      },

      "EGA-assay-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA assay's ID (EGAR...)",
        "pattern": "^EGAR[0-9]{11}$",
        "examples": [ "EGAR00001314547" ]
      },

      "EGA-dataset-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA dataset's ID (EGAD...)",
        "pattern": "^EGAD[0-9]{11}$",
        "examples": [ "EGAD00001004170" ]
      },

      "EGA-analysis-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA analysis's ID (EGAZ...)",
        "pattern": "^EGAZ[0-9]{11}$",
        "examples": [ "EGAZ00001004170" ]
      },

      "EGA-policy-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA policy's ID (EGAP...)",
        "pattern": "^EGAP[0-9]{11}$",
        "examples": [ "EGAP00001001831" ]
      },

      "EGA-DAC-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA DAC's ID (EGAC...)",
        "pattern": "^EGAC[0-9]{11}$",
        "examples": [ "EGAC00001000908" ]
      },

      "EGA-individual-id-pattern": {
        "type": "string",
        "title": "Pattern of an EGA Individual's ID (EGAI...)",
        "pattern": "^EGAI[0-9]{11}$",
        "examples": [ "EGAI00001159712" ]
      },

      "EGA-ISO-date-YYYY-MM-DD-pattern": {
        "type": "string",
        "title": "Pattern of an EGA ISO date (YYYY-MM-DD)",
        "pattern": "^[0-9]{4}-(0[0-9]|1[0-2])-([012][0-9]|3[01])$",
        "examples": [ "2021-04-30" ]
      },

      "filename-filetype-pattern-check": {
        "type": "object",
        "title": "Check: filetype checks based on its filename",
        "description": "This object exists with the only purpose of being a reference of pattern checks of the given filetype of a file based on its corresponding filename (e.g. if the file is 'alignment.bam.gz.gpg' its filetype_id shall be 'BAM' and not 'XLSX')",
        "anyOf": [
          {
            "title": "CEL Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["CEL"] 
                },
                "filename": { "$ref": "#/definitions/cel-file-filename-pattern" }
            }
          },                
          {
            "title": "TSV Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["TSV"] 
                },
                "filename": { "$ref": "#/definitions/tsv-file-filename-pattern" }
            }
          },                
          {
            "title": "ADF Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["ADF"] 
                },
                "filename": { "$ref": "#/definitions/adf-file-filename-pattern" }
            }
          },                
          {
            "title": "FASTQ Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["FASTQ"] 
                },
                "filename": { "$ref": "#/definitions/fastq-file-filename-pattern" }
            }
          },                
          {
            "title": "FASTA Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["FASTA"] 
                },
                "filename": { "$ref": "#/definitions/fasta-file-filename-pattern" }
            }
          },                
          {
            "title": "SDRF Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["SDRF"] 
                },
                "filename": { "$ref": "#/definitions/sdrf-file-filename-pattern" }
            }
          },                
          {
            "title": "IDF Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["IDF"] 
                },
                "filename": { "$ref": "#/definitions/idf-file-filename-pattern" }
            }
          },                
          {
            "title": "VCF Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["VCF"] 
                },
                "filename": { "$ref": "#/definitions/vcf-file-filename-pattern" }
            }
          },                
          {
            "title": "SRA Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["SRA"] 
                },
                "filename": { "$ref": "#/definitions/sra-file-filename-pattern" }
            }
          },                
          {
            "title": "SRF Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["SRF"] 
                },
                "filename": { "$ref": "#/definitions/srf-file-filename-pattern" }
            }
          },                
          {
            "title": "SFF Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["SFF"] 
                },
                "filename": { "$ref": "#/definitions/sff-file-filename-pattern" }
            }
          },                
          {
            "title": "BAM Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["BAM"] 
                },
                "filename": { "$ref": "#/definitions/bam-file-filename-pattern" }
            }
          },                
          {
            "title": "CRAM Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["CRAM"] 
                },
                "filename": { "$ref": "#/definitions/cram-file-filename-pattern" }
            }
          },                
          {
            "title": "XLSX Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["XLSX"] 
                },
                "filename": { "$ref": "#/definitions/xlsx-file-filename-pattern" }
            }
          },                
          {
            "title": "CSV Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["CSV"] 
                },
                "filename": { "$ref": "#/definitions/csv-file-filename-pattern" }
            }
          },                
          {
            "title": "BED Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["BED"] 
                },
                "filename": { "$ref": "#/definitions/bed-file-filename-pattern" }
            }
          },                
          {
            "title": "IDAT Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["IDAT"] 
                },
                "filename": { "$ref": "#/definitions/idat-file-filename-pattern" }
            }
          },                
          {
            "title": "MAP Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["MAP"] 
                },
                "filename": { "$ref": "#/definitions/map-file-filename-pattern" }
            }
          },                
          {
            "title": "PED Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["PED"] 
                },
                "filename": { "$ref": "#/definitions/ped-file-filename-pattern" }
            }
          },                
          {
            "title": "BIM Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["BIM"] 
                },
                "filename": { "$ref": "#/definitions/bim-file-filename-pattern" }
            }
          },                
          {
            "title": "FAM Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["FAM"] 
                },
                "filename": { "$ref": "#/definitions/fam-file-filename-pattern" }
            }
          },
          {
            "title": "TXT Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["TXT"] 
                },
                "filename": { "$ref": "#/definitions/txt-file-filename-pattern" }
            }
          },
          {
            "title": "EXP Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["EXP"] 
                },
                "filename": { "$ref": "#/definitions/exp-file-filename-pattern" }
            }
          },
          {
            "title": "GPR Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["GPR"] 
                },
                "filename": { "$ref": "#/definitions/gpr-file-filename-pattern" }
            }
          },
          {
            "title": "PY Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["PY"] 
                },
                "filename": { "$ref": "#/definitions/py-file-filename-pattern" }
            }
          },
          {
            "title": "SH Filename pattern-check",
            "properties": {
                "filetype": {
                   "enum": ["SH"] 
                },
                "filename": { "$ref": "#/definitions/sh-file-filename-pattern" }
            }
          }          
        ]        
      },

      "cel-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a CEL file",
        "description": "This object exists to hold the filename pattern that a 'CEL' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.cel(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.cel.gz.gpg" ]
      },

      "tsv-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a TSV file",
        "description": "This object exists to hold the filename pattern that a 'TSV' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.tsv(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.tsv.gz.gpg" ]
      },

      "adf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a ADF file",
        "description": "This object exists to hold the filename pattern that a 'ADF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.adf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.adf.gz.gpg" ]
      },

      "fastq-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a FASTQ file",
        "description": "This object exists to hold the filename pattern that a 'FASTQ' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.(fastq|fq)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fastq.gz.gpg" ]
      },

      "fasta-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a FASTA file",
        "description": "This object exists to hold the filename pattern that a 'FASTA' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.fasta(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fasta.gz.gpg" ]
      },

      "sdrf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SDRF file",
        "description": "This object exists to hold the filename pattern that a 'SDRF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.sdrf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sdrf.gz.gpg" ]
      },

      "idf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a IDF file",
        "description": "This object exists to hold the filename pattern that a 'IDF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.idf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.idf.gz.gpg" ]
      },

      "vcf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a VCF file",
        "description": "This object exists to hold the filename pattern that a 'VCF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.vcf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.vcf.gz.gpg" ]
      },

      "sra-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SRA file",
        "description": "This object exists to hold the filename pattern that a 'SRA' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.sra(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sra.gz" ]
      },

      "srf-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SRF file",
        "description": "This object exists to hold the filename pattern that a 'SRF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.srf(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.srf.gz.gpg" ]
      },

      "sff-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SFF file",
        "description": "This object exists to hold the filename pattern that a 'SFF' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.sff(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sff.gz.gpg" ]
      },

      "bam-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a BAM file",
        "description": "This object exists to hold the filename pattern that a 'BAM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.bam(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bam.arj.gpg" ]
      },

      "cram-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a CRAM file",
        "description": "This object exists to hold the filename pattern that a 'CRAM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.cram(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.cram.gz.gpg" ]
      },

      "xlsx-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a  file",
        "description": "This object exists to hold the filename pattern that a 'XLSX' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.xlsx(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.xlsx.tar.gpg" ]
      },

      "csv-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a CSV file",
        "description": "This object exists to hold the filename pattern that a 'CSV' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.csv(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.csv" ]
      },

      "bed-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a BED file",
        "description": "This object exists to hold the filename pattern that a 'BED' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.bed(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bed.gz.gpg" ]
      },

      "idat-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a IDAT file",
        "description": "This object exists to hold the filename pattern that a 'IDAT' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.idat(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.idat.zip" ]
      },

      "map-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a MAP file",
        "description": "This object exists to hold the filename pattern that a 'MAP' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.map(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.map.gpg" ]
      },

      "ped-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a PED file",
        "description": "This object exists to hold the filename pattern that a 'PED' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.ped(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.ped.gz.gpg" ]
      },

      "bim-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a BIM file",
        "description": "This object exists to hold the filename pattern that a 'BIM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.bim(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.bim.gz.gpg" ]
      },

      "fam-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a FAM file",
        "description": "This object exists to hold the filename pattern that a 'FAM' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^.+\\.fam(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.fam.gz.gpg" ]
      },

      "txt-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a TXT file",
        "description": "This object exists to hold the filename pattern that a 'TXT' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(txt|TXT)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.txt.gz.gpg" ]
      },

      "exp-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a EXP file",
        "description": "This object exists to hold the filename pattern that a 'EXP' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(exp|EXP)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.exp.gz.gpg" ]
      },

      "gpr-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a GPR file",
        "description": "This object exists to hold the filename pattern that a 'GPR' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(gpr|GPR)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.gpr.gz.gpg" ]
      },

      "py-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a PY file",
        "description": "This object exists to hold the filename pattern that a 'PY' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(py|PY)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.py.gz.gpg" ]
      },

      "sh-file-filename-pattern": {
        "type": "string",
        "title": "Filename pattern of a SH file",
        "description": "This object exists to hold the filename pattern that a 'SH' filetype_id would have, for it to be referenced elsewhere within this (or other) JSON schema.",
        "pattern": "^[^<>:;,?\"*|/]+\\.(sh|SH)(\\.(gz|zip|rar|arj|tar|7z|bz2))?(\\.gpg)?$",
        "examples": [ "my_file1.sh.gz.gpg" ]
      },

      "object_external_accession": {
        "type": "object",
        "title": "Object of external accession of the object",
        "description": "External accession node containing the object accession (i.e. unique identifier -  each following their respective formats) assigned by other archives (e.g. biosample, ena, ensembl...) and an optional label to add context to the reference.",
        "additionalProperties": false,
        "required": ["external_accession_curie"],
        "properties": {
          "external_accession_curie": {
            "type": "string",
            "title": "CURIE of the external accession",
            "description": "Unique identifier of an external, to EGA, object. It shall follow CURIE format (``prefix``:``accession``): prefix assigned to the archive (e.g. biosample - search for yours at identifiers.org) and the unique accession of the object (e.g. SAMEA7616999).",
            "allOf": [
              {
                "title": "General pattern of a CURIE",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
              }
            ],
            "examples": [ "biosample:SAMEA7616999", "arrayexpress:E-MEXP-1712", "biostudies:S-EPMC3314381"]
          },
          "accession_label": {
            "type": ["string", "number"],
            "title": "Label of the external accession",
            "description": "Optional label (e.g. 'taken from biosample temporarily') of the external accession, used to add extra information to the identifier.",
            "examples": [ "taken from biosample temporarily", "Ensembl's part of the accessions", "first", 2 ]
          }
        }
      },

      "sample-label-association": {
        "type": "object",
        "title": "Repeatable Sample-label node",
        "description": "The base node of a label-sample association. One form of basic identification of the sample (inherited from object_core_id - e.g. either the center name and alias or the accession) is required, as well as the label per se.",
        "required": ["label", "object_id"],
        "additionalProperties": false,
        "properties": {
          "label": { 
            "title": "Labelling dye used with the sample",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/array_label" 
          },
          "object_id": {
            "type": "object",
            "title": "Object's IDs block",
            "allOf": [
              {
                "title": "Inherited object_core_id object",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_core_id"
              },
              {
                "title": "Check that sample EGA ID (EGAN) pattern is correct",
                "properties": {
                  "ega_accession": {
                    "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/EGA-sample-id-pattern"
                  }
                }
              }
            ]       
          }
        }
      },

      "one-relationship-end": {
        "type": "object",
        "title": "Relationship's object (either source or target)",
        "description": "Node containing metadata (identifiers and the type of reference) of one of the ends of the relationship, whether it is the source or the target of the relationship.",
        "additionalProperties": false,
        "required": ["object_id", "object_type"],
        "properties": {
          "object_id": {
            "type": "object",
            "title": "Relationship's object's IDs block",
            "description": "Node containing the main identifiers of the relationship's object (e.g. alias, center_name...), inherited from the common definitions (#/definitions/object_core_id).",
            "allOf": [
              { 
                "title": "Inherited object_core_id object", 
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_core_id" 
              }
            ]
          },
          "object_type": {
            "type": "string",
            "title": "Type of the relationship's object",
            "description": "Type of the relationship's object, chosen from a list of CV (e.g. experiment, dataset, external_URL...). Both the source or target types can be: (1) the object tag of one of EGA's object (e.g. file, sample...); (2) an 'external_accession'; (3) or an 'external_URL'. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "enum": ["experiment", "study", "sample", "individual", "submission", "assay", "dataset", "analysis", "policy", "DAC", "external_accession", "external_URL"],
            "meta:enum": ["Contains information about the experimental design of the sequencing", "Information about the study", "Information about the used samples", "Information about the participants (i.e. humans) of the study", "Information about the submission actions", "Contains information about the specific assays (either sequencing or array assays) from the experiment", "Contains the collection of assay/analysis data files to be subject to controlled access", "Contains the analysis metadata and data files", "Contains information related to the Data Access Agreement (DAA) the dataset is subject to", "Contains information about the Data Access Committee (DAC)", "An external accession among the ones Entrez (NCBI's text search) contemplates (search for the terms here: https://www.ncbi.nlm.nih.gov/entrez/eutils/einfo.fcgi?)", "An external URL resource, of any type"],
            "examples": [ "sample" ]
          }
        },
        "allOf": [
          { 
            "title": "Check for object_id and object_type to match",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object-id-and-object-type-check" 
          }
        ]        
      },

      "subject_id": {
        "type": "string",
        "title": "Subject ID",
        "description": "A unique identifier (e.g. 'Donor-10031') for the subject the sample derives from, providing context for the sample to be better understood through its provenance. It **shall not** contain personal sensitive data, since it will be publicly displayed for queries and searches.",
        "minLength": 1,
        "examples": [ "Donor-10031", "ID001", "9001", "AX_Dli" ]
      },

      "biological_sex": {
        "type": "string",
        "title": "Biological sex of the individual",
        "meta:property_curie": "PATO:0000047",
        "description": "An organismal quality inhering in a bearer by virtue of the bearer's physical expression of sexual characteristics. In other words, the trait that determines the individual's (from which the sample derives) reproductive function: mainly male or female. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
        "enum": [ "male", "female", "hermaphrodite", "unknown" ],
        "meta:enum": [ "male__PATO:0000384: A biological sex quality inhering in an individual or a population whose sex organs contain only male gametes.", "female__PATO:0000383: A biological sex quality inhering in an individual or a population that only produces gametes that can be fertilised by male gametes.", "hermaphrodite__PATO:0001340: An organism having both male and female sexual characteristics and organs. A biological sex quality inhering in an organism or a population with both male and female sexual organs in one individual.", "unknown__: The biological sex is unknown." ],
        "examples": [ "male" ]
      },

      "experimental_condition_descriptor": {
        "type": "object",
        "title": "Experimental condition",
        "meta:property_curie": "XCO:0000000",
        "description": "A state of being, an external or environmental factor or a treatment observed or administered prior to or concurrent with an investigative procedure such as an assessment of a morphological or physiological state or property in a single individual or sample or in a group of individuals or samples, especially a state, factor or treatment which has the potential to influence the outcome of such an assessment. We highly recommend the usage of ontologies to describe experimental conditions (search at 'https://www.ebi.ac.uk/ols/ontologies/efo').",
        "additionalProperties": false,
        "required": ["experimental_condition_term"],
        "properties": {
          "experimental_condition_term": {
            "type": "string",
            "title": "Experimental condition term",
            "description": "Term that specifies the experimental condition (e.g. 'fibroadenoma').",
            "examples": [ "control", "fibroadenoma", "osteonecrosis" ]
          },
          "experimental_condition_curie": {
            "type": "string",
            "title": "Experimental condition curie",
            "description": "Curie (i.e. ontologised term - e.g. 'EFO:0001461') of the experimental condition. Search for the ontologized term at the [Ontology Lookup Service (OLS)](https://www.ebi.ac.uk/ols/index).",
            "examples": [ "EFO:0001461", "EFO:1000254", "EFO:0004259" ],
            "allOf": [
              {
                "title": "General pattern of a CURIE",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
              }
            ]
          },
          "experimental_condition_description": {
            "type": "string",
            "title": "Experimental condition description",
            "description": "Broad description of the experimental condition, providing further details and context over the ontologised term.",
            "examples": [
              "A control role is borne by a material in a process in which results obtained from an experimental sample and a control sample are compared.",
              "A benign tumor of the breast characterized by the presence of stromal and epithelial elements.", 
              "A none disease characterized by death of bone tissue due to a lack of blood supply."
            ]
          }
        }
      },

      "organism_descriptor": {
        "type": "object",
        "title": "Organism [OBI:0100026] descriptor block",
        "description": "This node describes the material entity the sample consists in. That is, an individual living system, such as animal, plant, bacteria or virus, that is capable of replicating or reproducing, growth and maintenance in the right environment. An organism may be unicellular or made up, like humans, of many billions of cells divided into specialized tissues and organs. This node is of special interest in case the provenance of the sample is not human (e.g. microbiota taken from a donor). Unless stated otherwise, given the nature of the EGA, it is expected to be of human provenance by default.",
        "additionalProperties": false,
        "required": ["taxon_id"],
        "properties": {
          "taxon_id": {
            "type": "string",
            "title": "Taxon identifier",
            "meta:property_curie": "APOLLO_SV:00000203",
            "description": "Taxonomy Identifier (e.g. '9606' for humans) curated by the NCBI Taxonomy (search for your sample's here: https://www.ncbi.nlm.nih.gov/taxonomy). You can find further details at 'https://www.uniprot.org/help/taxonomic_identifier'. This is appropriate for individual organisms and some environmental samples.",
            "pattern": "^[0-9]{1,7}$",
            "examples": [ "9606" ]
          },
          "scientific_name": {
            "type": "string",
            "title": "Biologic entity classification scientific name",
            "meta:property_curie": "NCIT:C43459",
            "description": "The name applied to a plant, animal, or other organism, according to the Codes of Nomenclature, consisting of a Genus and species (e.g. 'homo sapiens').",
            "examples": [ "homo sapiens" ]
          },
          "common_name": {
            "type": "string",
            "title": "Biologic entity classification common name",
            "meta:property_curie": "NCIT:C164690",
            "description": "Common name (e.g. 'human') used to designate a plant, animal or other organism, as opposed to the scientific name.",
            "examples": [ "human" ]
          }
        }
      },

      "schema_descriptor": {
        "type": "object",
        "title": "Schema descriptor",
        "description": "This node is intended to be used to describe the schemas and standards that a JSON document was based on. For instance, if a sample.json document was created to be validated against EGA.sample.json schema version 1.0.0, such information should be reflected in this block. This way, both a human and a machine can interpret and validate the JSON document efficiently, without the need of guessing versions.",
        "additionalProperties": false,
        "required": ["object_type", "described_by_schema_uri", "object_schema_version", "common_schema_version"],
        "properties": {
          "object_type": {
            "type": "string",
            "title": "Type of the object",
            "description": "Type of the object (e.g. 'sample') the JSON document describes.",
            "enum": [ "experiment", "study", "sample", "individual", "submission", "assay", "dataset", "analysis", "policy", "DAC", "object-set" ]
          },
          "described_by_schema_uri": {
            "type": "string",
            "title": "URI of the schema",
            "description": "URI of the schema (e.g. 'https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.sample.json') that describes the JSON document (e.g. 'my_sample.json')",
            "pattern": "^https://github\\.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA\\..+\\.json$",
            "examples": ["https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.sample.json"]
          },
          "object_schema_version": {
            "type": "string",
            "title": "Version of the object's schema",
            "description": "The version of the object's schema, the one specific for the object the JSON document corresponds to (e.g. 'EGA.sample.json'), not the common definitions schema's version (i.e. 'EGA.common-definitions.json').",
            "allOf": [
              {
                "title": "Check semantic versioning pattern",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/semantic-versioning-pattern"
              }
            ]
          },
          "common_schema_version": {
            "type": "string",
            "title": "Version of the common definition's schema",
            "description": "The version of the common definition's schema, the one containing all shared definitions (i.e. 'EGA.common-definitions.json'), not the one specific to the object described by the JSON document (e.g. 'EGA.sample.json').",
            "allOf": [
              {
                "title": "Check semantic versioning pattern",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/semantic-versioning-pattern"
              }
            ]
          }
        }
      },

      "semantic-versioning-pattern": {
        "type": "string",
        "title": "Semantic versioning pattern",
        "description": "This object exists to hold the pattern that semantic versioning has, for it to be referenced elsewhere within this (or other) JSON schema. For further details about semantic versioning check 'https://semver.org/'",
        "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$",
        "examples": [ "2.5.1" ]
      },
      
      "contact_details": {
        "type": "object",
        "title": "Contact details",
        "description": "An object to contain the required metadata to identify and reach an individual or institution. Used, for instance, to list who needs to be informed (1) in case of a erroneous submission (2) or in case access to a dataset is requested by a user.",
        "additionalProperties": false,
        "required": ["email_address"],
        "properties": {
          "individual_full_name": {
            "type": "string",
            "title": "Full name of an individual",
            "description": "A full set of all personal names by which an individual is known and that can be recited as a word-group, with the understanding that, taken together, they all relate to that one individual. In case there are several, separate them with semicolons (;).",
            "examples": [ "Wayne Jr., Bruce" ]
          },
          "institution_name": {
            "type": "string",
            "title": "Institution name",
            "description": "The full name of an institution the contact belongs to. In case there are several, separate them with semicolons (;).",
            "examples": [ "European Genome-phenome Archive (EGA)" ]
          },
          "email_address": {
            "type": "string",
            "title": "Email address",
            "description": "Current email address that would be used in case the contact needs to be reached. Its expected format is of a local-part (e.g. 'myname'), followed by an 'at' sign (i.e. '@') and the domain of the address (e.g. 'gmail.com' or 'ebi.ac.uk').",
            "pattern": "^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$",
            "examples": [ "myname@ebi.ac.uk" ]
          },
          "phone_number": {
            "type": "string",
            "title": "Phone number",
            "description": "Current phone number that would be used in case the contact needs to be reached. Theoretically would only be used in case the email address was not provided, does not exist or is unresponsive.",
            "pattern": "^\\+?\\(?[0-9]{1,4}\\)?[-\\s\\./0-9]+$",
            "examples": [ "+44 7427512529" ]
          }          
        },
        "anyOf": [
          { 
            "title": "Either the individual's name is required.",
            "required": ["individual_full_name"]
          },
          {
            "title": "Or the institution's name is required.",
            "required": ["institution_name"]
          }
        ]        
      },

      "study-design-keywords": {
        "type": "string",
        "title": "Enumeration of design keywords",
        "meta:property_curie": "EFO:0001426",
        "description": "An object containing the enumeration of multiple study-design keywords, to be inherited at their respective nodes. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
        "enum": ["RNA stability design", "binding site identification design", "case control design", "cell component comparison design", "cell cycle design", "cell type comparison design", "cellular modification design", "clinical history design", "compound treatment design", "cross sectional design", "development or differentiation design", "disease state design", "dose response design", "twin design", "genetic modification design", "genotype design", "growth condition design", "imprinting design", "injury design", "innate behavior design", "organism part comparison design", "organism status design", "pathogenicity design", "population based design", "sex design", "species design", "stimulus or stress design", "strain or line design", "time series design", "family based design", "genotyping design", "mobile element identification design", "operon identification design", "secreted protein identification design", "translational bias design", "transposable element identification design", "hardware variation design", "normalization testing design", "operator variation design", "optimization design", "quality control testing design", "reference design", "replicate design", "software variation design", "validation by real time PCR design", "validation by reverse transcription PCR design"],
        "meta:enum": ["RNA stability design__EFO:0001783", "binding site identification design__EFO:0004664", "case control design__EFO:0001427", "cell component comparison design__EFO:0001743", "cell cycle design__EFO:0001744", "cell type comparison design__EFO:0001745", "cellular modification design__EFO:0004666", "clinical history design__EFO:0001780", "compound treatment design__EFO:0001755", "cross sectional design__EFO:0001428", "development or differentiation design__EFO:0001746", "disease state design__EFO:0001756", "dose response design__EFO:0001757", "twin design__EFO:0001431", "genetic modification design__EFO:0001758", "genotype design__EFO:0001748", "growth condition design__EFO:0001759", "imprinting design__EFO:0001747", "injury design__EFO:0001760", "innate behavior design__EFO:0001749", "organism part comparison design__EFO:0001750", "organism status design__EFO:0001751", "pathogenicity design__EFO:0001761", "population based design__EFO:0001430", "sex design__EFO:0001752", "species design__EFO:0001753", "stimulus or stress design__EFO:0001762", "strain or line design__EFO:0001754", "time series design__EFO:0001779", "family based design__EFO_0001429", "genotyping design__EFO_0001784", "mobile element identification design__EFO_0005693", "operon identification design__EFO_0001785", "secreted protein identification design__EFO_0001786", "translational bias design__EFO_0001787", "transposable element identification design__EFO_0005692", "hardware variation design__EFO_0001767", "normalization testing design__EFO_0001771", "operator variation design__EFO_0001772", "optimization design__EFO_0001773", "quality control testing design__EFO_0001774", "reference design__EFO_0001775", "replicate design__EFO_0001776", "software variation design__EFO_0001778", "validation by real time PCR design__OBI_0001166", "validation by reverse transcription PCR design__OBI_0001162"],
        "examples": [ "RNA stability design" ]
      },

      "locus_identifier": {
        "type": "object",
        "title": "Locus identifier",
        "description": "Node to unambiguously identify loci [OGI:0000022]: the unique chromosomal location defining the position of an individual gene or DNA sequence. This node shall be used to precisely define: (1) the organism of said locus; (2) the gene and other genomic feature references in other accessions; (3) the genomic sequence per se, including its assembly and position. These details, in different combinations, shall allow identification of any genomic feature, such as SNPs (e.g. coordinates of a variant) or genes (e.g. PT53).",
        "required": ["organism_descriptor", "loci_descriptor"],
        "additionalProperties": false,
        "properties": {
          "organism_descriptor": {
            "title": "Organism descriptor",
            "description": "Node to identify the specific organism the locus belongs to.",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/organism_descriptor"
          },
          "loci_descriptor": {
            "type": "array",
            "title": "Loci context array",
            "description": "Array of locus context items. Multiple loci can be described in the array if the organism remains the same.",
            "additionalProperties": false,
            "uniqueItems": true,
            "minItems": 1,
            "items": {
              "type": "object",
              "title": "Locus context item",
              "description": "Node providing the context of the locus: its sequence, coordinates, encompassed genes...",
              "properties": {
                "gene_descriptor": {
                  "title": "Gene descriptor",
                  "description": "Node to identify the gene of the locus of interest.",
                  "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/gene_descriptor"
                },
                "genomic_sequence_descriptor": {
                  "title": "Genomic sequence descriptor",
                  "description": "Node to describe the sequence per se, instead of referencing it.",
                  "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/genomic_sequence_descriptor"
                },
                "locus_external_reference": {
                  "title": "External reference of the locus",
                  "description": "If the locus is NOT a gene (if so, use 'gene_descriptor'), and it is well represented (i.e. uniquely identifiable and with comprehensive detail) in another resource that is accessible and persistent, one can reference it here instead of providing all their details. For example, transcript TAF1-204 already contains all its locus information within its persistent record at Ensembl, identified by 'ensembl:ENST00000423759.6'.",
                  "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/object_external_accession",
                  "examples": ["ensembl:ENST00000423759.6"]
                },
                "locus_additional_description": {
                  "type": "string",
                  "title": "Additional description of the locus",
                  "description": "Optional free-text description of the locus to add any additional context.",
                  "minLength": 1,
                  "examples": ["Targeted locus number 1 out of 3 possible loci that our experimental procedure aimed at.", "The locus corresponds to a variant version of the defined gene, only existing in patients with X disease."]
                }
              },
              "anyOf": [
                {
                  "title": "Either the gene description is given",
                  "required": ["gene_descriptor"]
                },
                {
                  "title": "Or the genomic sequence context",
                  "required": ["genomic_sequence_descriptor"]
                },
                {
                  "title": "Or an external reference to the locus context",
                  "required": ["locus_external_reference"]
                }
              ]
            }            
          }
        }
      },

      "gene_descriptor": {
        "type": "object",
        "title": "Gene descriptor",
        "description": "Node to uniquely identify a gene [SO:0000704]: a region (or regions) that includes all of the sequence elements necessary to encode a functional transcript. A gene may include regulatory regions, transcribed regions and/or other functional sequence regions. For human genes, the standard is to use nomenclature provided by the HUGO Gene Nomenclature Committee (HGNC).",
        "required": ["gene_id_curie"],
        "additionalProperties": false,
        "properties": {
          "gene_symbol": {
            "type": "string",
            "title": "Gene Symbol",
            "meta:property_curie": "data:1026",
            "description": "The official gene symbol. It is typically derived from the gene name. This optional field exists to provide the common identifier of the gene. There are several resources to search for a gene of interest, although we recommend [NCBI's service](https://www.ncbi.nlm.nih.gov/gene). For example: (1) in the case of human genes, the symbol follows [HGNC](https://www.genenames.org/)'s nomenclature; (2) while in the case of mice genes they are provided by [MGI](http://www.informatics.jax.org/).",
            "examples": ["TAF1", "TP53", "BRAF", "16S"]
          },
          "gene_id_curie": {
            "type": "string",
            "title": "Gene CURIE ID",
            "meta:property_curie": "data:2295",
            "description": "A unique (and typically persistent) identifier of a gene in a database, that is (typically) different to the gene name/symbol (e.g. HGNC:11535 for gene TAF1). The identifier has to follow CURIE format. Additionally, there are 2 types of allowed databases to reference: NCBIGene and HGNC. Other archives' accessions (e.g. ensembl:ENSDARG00000035330) can be cross referenced with NCBIGene to obtain its gene ID (e.g. ncbigene:555452).",            
            "allOf": [
              {
                "title": "General pattern of a CURIE",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
              }
            ],
            "oneOf": [
              {
                "title": "NCBI Gene pattern (e.g. 'NCBIGene:100010')",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_ncbi_gene_identifier_pattern"
              },
              {
                "title": "NCBI Gene pattern (e.g. 'NCBIGene:100010')",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_hgnc_identifier_pattern"
              }
            ],
            "examples": ["HGNC:11535", "hgnc:11998", "HGNC:1097", "ncbigene:100010", "ncbigene:6872"]
          }
        }
      },

      "ncbi_assembly_descriptor": {
        "type": "object",
        "title": "NCBI's Assembly descriptor",
        "meta:property_curie": "topic:0196",
        "description": "Node describing a sequence assembly referenced in [NCBI's Assembly database](https://www.ncbi.nlm.nih.gov/assembly). Assembly is a database providing information on the structure of assembled genomes, assembly names and other meta-data, statistical reports, and links to genomic sequence data. An assembly is defined as the set of chromosomes, unlocalized and unplaced (sometimes called 'random') and alternate sequences used to represent an organism's genome. Assemblies are constructed from 1 or more assembly units.",
        "additionalProperties": false,
        "properties": {
          "assembly_name": {
            "type": "string",
            "title": "Assembly common name",
            "meta:property_curie": "OBI:0001948",
            "description": "A free-text common name (e.g. 'GRCh38') that is used to denote the sequence assembly.",
            "minLength": 1,
            "examples": [ "GRCh38.p14", "GRCh38", "GRCh37.p13", "GRCh37" ]
          },
          "ncbi_assembly_accession": {
            "type": "string",
            "title": "NCBI Assembly accession",
            "description": "Assembly's identifier (e.g. GCF_000001405.26) of the assembly. For example, the assembly accession for the GenBank version of the public human reference assembly (GRCh38.p14) is GCA_000001405.29. See further details here: https://www.ncbi.nlm.nih.gov/assembly/model/.",
            "allOf": [
              {
                "title": "Assembly's CURIE pattern",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_ncbi_assembly_pattern"
              }
            ],
            "examples": ["assembly:GCF_000001405.26", "assembly:GCA_000001405.1", "assembly:GCF_000005845.2" ]
          },
          "assembly_unit_name": {
            "type": "string",
            "title": "Assembly unit common name",
            "meta:property_curie": "OBI:0001948",
            "description": "A free-text common name (e.g. 'chr17') that is used to denote the sequence assembly unit.",
            "minLength": 1,
            "examples": [ "Chromosome 2", "MT", "chr17", "chr20", "18" ]
          },
          "ncbi_assembly_unit_accession": {
            "type": "string",
            "title": "NCBI Assembly unit accession",
            "description": "NCBI's identifier (e.g. ) of the assembly unit. An assembly unit is defined as the collection of sequences used to define discrete parts of an assembly. Commonly assembly units are entire chromosomes (e.g. Chromosome 1 of human genome), scaffolds or different types of sequences (e.g. Mitochondrial DNA). For example, GenBank's accession: (1) for the assembly unit of the human chromosome 1 is [NC_000001.11](https://www.ncbi.nlm.nih.gov/nuccore/NC_000001.11) (for the human reference assembly GRCh38.p14); (2) and for the complete mitochondrion genome of a human it is [NC_012920.1](https://www.ncbi.nlm.nih.gov/nuccore/NC_012920.1). See further details here: https://www.ncbi.nlm.nih.gov/assembly/model/.",
            "allOf": [
              {
                "title": "RefSeq accession CURIE",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_refseq_pattern"
              }
            ],
            "examples": ["refseq:NC_000001.11", "refseq:NC_012920.1"]
          }
        },
        "anyOf": [
          {
            "title": "Or the Assembly accession is required",
            "required": ["ncbi_assembly_accession"]
          },
          {
            "title": "Or the Assembly unit accession is required",
            "required": ["ncbi_assembly_unit_accession"]
          }
        ]
        
      },

      "genomic_sequence_descriptor": {
        "type": "object",
        "title": "Genomic sequence descriptor",
        "meta:property_curie": "GENO:0000960",
        "description": "Node used to describe with sufficient detail a genomic sequence (e.g. Human Chromosome X: 71366222-71532374 forward strand), defined as a biological sequence that is of genomic origin (i.e. carries sequence from the genome of a cell or organism).",
        "additionalProperties": false,
        "properties": {
          "assembly_descriptor": {
            "title": "Assembly descriptor",
            "meta:property_curie": "topic:0196",
            "description": "Node to identify the assembly of the locus of interest.",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/ncbi_assembly_descriptor"
          },
          "sequence_coordinates": {
            "title": "DNA Sequence coordinates",
            "description": "Node to define que specific sequence coordinates of the genomic feature within the assembly.",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/sequence_coordinates"
          },
          "dna_sequence_strand": {
            "title": "DNA Sequence strand",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/dna_sequence_strand"
          },
          "nucleic_acid_sequence": {
            "title": "Nucleic acid sequence of the locus",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/nucleic_acid_sequence"
          }
        },
        "anyOf": [
          {
            "title": "Either the full position context is given",
            "required": ["assembly_descriptor", "sequence_coordinates", "dna_sequence_strand"]
          },
          {
            "title": "Or at least the sequence itself is given",
            "required": ["nucleic_acid_sequence"]
          }
        ]
      },

      "sequence_coordinates": {
        "type": "object",
        "title": "Sequence coordinates",
        "meta:property_curie": "data:2012",
        "description": "A position in a map (for example a genetic map), either a single position (e.g. 71366222) or a region interval (e.g. 71366222-71532374). Used to define coordinates within an assembly unit.",
        "additionalProperties": false,
        "properties": {
          "single_position": {
            "title": "Single position",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/single_sequence_position"
          },
          "sequence_interval": {
            "type": "object",
            "title": "Sequence interval",
            "meta:property_curie": "GENO:0000902",
            "description": "The location of a sequence feature in a genome, defined by its start (e.g. 71366222) and end (e.g. 71532374) position on some reference genomic coordinate system. Positions are always represented by contiguous spans using interbase coordinates or coordinate ranges. Both coordinates are inclusive: the sequence bounds are included in the described genomic feature. In other words, if the sequence interval is 71366222-71532374, both 71366222 and 71532374 coordinates are included in the feature.",
            "required": ["start", "end"],
            "additionalProperties": false,
            "properties": {
              "start": {
                "title": "Start position",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/single_sequence_position"
              },
              "end": {
                "title": "End position",
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/single_sequence_position"
              }
            }
          }
        },
        "anyOf": [
          {
            "title": "Either a single position is given",
            "required": ["single_position"]
          },
          {
            "title": "Or the whole sequence interval",
            "required": ["sequence_interval"]
          }
        ]
      },

      "dna_sequence_strand": {
        "type": "string",
        "title": "DNA Sequence strand",
        "description": "DNA sequence is double-stranded. By convention, for a reference chromosome, one whole strand is designated the 'forward strand' and the other the 'reverse strand'. This designation is arbitrary and sometimes the terms 'plus strand' and 'minus strand', respectively, are used instead. A genomic feature can live on a DNA strand in one of two orientations. For instance, a gene is said to have a coding strand (also known as its 'sense strand'), and a template strand (also known as its 'antisense strand'), which can be forward or reverse strands depending on which contain the nucleotide sequence the RNA polymerase reads to create its RNA product. Annotations such as Ensembl and UCSC are concerned with the coding sequences of genes, so when they say a gene is on the forward strand, it means the gene's coding sequence is on the forward strand. To follow through again, that means that during transcription of this forward-strand gene, the gene's template sequence is read from the reverse strand, producing an mRNA that matches the sequence on the forward strand. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
        "enum": ["forward", "reverse"],
        "meta:enum": ["Forward strand [ENSGLOSSARY:0000369]: DNA strand arbitrary defined as the strand with its 5' end at the tip of the short chromosome arm (p). If a gene is forward-stranded, its sense (sequence matching cDNA) is on the forward strand. Forward strand is reverse complementary to the reverse strand.", "Reverse strand [ENSGLOSSARY:0000370]: DNA strand arbitrary defined as the strand with its 5' end at the tip of the long chromosome arm (q). If a gene is reverse-stranded, its sense (sequence matching cDNA) is on the reverse strand. Reverse strand is reverse complementary to the forward strand."]
      },

      "nucleic_acid_sequence": {
        "type": "string",
        "title": "Nucleic acid sequence",
        "meta:property_curie": "data:2977",
        "description": "Sequence of characters representing a specific nucleic (i.e. molecular species - e.g. Adenine) or groupings of these (through ambiguity codes), using [one-letter IUPAC abbreviations](https://en.wikipedia.org/wiki/International_Union_of_Pure_and_Applied_Chemistry#Amino_acid_and_nucleotide_base_codes).",
        "pattern": "^([\\.-]*[ACGTURYKMSWBDHVNX]+[\\.-]*)+$",
        "examples": ["ACTGCCG", "CTGCGCGCGCT", "KM-AGT-X-N"]        
      },

      "single_sequence_position": {
        "type": "number",
        "title": "Single sequence position",
        "description": "A single 1-based (first base of the assembly unit is 1, not 0) sequence coordinate, inclusive. It can be used to describe the start or end coordinates of a sequence interval, or directly a single coordinate within a sequence.",
        "minInclusive": 1,
        "examples": [71366222, 36592394, 1]
      },

      "curie_general_pattern": {
        "type": "string",
        "title": "Compact URI (CURIE) pattern",
        "description": "A [W3C Compact URI](https://www.w3.org/TR/curie/) formatted string. A CURIE string has the structure ``prefix``:``reference``, as defined by the W3C syntax. Even though we do not restrict prefixes, we recommend that the term used as ``prefix`` is uniformely resolved. In other words, it is better to use prefixes (e.g. 'ensembl') from identifiers.org.",
        "pattern": "^\\w[^:]*:.+$",
        "examples": ["ensembl:ENSG00000139618", "HGNC:11535", "data:1026", "EFO:0003815"]
      },

      "curie_refseq_pattern": {
        "type": "string",
        "title": "RefSeq accessions' [data:1098] CURIE pattern",
        "description": "The Reference Sequence (RefSeq) CURIEs take the structure of ``refseq``:``accession``. [RefSeq accessions](https://registry.identifiers.org/registry/refseq) [data:1098] have special prefixes (e.g. 'NM_' for protein-coding transcripts - mRNA) based on the category of the object. The accession can also have a version attached as a suffix (e.g. '.23'). Their records are integrated into [NCBI's resources](https://www.ncbi.nlm.nih.gov/refseq/) including the Nucleotide, Protein, and BLAST databases and can be easily identified by the keyword 'RefSeq' and by their distinct accession prefixes that define their type (see further details at [doi:10.1093/nar/gkv1189](https://academic.oup.com/nar/article/44/D1/D733/2502674).",
        "pattern": "^(RefSeq|refseq):",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
          }
        ],        
        "oneOf": [
          {
            "title": "NC - Molecule type: DNA",
            "Description": "Use context: Chromosomes; Linkage Groups",
            "pattern": "^[^:]+:NC_\\d+(\\.\\d+)?$"
          },
          {
            "title": "AC - Molecule type: DNA",
            "Description": "Use context: Chromosomes; Linkage Groups",
            "pattern": "^[^:]+:AC_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NZ - Molecule type: DNA",
            "Description": "Use context: Chromosomes; Scaffolds; Used predominantly for prokaryotic genomes.",
            "pattern": "^[^:]+:NZ_[A-Z]{2,4}\\d+(\\.\\d+)?$"
          },
          {
            "title": "NT - Molecule type: DNA",
            "Description": "Use context: Scaffolds",
            "pattern": "^[^:]+:NT_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NW - Molecule type: DNA",
            "Description": "Use context: Scaffolds",
            "pattern": "^[^:]+:NW_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NG - Molecule type: DNA",
            "Description": "Use context: Genomic regions; A genomic region record may represent a single or multiple genetic loci (e.g. rRNA targeted locus, RefSeqGene, non-transcribed pseudogene)",
            "pattern": "^[^:]+:NG_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NM - Molecule type: mRNA",
            "Description": "Use context: protein-coding transcripts",
            "pattern": "^[^:]+:NM_\\d+(\\.\\d+)?$"
          },
          {
            "title": "XM - Molecule type: mRNA",
            "Description": "Use context: protein-coding transcripts",
            "pattern": "^[^:]+:XM_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NR - Molecule type: RNA",
            "Description": "Use context: non-protein-coding transcripts including lncRNAs, structural RNAs, transcribed pseudogenes, and transcripts with unlikely protein-coding potential from protein-coding genes",
            "pattern": "^[^:]+:NR_\\d+(\\.\\d+)?$"
          },
          {
            "title": "XR - Molecule type: RNA",
            "Description": "Use context: non-protein-coding transcripts, as above",
            "pattern": "^[^:]+:XR_\\d+(\\.\\d+)?$"
          },
          {
            "title": "NP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on NM_ transcript accessions or annotated on genomic molecules without an instantiated transcript (e.g. some mitochondrial genomes, viral genomes, and reference bacterial genomes",
            "pattern": "^[^:]+:NP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "AP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on AC_ genomic accessions or annotated on genomic molecules without an instantiated transcript record",
            "pattern": "^[^:]+:AP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "XP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on XM_ transcript accessions or annotated on genomic molecules without an instantiated transcript record",
            "pattern": "^[^:]+:XP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "YP - Molecule type: protein",
            "Description": "Use context: Proteins annotated on genomic molecules without an instantiated transcript record",
            "pattern": "^[^:]+:YP_\\d+(\\.\\d+)?$"
          },
          {
            "title": "WP - Molecule type: protein",
            "Description": "Use context: Proteins that are non-redundant across multiple strains and species. A single protein of this type may be annotated on more than one prokaryotic genome",
            "pattern": "^[^:]+:WP_\\d+(\\.\\d+)?$"
          }
        ],
        "examples": ["NC_001502.1", "NZ_AP024564.1", "NG_046887.1", "NP_001006685.1", "NZ_AMGO01000001.1"]
      },

      "curie_hgnc_symbol_pattern": {
        "type": "string",
        "title": "HGNC symbol CURIE pattern",
        "description": "The HGNC (HUGO Gene Nomenclature Committee) provides an approved gene name and symbol (short-form abbreviation) for each known human gene. All approved symbols are stored in the HGNC database, and each symbol is unique. This collection refers to records using the HGNC symbol. See further details here: https://registry.identifiers.org/registry/hgnc.symbol",
        "pattern": "hgnc.symbol:[A-Za-z-0-9_]+(\\@)?$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
          }
        ],
        "examples": ["hgnc.symbol:DAPK1", "hgnc.symbol:TAF1"]
      },

      "curie_hgnc_identifier_pattern": {
        "type": "string",
        "title": "HGNC identifier CURIE pattern",
        "description": "The HGNC (HUGO Gene Nomenclature Committee) provides an approved gene name and symbol (short-form abbreviation) for each known human gene. All approved symbols are stored in the HGNC database, and each symbol is unique. HGNC identifiers refer to records in the HGNC symbol database. See further details here: https://registry.identifiers.org/registry/hgnc",
        "pattern": "^((HGNC|hgnc):)?\\d{1,5}$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
          }
        ],
        "examples": ["hgnc:2674", "HGNC:11535"]
      },

      "curie_ncbi_gene_identifier_pattern": {
        "type": "string",
        "title": "NCBI Gene identifier CURIE pattern",
        "description": "Entrez Gene is the NCBI's database for gene-specific information, focusing on completely sequenced genomes, those with an active research community to contribute gene-specific information, or those that are scheduled for intense sequence analysis. See further details here: https://registry.identifiers.org/registry/ncbigene",
        "pattern": "^ncbigene:\\d+$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
          }
        ],
        "examples": ["ncbigene:100010", "ncbigene:270627"]
      },

      "curie_ncbi_assembly_pattern": {
        "type": "string",
        "title": "NCBI Assembly CURIE pattern",
        "description": "The assembly accession starts with a three letter prefix, GCA for GenBank assemblies and GCF for RefSeq assemblies. This is followed by an underscore and 9 digits (e.g. '_000001405'). A version (e.g. '.26') is then added to the accession. See further details here: https://registry.identifiers.org/registry/assembly",
        "pattern": "^assembly:(GCF|GCA)_\\d+(\\.\\d+)?$",
        "allOf": [
          {
            "title": "General CURIE pattern",
            "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/curie_general_pattern"
          }
        ],
        "examples": ["assembly:GCF_000001405.26", "assembly:GCA_000001405.1", "assembly:GCF_000005845.2" ]
      },

      "assay_technology_descriptor": {
        "type": "object",
        "title": "Assay technology",
        "meta:property_curie": "EFO:0000548",
        "description": "Metadata of the assay instrument (e.g. sequencer Illumina NextSeq 500) used to obtain the raw data (e.g. sequence files) of an assay.",
        "required": ["assay_instrument", "assay_instrument_platform"],
        "additionalProperties": false,
        "properties": {
          "assay_instrument": {
            "type": "string",
            "title": "Assay's instrument category",
            "meta:property_curie": "EFO:0002773",
            "description": "The general categories (e.g. sequencers) in which assay instruments are categorized. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "enum": [ "array", "sequencer" ],
            "meta:enum": ["[Array instrument [EFO:0002698]](http://www.ebi.ac.uk/efo/EFO_0002698), an instrument which consists of nucleic acid or protein molecules bound to a substrate", "[Sequencer instrument [EFO:0003739]](http://www.ebi.ac.uk/efo/EFO_0003739), an instrument that determines the order of nucleic acids in their sequences."]
          },
          "assay_instrument_platform": {
            "type": "string",
            "title": "Assay instrument label",
            "description": "Label (e.g. 'Illumina HiSeq 2500'), chosen from a list of controlled vocabulary (CV), of the technology used at the experiment. If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
            "examples": ["Illumina HiSeq 2500", "[HuGene-1_1-st] Affymetrix Human Gene 1.1 ST Array [probe set (exon) version]", "DNBSEQ-G400 FAST"]
          }
        },
        "oneOf": [
          {
            "title": "Asserting array technology controlled vocabulary (CV)",
            "properties": {
              "assay_instrument": {
                "enum": [ "array" ]
              },
              "assay_instrument_platform": {
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/controlled_vocabulary_schemas/EGA.cv.instrument_platforms_array.json"
              }
            }              
          },
          {
            "title": "Asserting sequencer technology controlled vocabulary (CV)",
            "properties": {
              "assay_instrument": {
                "enum": [ "sequencer" ]
              },
              "assay_instrument_platform": {
                "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/controlled_vocabulary_schemas/EGA.cv.instrument_platforms_sequencing.json"
              }
            }              
          }
        ]
      },

      "library_layout": {
        "type": "string",
        "title": "Sequencing library layout",
        "description": "Whether the sequenced reads are paired or single. In other words, if the sequencing assay is paired- (OBI:0001850) or single-end (OBI:0002485). Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
        "enum": ["paired-end", "single-end"],
        "meta:enum": ["Paired-end [OBI:0001850]: A transcription profiling assay that determines transcripts, gene structures, and gene expressions using Paired-End Tags and sequencing technology. Allows to sequence both ends of a fragment and generate high-quality, alignable sequence data. Paired-end sequencing facilitates detection of genomic rearrangements and repetitive sequence elements, as well as gene fusions and novel transcripts.", "Single-end [OBI:0002485]: A sequencing assay that incorporates single-end reads and sequencing technology to determine transcripts, gene structures, and gene expressions. Single-read sequencing involves sequencing DNA from only one end."]
      },

      "spot_descriptor": {
        "type": "array",
        "title": "Spot descriptor",
        "description": "The 'spot_descriptor' specifies how to decode the individual reads of interest from the monolithic spot sequence. The spot descriptor contains aspects of the experimental design, platform, and processing information. There will be two methods of specification: one will be an index into a table of typical decodings, the other being an exact specification. This construct is needed for loading data and for interpreting the loaded sequencing assays. It can be omitted if the loader can infer read layout (from multiple input files or from one input files).",
        "minItems": 1,
        "additionalProperties": false,
        "items": {
          "type": "object",
          "title": "Spot decode spec",
          "description": "",
          "additionalProperties": false,
          "required": ["read_specs"],
          "properties": {
            "spot_length": {
              "type": "integer",
              "title": "Spot length",
              "description": "Number of base/color calls, cycles, or flows per spot (raw sequence length or flow length including all application and technical tags and mate pairs, but not including gap lengths). This value will be platform dependent, library dependent, and possibly run dependent. Variable length platforms will still have a constant flow/cycle length.",
              "minInclusive": 0
            },
            "read_specs": {
              "type": "array",
              "title": "Read specs",
              "description": "",
              "minItems": 1,
              "items": {
                "type": "object",
                "title": "Read spec",
                "description": "",
                "additionalProperties": false,
                "required": [""],
                "properties": {
                  "read_index": {
                    "type": "string",
                    "title": "Read index",
                    "description": "READ_INDEX starts at 0 and is incrementally increased for each sequential READ_SPEC within a SPOT_DECODE_SPEC."      
                  },
                "read_label": {
                  "type": "string",
                  "title": "Read label",
                  "description": "READ_LABEL is a name for this tag, and can be used to on output to determine read name, for example F or R."    
                },
                "read_class": {
                  "type": "string",
                  "title": "Read class",
                  "description": "",
                  "enum": ["Application Read", "Technical Read" ],
                  "meta:enum": ["", ""]
                },
                "read_type": {
                  "type": "string",
                  "title": "Read type",
                  "description": "",
                  "enum": ["Forward", "Reverse", "Adapter", "Primer", "Linker", "BarCode", "Other"],
                  "meta:enum": ["", "", "", "", "", "", ""]
                },
                "relative_order": {
                  "type": "object",
                  "title": "Relative order",
                  "description": "The read is located beginning at the offset or cycle relative to another read. This choice is appropriate for example when specifying a read that follows a variable length expected sequence(s).",
                  "additionalProperties": false,
                  "required": [""],        
                  "properties": {
                    "follows_read_index": {
                      "type": "integer",
                      "title": "Follows read index",
                      "description": "Specify the read index that precedes this read.",
                      "minInclusive": 0      
                    },
                    "precedes_read_index": {
                      "type": "integer",
                      "title": "",
                      "description": "Specify the read index that follows this read.",
                      "minInclusive": 0
                    }
                  }                    
                },
                "base_coord": {
                  "type": "integer",
                  "title": "Base coord",
                  "description": "The location of the read start in terms of base count (1 is beginning of spot)"
                },
                "expected_basecall_table": {
                  "type": "object",
                  "title": "Expected basecall table",
                  "description": "A set of choices of expected basecalls for a current read. Read will be zero-length if none is found.",    
                  "additionalProperties": false,
                  "required": ["basecalls"],        
                  "properties": {
                    "default_length": {
                      "type": "integer",
                      "title": "Default length",
                      "description": "Specify whether the spot should have a default length for this tag if the expected base cannot be matched.",
                      "minInclusive": 0
                    },
                    "base_coord": {
                      "type": "integer",
                      "title": "Base coord",
                      "description": "Specify an optional starting point for tag (base offset from 1).",   
                      "minInclusive": 0
                    },
                    "basecalls": {
                      "type": "array",
                      "title": "Basecalls array",
                      "description": "Element's body contains a basecall, attribute provide description of this read meaning as well as matching rules.",
                      "minItems": 1,
                      "items": {
                        "type": "object",
                        "title": "Basecall",
                        "description": "",
                        "additionalProperties": false,
                        "required": [""],              
                        "properties": {
                          "read_group_tag": {
                            "type": "string",
                            "title": "Read group tag",
                            "description": "When match occurs, the read will be tagged with this group membership."              
                          },
                          "min_match": {
                            "type": "integer",
                            "title": "Min match",
                            "description": "Minimum number of matches to trigger identification.",   
                            "minInclusive": 0            
                          },
                          "max_mismatch": {
                            "type": "integer",
                            "title": "Max mismatch",
                            "description": "Maximum number of mismatches",   
                            "minInclusive": 0         
                          },
                          "match_edge": {
                            "type": "string",
                            "title": "Match edge",
                            "description": "Where the match should occur. Changes the rules on how min_match and max_mismatch are counted.",
                            "enum": ["full", "start", "end"],
                            "meta:enum": ["Only @max_mismatch influences matching process", "Both matches and mismatches are counted. When @max_mismatch is exceeded - it is not a match. When @min_match is reached - match is declared.", "Both matches and mismatches are counted. When @max_mismatch is exceeded - it is not a match. When @min_match is reached - match is declared."]   
                          }
                        }    
                      }
                    }
                    }
                  } 
                }
              }
            }
          }                    
        }        
      },
      
      "type_of_data": {
        "type": "string",
        "title": "Type of data",
        "meta:property_curie": "IAO:0000100",
        "description": "Type of data an experiment or analysis can produce (i.e. output), or an analysis can use as input. For example, in a sequencing experiment the output data would be 'genomic data', while that same type of data could be the input type of data for an analysis, which would then output 'processed sequencing data'. Term chosen from a list of controlled vocabulary (CV). If you cannot find your term in the CV list, please create an issue at our [metadata GitHub repository](https://github.com/EbiEga/ega-metadata-schema) proposing its addition.",
        "enum": ["gene list", "genomic data", "metagenomic data", "metatranscriptomic data", "synthetic DNA data", "transcriptomic data", "viral RNA data", "processed sequencing data", "processed array data"],
        "meta:enum": ["gene list__OBI_0000118", "genomic data__EFO_0004600", "metagenomic data__EFO_0004602", "metatranscriptomic data__EFO_0004603", "synthetic DNA data__EFO_0004604", "transcriptomic data__EFO_0004601", "viral RNA data__EFO_0004605", "processed sequencing data__EFO:0004663: raw sequencing data (e.g. FastQ files) were processed in any way (e.g. normalization, noise reduction, alignment...) and transformed into processed genotype data files [EFO:0004663].", "processed array data__EFO:0004096: raw array data (e.g. CEL files) were processed in any way (e.g. normalization, noise reduction...) and transformed into processed array data files [EFO:0004096]."]
      },

      "reference_alignment_details": {
        "type": "array",
        "title": "Reference assembly and sequence details",
        "description": "Node containing the information of the reference assembly that was used to obtain the sequence alignment. For example, processing raw sequence FastQ files aligning it to a reference sequence (e.g. human Chromosome X of GRCh38's assembly), obtaining aligned sequences (e.g. BAM format). In this array one can list the used assembly (e.g. GRCh38.p14), the used assembly units (e.g. refseq:NC_000001.11), or a combination of both. In order to ease the interpretation of the data, it is important to notice that the field 'assembly_unit_name' shall correspond to how the Reference Sequence is labelled in submission file(s) (e.g. '1' for chromosome 1). This name is equivalent to the SQ label (the reference sequence dictionary) in BAM (see [documentation for v1](https://samtools.github.io/hts-specs/SAMv1.pdf)) and optional when submitted file uses INSDC accession.version",
        "additionalProperties": false,
        "uniqueItems": true,
        "minItems": 1,
        "items": {
          "title": "One item containing metadata of the assembly or assembly unit.",
          "$ref": "https://github.com/EbiEga/ega-metadata-schema/tree/main/schemas/EGA.common-definitions.json#/definitions/ncbi_assembly_descriptor"
        }
      },

      "uberon-anatomical-entity": {
        "type": "string",
        "title": "UBERON's Anatomical entity",
        "meta:property_curie": "UBERON:0001062",
        "description": "Biological entity that is either an individual member of a biological species or constitutes the structural organization of an individual member of a biological species. Term shall be one of UBERON's ontologized terms beneath anatomical entity [UBERON:0001062]. Search for yours at: http://purl.obolibrary.org/obo/UBERON_0001062. It can be used to describe a sampling site or the morphological site of a disease, for example. #! To be used as an ontology validation node in the future.",
        "examples": ["liver", "gut wall", "nasal cavity" ]
      },

      "r-type-referenced_by": {
        "type": "object",
        "title": "Relationship type: referenced_by",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "referenced_by"
          } 
        }
      },

      "r-type-grouped_with": {
        "type": "object",
        "title": "Relationship type: grouped_with",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "grouped_with"
          } 
        }
      },

      "r-type-member_of": {
        "type": "object",
        "title": "Relationship type: member_of",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "member_of"
          } 
        }
      },

      "r-type-is_after": {
        "type": "object",
        "title": "Relationship type: is_after",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "is_after"
          } 
        }
      },

      "r-type-child_of": {
        "type": "object",
        "title": "Relationship type: child_of",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "child_of"
          } 
        }
      },

      "r-type-develops_from": {
        "type": "object",
        "title": "Relationship type: develops_from",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "develops_from"
          } 
        }
      },

      "r-type-family_relationship_with": {
        "type": "object",
        "title": "Relationship type: family_relationship_with",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "family_relationship_with"
          } 
        }
      },

      "r-type-same_as": {
        "type": "object",
        "title": "Relationship type: same_as",
        "description": "Node to be used as a relationship type for relationship contraints.",
        "properties": {
          "r_type": {
            "const": "same_as"
          } 
        }
      },

      "r-target-policy": {
        "type": "object",
        "title": "Relationship target: Policy",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "policy" 
              }
            }
          } 
        }
      },

      "r-source-policy": {
        "type": "object",
        "title": "Relationship source: Policy",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "policy" 
              }
            }
          } 
        }
      },

      "r-target-DAC": {
        "type": "object",
        "title": "Relationship target: DAC",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "DAC" 
              }
            }
          } 
        }
      },

      "r-source-DAC": {
        "type": "object",
        "title": "Relationship source: DAC",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "DAC" 
              }
            }
          } 
        }
      },

      "r-target-dataset": {
        "type": "object",
        "title": "Relationship target: dataset",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "dataset" 
              }
            }
          } 
        }
      },

      "r-source-dataset": {
        "type": "object",
        "title": "Relationship source: dataset",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "dataset" 
              }
            }
          } 
        }
      },

      "r-target-analysis": {
        "type": "object",
        "title": "Relationship target: analysis",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "analysis" 
              }
            }
          } 
        }
      },

      "r-source-analysis": {
        "type": "object",
        "title": "Relationship source: analysis",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "analysis" 
              }
            }
          } 
        }
      },

      "r-target-sample": {
        "type": "object",
        "title": "Relationship target: sample",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "sample" 
              }
            }
          } 
        }
      },

      "r-source-sample": {
        "type": "object",
        "title": "Relationship source: sample",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "sample" 
              }
            }
          } 
        }
      },

      "r-target-experiment": {
        "type": "object",
        "title": "Relationship target: experiment",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "experiment" 
              }
            }
          } 
        }
      },

      "r-source-experiment": {
        "type": "object",
        "title": "Relationship source: experiment",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "experiment" 
              }
            }
          } 
        }
      },

      "r-source-individual": {
        "type": "object",
        "title": "Relationship source: individual",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "individual" 
              }
            }
          } 
        }
      },

      "r-target-individual": {
        "type": "object",
        "title": "Relationship target: individual",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "individual" 
              }
            }
          } 
        }
      },

      "r-source-submission": {
        "type": "object",
        "title": "Relationship source: submission",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "submission" 
              }
            }
          } 
        }
      },

      "r-target-submission": {
        "type": "object",
        "title": "Relationship target: submission",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "submission" 
              }
            }
          } 
        }
      },

      "r-source-external_accession": {
        "type": "object",
        "title": "Relationship source: external_accession",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "external_accession" 
              }
            }
          } 
        }
      },

      "r-target-external_accession": {
        "type": "object",
        "title": "Relationship target: external_accession",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "external_accession" 
              }
            }
          } 
        }
      },

      "r-source-external_URL": {
        "type": "object",
        "title": "Relationship source: external_URL",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "external_URL" 
              }
            }
          } 
        }
      },

      "r-target-external_URL": {
        "type": "object",
        "title": "Relationship target: external_URL",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "external_URL" 
              }
            }
          } 
        }
      },

      "r-source-study": {
        "type": "object",
        "title": "Relationship source: study",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "study" 
              }
            }
          } 
        }
      },

      "r-target-study": {
        "type": "object",
        "title": "Relationship target: study",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "study" 
              }
            }
          } 
        }
      },

      "r-target-assay": {
        "type": "object",
        "title": "Relationship target: assay",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_target": {
            "properties": {
              "object_type": {
                "const": "assay" 
              }
            }
          } 
        }
      },

      "r-source-assay": {
        "type": "object",
        "title": "Relationship source: assay",
        "description": "Node to be used as an object type for relationship contraints.",
        "properties": {
          "r_source": {
            "properties": {
              "object_type": {
                "const": "assay" 
              }
            }
          } 
        }
      }
    }
}