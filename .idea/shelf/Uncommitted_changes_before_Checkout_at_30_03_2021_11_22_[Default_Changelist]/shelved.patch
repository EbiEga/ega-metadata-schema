Index: Star2xml/configuration_files/xml_schema.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This is the YAML schema file containing the hierarchy of elements and their characteristics\r\n# represented within the submission XML file.\r\n\r\n# -------- #\r\n# Miscellaneous information\r\n# -------- #\r\n\r\ntool_info:  # Contains info about the conversion tool and this schema file.\r\n    # Version (string: !!str): defines the tool version for which this YAML was created.\r\n    version: !!str 1.0\r\n    # update_date (ISO 8691 format): defines the date of the last official update for this file.\r\n    update_date: 2021-03-16\r\n\r\n# Contains info about where the XML schemas instances are. This information will be used\r\n#   when creating each object's XML.\r\nXML_schemas_info:\r\n    # Information regardig the XSD download if needed:\r\n    file_extension: \"xsd\"\r\n    ftp_server: \"ftp.ebi.ac.uk\"\r\n    schemas_dir: \"pub/databases/ena/doc/xsd/sra_1_6/\"\r\n    # Information regarding the XML construction:\r\n    schema_instance_reference: \"noNamespaceSchemaLocation\"\r\n    schema_instance: \"http://www.w3.org/2001/XMLSchema-instance\"\r\n    schemas_directory: \"http://ftp.ebi.ac.uk/pub/databases/ena/doc/xsd/sra_1_6/\"\r\n    object_schemas:\r\n        sample: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/SRA.sample.xsd\"\r\n        experiment: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/SRA.experiment.xsd\"\r\n        run: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/sra_1_6/SRA.run.xsd\"\r\n        dac: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/EGA.dac.xsd\"\r\n        dataset: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/EGA.dataset.xsd\"\r\n        policy: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/EGA.policy.xsd\"\r\n        analysis: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/SRA.analysis.xsd\"\r\n        study: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/SRA.study.xsd\"\r\n        submission: \"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_6/SRA.submission.xsd\"\r\n\r\n# -------- #\r\n# XMLs structure\r\n# -------- #\r\n\r\n# Every element (XML node) can have 5 characteristics. Their names are saved\r\n#   at the beginning of \"common_key_values\":\r\n#       - children: it contains a dictionary with the children elements of the current node (e.g. TAXON_ID and COMMON_NAME\r\n#                   would be the children of SAMPLE_NAME)\r\n#                   Example: in the following XML, the element \"FILE\" is the children of element \"FILES\"\r\n#                            <FILES>\r\n#                               <FILE filename=\"path/to/file.txt\"/>\r\n#                            </FILES>\r\n#       - attributes:   it contains a dictionary of the attributes, where the keys are the XML tags (e.g. \"alias\")\r\n#                       and its values are their corresponding column name in the dataframe/input file (e.g. \"Sample_ID\")\r\n#                       Example: in the following XML, \"filename\" is the attribute of the element \"FILE\"\r\n#                                <FILE filename=\"path/to/file.txt\"/>\r\n#       - text: it contains a string with the text that should be put within the XML element.\r\n#               Example: in the following XML, \"gender\" is the text within the element \"TAG\"\r\n#                                <TAG>gender</TAG\r\n#       - repetitive_node: if this line exists, it defines a repetitive node, which means that the tool will try to infer\r\n#                          how many times it shall be repeated (based on the input dataframe's columns). It can be a plain\r\n#                          \"repetitive_node:\" or with any other element inside (e.g. \"repetitive_node: True\").\r\n#                          Example: in the following XML, the element \"FILE\" is repeated thrice.\r\n#                            <FILES>\r\n#                               <FILE filename=\"path/to/file1.txt\"/>\r\n#                               <FILE filename=\"path/to/file2.txt\"/>\r\n#                               <FILE filename=\"path/to/file3.txt\"/>\r\n#                            </FILES>\r\n#       - add_empty_node: if this entry exists within an XML tag, the tool will know that this node holds information by\r\n#                         itself, even if left empty, and thus will not be removed from the XML at the prunning stage. \r\n#                         Example: in the following XML, the element \"SINGLE\" is an empty node that needs to be left within the\r\n#                                  XML tree. \r\n#                            <LIBRARY_LAYOUT>\r\n#                               <SINGLE/>\r\n#                            </LIBRARY_LAYOUT>\r\n#       - choice_tag: it contains the column name (e.g. \"Analysis_type\") whose value for that row will decide which child node is chosen\r\n#                     among the possible choices. All child nodes that contain the same column name at \"choice_tag\" will be excluded unless\r\n#                     their node names (e.g. SEQUENCE_VARIATION) are given as a value (or values separated by \";\") of that column at their  \r\n#                     corresponding row.\r\n#                     In other words, if the 5th Analysis instance (row) is of type Sequence variation, all other children nodes of \"ANALYSIS_TYPE\"\r\n#                     that contain the choice \"Analysis_type\" will be excluded except for \"SEQUENCE_VARIATION\", since this will be the value that\r\n#                     one shall give at row 5 and column name \"Analysis_type\". In case of a multi-choice case, chosen nodes can be given as a \r\n#                     list of node names separated by \";\" (e.g. \"SEQUENCE_VARIATION;SEQUENCE_FLATFILE\")\r\n#                     Example: in the following XML, the Analysis type was chosen to be SEQUENCE_FLATFILE, and no other children of ANALYSIS_TYPE\r\n#                              will be considered. \r\n#                              <ANALYSIS_TYPE>\r\n#                                 <SEQUENCE_FLATFILE/>\r\n#                              </ANALYSIS_TYPE>\r\n\r\n\r\n# Important: if we create a node's attribute/text in this schema, there HAS to be a column in the input dataframe\r\n#            referencing it (the script will be looking for it). Even if it's empty for some or all rows.\r\n\r\n####-----------------####\r\n# - COMMON KEY-VALUES - #\r\n####-----------------####\r\n# In this section we will store some of the values or even key-value pairs that are commonly\r\n#   used in this file. They are stored with \"&\", and accessed with \"*\" or \"<<: *\".\r\ncommon_key_values:\r\n  # The 5 main characteristics that elements in this file can have\r\n  children_tag: &child \"children\"\r\n  attributes_tag: &att \"attributes\"\r\n  text_tag: &tx \"text\"\r\n  repetitiveNode_tag: &RN \"repetitive_node\"\r\n  add_empty_node: &empty \"add_empty_node\"     # This one is used at XML tags that are empty but its pressence is meaningful by itself, with no\r\n                                              #   attributes nor text. \r\n  choice_tag: &choice \"choice_tag\"\r\n\r\n  #! To be uncommented once EE-1841 is done\r\n  # multiple_choice_child: &multi_child \"multiple_choice_child\"\r\n\r\n  # From this point we will save common attributes for objects that are sometimes\r\n  #   repeated within our schemas.\r\n  # Basic attributes of the file node (others will be specified at each schema)\r\n  file_basic_attributes: &file_basic_attributes\r\n    filename: \"Filename\"\r\n    filetype: \"Filetype\"\r\n    checksum_method: \"Checksum_method\"\r\n    checksum: \"Encrypted_checksum\"\r\n    unencrypted_checksum: \"Unencrypted_checksum\"\r\n  # The typical object's custom attribute (repetitive) with 3 nodes and text\r\n  custom_tag_value_node: &custom_tag_value_unit\r\n    *RN:\r\n    *child:\r\n      tag:\r\n          *tx: \"Tag\"\r\n      value:\r\n          *tx: \"Value\"\r\n      units:\r\n          *tx: \"Units\"\r\n\r\n  #! To be uncommented once EE-1841 is done\r\n  # Another common node for links, used in all objects\r\n  # URL_XREF_ENTREZ_links_node: &URL_XREF_ENTREZ_links_node\r\n  #   *RN:\r\n  #   *multi_child:\r\n  #     URL_LINK:\r\n  #       *child:\r\n  #         LABEL:\r\n  #           *tx: \"URL_LINK.Label\"\r\n  #         URL:\r\n  #           *tx: \"URL_LINK.URL\"\r\n  #     XREF_LINK:\r\n  #       *child:\r\n  #         DB:\r\n  #           *tx: \"XREF_LINK.DB\"\r\n  #         ID:\r\n  #           *tx: \"XREF_LINK.ID\"\r\n  #         #! Nobody used QUERY in an XREF link, there's literally no data for it so far in ERAPRO,\r\n  #         #     and there's little to no documentation about it. \r\n  #         # QUERY:\r\n  #         #   *tx: \"XREF_LINK.Query\"\r\n  #         LABEL:\r\n  #           *tx: \"XREF_LINK.label\"\r\n  #     ENTREZ_LINK:\r\n  #       *child:\r\n  #         DB:\r\n  #           *tx: \"ENTREZ_LINK.DB\"\r\n  #         ID:\r\n  #           *tx: \"ENTREZ_LINK.ID\"\r\n  #         #! Just like with XREF: not a single entry of QUERY here.   \r\n  #         # QUERY:\r\n  #         #   *tx: \"ENTREZ_LINK.query\"\r\n  #         LABEL:\r\n  #           *tx: \"ENTREZ_LINK.label\"\r\n\r\n  # Node used in RUN and EXPERIMENT objects\r\n  platform_multichoice_node: &platform_multichoice_node\r\n    *child:\r\n      LS454:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"LS454.Instrument_model\"\r\n      ILLUMINA:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"ILLUMINA.Instrument_model\"\r\n      HELICOS:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"HELICOS.Instrument_model\"\r\n      ABI_SOLID:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"ABI_SOLID.Instrument_model\"\r\n      COMPLETE_GENOMICS:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"COMPLETE_GENOMICS.Instrument_model\"\r\n      BGISEQ:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"BGISEQ.Instrument_model\"\r\n      OXFORD_NANOPORE:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"OXFORD_NANOPORE.Instrument_model\"\r\n      PACBIO_SMRT:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"PACBIO_SMRT.Instrument_model\"\r\n      ION_TORRENT:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"ION_TORRENT.Instrument_model\"\r\n      CAPILLARY:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"CAPILLARY.Instrument_model\"\r\n      DNBSEQ:\r\n        *choice: \"Platform*\"\r\n        *child:\r\n          INSTRUMENT_MODEL:\r\n            *tx: \"DNBSEQ.Instrument_model\"\r\n  # The node referencing to the assembly and sequence used in the submitted reads\r\n  #!   We might want to remove some optional parts of it if it becomes too long.\r\n  ReferenceAssemblyType_node: &ReferenceAssemblyType_node\r\n    ASSEMBLY: # OPT\r\n      *child:\r\n        STANDARD:\r\n          *att:\r\n            refname: \"Assembly_name\"\r\n            accession: \"Assembly_accessionVersion\"  # REQ\r\n        #! Check if it's worth it to add the <CUSTOM> genome assembly node besides the standard -- THERE ARE some analysis with CUSTOM nodes for Reference Alignment\r\n    SEQUENCE: # OPT\r\n      *RN:\r\n      *att:\r\n        # refname: \"RefSequence_name\"\r\n        accession: \"SEQUENCE.Accession\"  # REQ\r\n        label: \"SEQUENCE.Label\"\r\n\r\n\r\n####-------------####\r\n# - SAMPLE OBJECT - #\r\n####-------------####\r\nsample:\r\n    *att: # OPT\r\n         alias: \"Sample_alias*\"\r\n         center_name: \"Center_name*\"\r\n         broker_name: \"Broker_name\"\r\n    *child:\r\n        TITLE:\r\n          *tx: \"Title*\"\r\n        SAMPLE_NAME:\r\n          *child:\r\n            TAXON_ID:\r\n              *tx: \"NCBI_taxid*\"\r\n            SCIENTIFIC_NAME:\r\n              *tx: \"Scientific_name*\"\r\n            COMMON_NAME:\r\n              *tx: \"Common_name*\"\r\n        DESCRIPTION:\r\n          *tx: \"Description\"\r\n        #! To be uncommented once EE-1841\r\n        # SAMPLE_LINKS:\r\n        #   *child:\r\n        #     SAMPLE_LINK:\r\n        #       <<: *URL_XREF_ENTREZ_links_node\r\n        sample_attributes:\r\n          *child:\r\n            # Bear in mind that subject_id, gender and phenotype are mandatory\r\n            #   as tag/value/unit blocks in \"sample\"\r\n            sample_attribute:\r\n              <<: *custom_tag_value_unit\r\n\r\n####------------####\r\n# - Study OBJECT - #\r\n####------------####\r\nstudy:\r\n    *att: # OPT\r\n        alias: \"Study_alias*\"\r\n        center_name: \"Center_name*\"\r\n        broker_name: \"Broker_name\"\r\n    *child:\r\n        DESCRIPTOR: # REQ\r\n            *child:\r\n                STUDY_TITLE:  # REQ\r\n                  *tx: \"Study_title*\"\r\n                STUDY_TYPE: # REQ\r\n                  *att:\r\n                    existing_study_type: \"Existing_study_type*\"\r\n                    new_study_type: \"New_study_type\"\r\n                STUDY_ABSTRACT: # OPT\r\n                  *tx: \"Study_abstract\"\r\n                CENTER_PROJECT_NAME:  # OPT\r\n                  *tx: \"Center_ProjectName\"\r\n                RELATED_STUDIES:  # OPT\r\n                  *child:\r\n                    RELATED_STUDY:\r\n                      *RN:\r\n                      *child:\r\n                        RELATED_LINK:\r\n                          *child:\r\n                            DB:\r\n                              *tx: \"RelatedStudy_DB\"\r\n                            ID:\r\n                              *tx: \"RelatedStudy_ID\"\r\n                            #! Not a single study used the Query. \r\n                            # QUERY:\r\n                            #   *tx: \"RelatedStudy_Query\"\r\n                            LABEL:\r\n                              *tx: \"RelatedStudy_label\"\r\n                        IS_PRIMARY:\r\n                          *tx: \"RelatedStudy_IsPrimary\"\r\n                STUDY_DESCRIPTION:  # OPT\r\n                  *tx: \"Study_description\"\r\n        #! To be uncommented once EE-1841\r\n        # STUDY_LINKS:  # OPT\r\n        #   *child:\r\n        #     STUDY_LINK:\r\n        #       <<: *URL_XREF_ENTREZ_links_node\r\n        STUDY_ATTRIBUTES:  # OPT\r\n          *child:\r\n            STUDY_ATTRIBUTE:\r\n              <<: *custom_tag_value_unit\r\n\r\n####----------####\r\n# - Run OBJECT - #\r\n####----------####\r\nrun:\r\n    *att: # OPT\r\n        alias: \"Run_alias*\"\r\n        center_name: \"Center_name*\"\r\n        broker_name: \"Broker_name\"\r\n        run_date: \"Run_date\"\r\n        run_center: \"Run_center\"\r\n    *child:\r\n      TITLE:  # OPT\r\n        *tx: \"Title\"\r\n      EXPERIMENT_REF: # REQ\r\n        *att:\r\n            refname: \"ExperimentReference_Name*\"\r\n            refcenter: \"ExperimentReference_Center*\"\r\n            # accession: \"ExperimentReference_Accession\"\r\n\r\n      #! Check if it's worh it to add the <SPOT_DESCRIPTOR> element\r\n\r\n      #! The platform is already assigned in the EXPERIMENT metadata object\r\n      # PLATFORM: # OPT\r\n      #   <<: *platform_multichoice_node\r\n\r\n      #! Check if it's worh it to add the <PROCESSING> element, and add it as a common one\r\n      #!    since it's used in EXPERIMENTS too.\r\n\r\n      RUN_TYPE:\r\n        *child:\r\n          REFERENCE_ALIGNMENT:\r\n            *child:\r\n              <<: *ReferenceAssemblyType_node\r\n\r\n      DATA_BLOCK: # OPT\r\n        *child:\r\n          FILES:\r\n              *child:\r\n                  FILE:\r\n                      *RN:\r\n                      *att:\r\n                          <<: *file_basic_attributes\r\n                          quality_scoring_system: \"Scoring_system\" # OPT  Controlled Vocabulary\r\n                          quality_encoding: \"MinQuality_Ascii\" # OPT\r\n                          ascii_offset: \"Ascii_offset\"\r\n                  #! Check if it's worth it to add the <READ_LABEL> node\r\n      #! To be uncommented once EE-1841\r\n      # RUN_LINKS:  # OPT\r\n      #   *child:\r\n      #     RUN_LINK:\r\n      #       <<: *URL_XREF_ENTREZ_links_node\r\n      RUN_ATTRIBUTES:  # OPT\r\n        *child:\r\n          RUN_ATTRIBUTE:\r\n            <<: *custom_tag_value_unit\r\n\r\n####---------------####\r\n# - Analysis OBJECT - #\r\n####---------------####\r\nanalysis:\r\n  *att: # OPT\r\n    alias: \"Analysis_alias*\"\r\n    center_name: \"Center_name*\"\r\n    broker_name: \"Broker_name\"\r\n    analysis_date: \"Analysis_date\"\r\n    analysis_center: \"Analysis_center\"\r\n  *child:\r\n    TITLE:  # OPT\r\n      *tx: \"Title\"\r\n    DESCRIPTION:  # OPT\r\n      *tx: \"Description\"\r\n    STUDY_REF:  # REQ\r\n      *att:\r\n        refname: \"Study_alias\"\r\n        # refcenter: \"Study_CenterName\"\r\n        # accession: \"Study_accession\"\r\n        # label: \"Study_label\"\r\n    SAMPLE_REF:\r\n      *RN:\r\n      *att:\r\n        refname: \"Sample_alias\"\r\n        # refcenter: \"Sample_CenterName\"\r\n        # accession: \"Sample_accession\"\r\n        label: \"Sample_Label\"\r\n    EXPERIMENT_REF:\r\n      *RN:\r\n      *att:\r\n        refname: \"Experiment_alias\"\r\n        # refcenter: \"Experiment_CenterName\"\r\n        # accession: \"Experiment_accession\"\r\n    RUN_REF:\r\n      *RN:\r\n      *att:\r\n        refname: \"Run_alias\"\r\n        # refcenter: \"Run_CenterName\"\r\n        # accession: \"Run_accession\"\r\n        label: \"Run_label\"\r\n    ANALYSIS_REF:\r\n      *RN:\r\n      *att:\r\n        refname: \"OtherAnalysis_alias\"\r\n        # refcenter: \"OtherAnalysis_CenterName\"\r\n        # accession: \"OtherAnalysis_accession\"\r\n        label: \"OtherAnalysis_label\"\r\n\r\n    ANALYSIS_TYPE:  # REQ\r\n      *child:\r\n        REFERENCE_ALIGNMENT:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            <<: *ReferenceAssemblyType_node\r\n\r\n        SEQUENCE_VARIATION:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            <<: *ReferenceAssemblyType_node\r\n\r\n            EXPERIMENT_TYPE:  # Controlled Vocabulary\r\n              *tx: \"SEQUENCE_VARIATION.Experiment_type\"\r\n            PROGRAM:\r\n              *tx: \"SEQUENCE_VARIATION.Program\"\r\n            PLATFORM:\r\n              *tx: \"SEQUENCE_VARIATION.Platform\"\r\n            # IMPUTATION:\r\n            #   *tx: \"Imputation\"\r\n\r\n        SEQUENCE_ASSEMBLY:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            NAME:\r\n              *tx: \"SEQUENCE_ASSEMBLY.Name\"\r\n            TYPE: # Controlled Vocabulary\r\n              *tx: \"SEQUENCE_ASSEMBLY.Type\"\r\n            COVERAGE:\r\n              *tx: \"SEQUENCE_ASSEMBLY.Coverage\"\r\n            PLATFORM:\r\n              *tx: \"SEQUENCE_ASSEMBLY.Platform\"\r\n            MIN_GAP_LENGTH:\r\n              *tx: \"SEQUENCE_ASSEMBLY.MinGapLen\"\r\n            MOL_TYPE: # Controlled Vocabulary\r\n              *tx: \"SEQUENCE_ASSEMBLY.MoleculeType\"\r\n            PROGRAM:\r\n              *tx: \"SEQUENCE_ASSEMBLY.Program\"\r\n            PARTIAL:\r\n              *tx: \"SEQUENCE_ASSEMBLY.Partial\"\r\n            #! Check if it's worth it to use:\r\n            # TPA:\r\n            #   *tx: \"Sequence_Assembly.TPA\"\r\n            # AUTHORS:\r\n            #   *tx: \"Sequence_Assembly.Authors\"\r\n            # ADDRESS:\r\n            #   *tx: \"Sequence_Assembly.Address\"\r\n\r\n        # SEQUENCE_FLATFILE:\r\n        #   *choice: \"Analysis_type*\"\r\n        #   *empty:\r\n\r\n        SEQUENCE_ANNOTATION:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            <<: *ReferenceAssemblyType_node\r\n\r\n        # REFERENCE_SEQUENCE:\r\n        #   *choice: \"Analysis_type*\"\r\n        #   *empty:\r\n\r\n        SAMPLE_PHENOTYPE:\r\n          *choice: \"Analysis_type*\"\r\n          *empty:\r\n\r\n        PROCESSED_READS:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            <<: *ReferenceAssemblyType_node\r\n\r\n        GENOME_MAP:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            PROGRAM:\r\n              *tx: \"Genome_Map.Program\"\r\n            PLATFORM: # Controlled Vocabulary\r\n              *tx: \"Genome_Map.Platform\"\r\n            DESCRIPTION:\r\n              *tx: \"Genome_Map.Description\"\r\n\r\n        # AMR_ANTIBIOGRAM:\r\n        #   *choice: \"Analysis_type*\"\r\n        #   *empty:\r\n\r\n        PATHOGEN_ANALYSIS:\r\n          *choice: \"Analysis_type*\"\r\n          *empty:\r\n\r\n        TRANSCRIPTOME_ASSEMBLY:\r\n          *choice: \"Analysis_type*\"\r\n          *child:\r\n            NAME:\r\n              *tx: \"Transcriptome_Assembly.Name\"\r\n            TYPE: # Controlled Vocabulary\r\n              *tx: \"Transcriptome_Assembly.Type\"\r\n            PLATFORM:\r\n              *tx: \"Transcriptome_Assembly.Platform\"\r\n            PROGRAM:\r\n              *tx: \"Transcriptome_Assembly.Program\"\r\n            # TPA:\r\n            #   *tx: \"TPA\"\r\n            # AUTHORS:\r\n            #   *tx: \"Authors\"\r\n            # ADDRESS:\r\n            #   *tx: \"Address\"\r\n\r\n        #! There are only 2 analysis that use the NAME of TAXONOMIC_REFERENCE_SET, which denotes that its usage is marginal\r\n        # TAXONOMIC_REFERENCE_SET:\r\n        #   *choice: \"Analysis_type*\"\r\n        #   *child:\r\n        #     NAME:\r\n        #       *tx: \"Taxonomic_RefSet.Name\"\r\n        #     TAXONOMY_SYSTEM:\r\n        #       *tx: \"Taxonomic_RefSet.System\"\r\n            # TAXONOMY_SYSTEM_VERSION:\r\n            #   *tx: \"Taxonomic_RefSet.SystemVersion\"\r\n            # CUSTOM_FIELDS:\r\n            #   *child:\r\n            #     FIELD:\r\n            #       *RN:\r\n            #       *child:\r\n            #         NAME:\r\n            #           *tx: \"CustomField_Name\"\r\n            #         DESCRIPTION:\r\n            #           *tx: \"CustomField_Description\"\r\n    FILES:\r\n      *child:\r\n        FILE:\r\n          *RN:\r\n          *att:\r\n            <<: *file_basic_attributes\r\n            checklist: \"Checklist\"\r\n\r\n    #! To be uncommented once EE-1841 is done\r\n    # ANALYSIS_LINKS:  # OPT\r\n    #   *child:\r\n    #     ANALYSIS_LINK:\r\n    #       <<: *URL_XREF_ENTREZ_links_node\r\n\r\n    ANALYSIS_ATTRIBUTES:  # OPT\r\n      *child:\r\n        ANALYSIS_ATTRIBUTE:\r\n          <<: *custom_tag_value_unit\r\n\r\n####-----------------####\r\n# - Experiment OBJECT - #\r\n####-----------------####\r\n\r\nexperiment:\r\n  *att: # OPT\r\n     alias: \"Experiment_alias*\"\r\n     center_name: \"Center_name*\"\r\n     broker_name: \"Broker_name\"\r\n  *child:\r\n    TITLE:\r\n      *tx: \"Title\"\r\n    STUDY_REF:  # REQ\r\n      *att:\r\n        refname: \"Study_refname*\"\r\n        refcenter: \"Study_refCenter*\"\r\n        # accession: \"Study_accession\"\r\n    DESIGN: # REQ\r\n      *child:\r\n        DESIGN_DESCRIPTION: # REQ\r\n          *tx: \"Design_description*\"\r\n        SAMPLE_DESCRIPTOR:\r\n          *att:\r\n            # refname: \"Sample_refname\"\r\n            # refcenter: \"Sample_refCenter\"\r\n            accession: \"Sample_accession*\"\r\n          #! choice:      Although at ENA's schemas it seems there's only one choice.\r\n          #! The POOL element is hardly used (for what I've seen), and the sample accession is enough\r\n          #!    therefore. Check if it's worth it to add the pool element. \r\n          # *child:\r\n          #   POOL:\r\n          #     *child:\r\n          #       DEFAULT_MEMBER:\r\n          #         *att:\r\n          #           refname: \"DefaultMember_refname\"\r\n          #           refcenter: \"DefaultMember_refCenter\"\r\n          #           accession: \"DefaultMember_accession\"\r\n          #           # member_name: \"DefaultMember_name\"\r\n          #           # proportion: \"PercentageOfDefaultMember_Included\"\r\n          #         # *child:\r\n          #           # READ_LABEL: # OPT\r\n          #       MEMBER: # REQ\r\n          #         *RN:\r\n          #         *att:\r\n          #           refname: \"Member_refname\"\r\n          #           refcenter: \"Member_refCenter\"\r\n          #           accession: \"Member_accession\"\r\n          #           # member_name: \"Member_name\"\r\n          #           # proportion: \"PercentageOfMember_Included\"\r\n          #         # *child:\r\n          #           # READ_LABEL: # OPT\r\n\r\n        LIBRARY_DESCRIPTOR: # REQ\r\n          *child:\r\n            LIBRARY_NAME: # OPT\r\n              *tx: \"Library_name\"\r\n            LIBRARY_STRATEGY: # REQ Controlled Vocabulary\r\n              *tx: \"Library_strategy*\"\r\n            LIBRARY_SOURCE: # REQ Controlled Vocabulary\r\n              *tx: \"Library_source*\"\r\n            LIBRARY_SELECTION:  # REQ Controlled Vocabulary\r\n              *tx: \"Library_selection*\"\r\n            LIBRARY_LAYOUT: # REQ\r\n              *child:\r\n                SINGLE:\r\n                  *choice: \"Experiment_layout*\"\r\n                  *empty:\r\n                PAIRED:\r\n                  *choice: \"Experiment_layout*\"\r\n                  *att:\r\n                    NOMINAL_LENGTH: \"PAIRED.Nominal_length\"\r\n                    NOMINAL_SDEV: \"PAIRED.Nominal_sdev\"\r\n            TARGETED_LOCI:  # OPT\r\n              *child:\r\n                LOCUS:\r\n                  *RN:\r\n                  *att:\r\n                    locus_name: \"Locus_name\"  # Controlled Vocabulary\r\n                    description: \"Locus_description\"\r\n                  # *child:\r\n                  #   PROBE_SET:\r\n                  #     *child:\r\n                  #       DB:\r\n                  #         *tx: \"\"\r\n                  #       ID:\r\n                  #         *tx: \"\"\r\n                  #       LABEL:\r\n                  #         *tx: \"\"\r\n            # POOLING_STRATEGY: # OPT\r\n            #   *tx: \"Pooling_strategy\"\r\n            LIBRARY_CONSTRUCTION_PROTOCOL:\r\n              *tx: \"Library_construction_protocol\"\r\n\r\n        SPOT_DESCRIPTOR:\r\n          *child:\r\n            SPOT_DECODE_SPEC:\r\n              *child:\r\n                SPOT_LENGTH:\r\n                  *tx: \"SPOT_LENGTH\"\r\n                READ_SPEC:\r\n                  *RN:\r\n                  *child:\r\n                    READ_INDEX:\r\n                      *tx: \"ReadSpec.READ_INDEX\"\r\n                    READ_LABEL:\r\n                      *tx: \"ReadSpec.READ_LABEL\" \r\n                    READ_CLASS:\r\n                      *tx: \"ReadSpec.READ_CLASS\"\r\n                    READ_TYPE:  # CV\r\n                      *tx: \"ReadSpec.READ_TYPE\"     \r\n                    RELATIVE_ORDER:\r\n                      *att:\r\n                        follows_read_index: \"ReadSpec.Preceding_read_index\"              \r\n                    BASE_COORD:\r\n                      *tx: \"ReadSpec.BASE_COORD\"\r\n                    EXPECTED_BASECALL_TABLE:\r\n                      *att:\r\n                        default_length: \"ReadSpec.Expected_Default_Length\"\r\n                        # base_coord: \"ReadSpec.Expected_Default_Length\"\r\n                      *child:\r\n                        BASECALL:\r\n                          #! *RN: but we cannot allow for it due to its dimensional complexity.\r\n                          #   It shall be noted though that there is such case in the database, and thus we find ourselves limited by this constraint. We could find alternative methods to get this information (e.g. getting all basecalls within one single cell, using a separator for each attribute or text, and another one for each \"basecall\" separation)\r\n                          #   but that will take a modification of the tooling, addition of a new characteristic within this YAML, etc. \r\n                          #    like using separators within one single cell (e.g. )\r\n                          #    Example of what we can find: \r\n                          #   <EXPECTED_BASECALL_TABLE>\r\n                          #     <BASECALL min_match=\"40\" max_mismatch=\"5\" match_edge=\"full\">GTTGGAACCGAAAGGGTTTGAATTCAAACTTTCGGTTCCAAC</BASECALL>\r\n                          #     <BASECALL min_match=\"38\" max_mismatch=\"5\" match_edge=\"full\">TCGTATAACTTCGTATAATGTATGCTATACAGTTATTACG</BASECALL>\r\n                          #     <BASECALL min_match=\"38\" max_mismatch=\"5\" match_edge=\"full\">CGTAATAACTTCGTATAGCATACATTATAAAGTTATACGA</BASECALL>\r\n                          #   </EXPECTED_BASECALL_TABLE>\r\n                          *att:\r\n                            min_match: \"ReadSpec.Basecall_min_match\"\r\n                            max_mismatch: \"ReadSpec.Basecall_max_mismatch\"\r\n                            match_edge: \"ReadSpec.Basecall_match_edge\"\r\n                          *tx: \"ReadSpec.Basecall\"\r\n\r\n    PLATFORM: # REQ\r\n      <<: *platform_multichoice_node\r\n\r\n    PROCESSING:  # OPT\r\n      *child:\r\n        PIPELINE:\r\n          *child:\r\n            PIPE_SECTION:\r\n              *RN:\r\n              # *att:\r\n              #   section_name: \"Pipeline_section_name\"\r\n              *child:\r\n                STEP_INDEX:\r\n                  *tx: \"Pipeline.StepIndex\"\r\n                PREV_STEP_INDEX: # OPT\r\n                  #!! There's an issue with this element, since instead of being \"0\" for the first pipesection\r\n                  #!!   it says to set \"nil=True\", but our tool was not developed for users to modify those attributes. For now, instead we will imput N/A, NIL or leave it empty. \r\n                  # *RN - But we cannot allow it due to the complexity of the dataframe. An alternative would be to create a whole list (within one cell) of previous steps with a separator of some sort (e.g. \";\"). \r\n                  *tx: \"Pipeline.PreviousStepIndex\"\r\n                PROGRAM:\r\n                  *tx: \"Pipeline.Program\"\r\n                VERSION:\r\n                  *tx: \"Pipeline.ProgramVersion\"\r\n                NOTES: # OPT\r\n                  *tx: \"Pipeline.Notes\"\r\n        #! Check how useful it would be to add DIRECTIVES\r\n        # DIRECTIVES: # OPT\r\n        #   *child:\r\n        #     SAMPLE_DEMUX_DIRECTIVE: # OPT Controlled Vocabulary\r\n        #       *tx: \"Sample_demux_directive\"\r\n    \r\n    #! To be uncommented once EE-1841 is done\r\n    # EXPERIMENT_LINKS: # OPT\r\n    #   *child:\r\n    #     EXPERIMENT_LINK:\r\n    #       <<: *URL_XREF_ENTREZ_links_node\r\n    EXPERIMENT_ATTRIBUTES:  # OPT\r\n      *child:\r\n        EXPERIMENT_ATTRIBUTE:\r\n          <<: *custom_tag_value_unit\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Star2xml/configuration_files/xml_schema.yaml b/Star2xml/configuration_files/xml_schema.yaml
--- a/Star2xml/configuration_files/xml_schema.yaml	(revision 9341fc22df47681c560f68520d9a896f7645394b)
+++ b/Star2xml/configuration_files/xml_schema.yaml	(date 1617095979882)
@@ -100,6 +100,7 @@
   add_empty_node: &empty "add_empty_node"     # This one is used at XML tags that are empty but its pressence is meaningful by itself, with no
                                               #   attributes nor text. 
   choice_tag: &choice "choice_tag"
+  repetitiveNode_Father_Tag: &RN-father "repetitiveNode_Father_Tag"
 
   #! To be uncommented once EE-1841 is done
   # multiple_choice_child: &multi_child "multiple_choice_child"
@@ -126,38 +127,40 @@
 
   #! To be uncommented once EE-1841 is done
   # Another common node for links, used in all objects
-  # URL_XREF_ENTREZ_links_node: &URL_XREF_ENTREZ_links_node
-  #   *RN:
-  #   *multi_child:
-  #     URL_LINK:
-  #       *child:
-  #         LABEL:
-  #           *tx: "URL_LINK.Label"
-  #         URL:
-  #           *tx: "URL_LINK.URL"
-  #     XREF_LINK:
-  #       *child:
-  #         DB:
-  #           *tx: "XREF_LINK.DB"
-  #         ID:
-  #           *tx: "XREF_LINK.ID"
-  #         #! Nobody used QUERY in an XREF link, there's literally no data for it so far in ERAPRO,
-  #         #     and there's little to no documentation about it. 
-  #         # QUERY:
-  #         #   *tx: "XREF_LINK.Query"
-  #         LABEL:
-  #           *tx: "XREF_LINK.label"
-  #     ENTREZ_LINK:
-  #       *child:
-  #         DB:
-  #           *tx: "ENTREZ_LINK.DB"
-  #         ID:
-  #           *tx: "ENTREZ_LINK.ID"
-  #         #! Just like with XREF: not a single entry of QUERY here.   
-  #         # QUERY:
-  #         #   *tx: "ENTREZ_LINK.query"
-  #         LABEL:
-  #           *tx: "ENTREZ_LINK.label"
+  URL_XREF_ENTREZ_links_node: &URL_XREF_ENTREZ_links_node
+    *child:
+      URL_LINK:
+        *RN:
+        *child:
+          LABEL:
+            *tx: "URL_LINK.Label"
+          URL:
+            *tx: "URL_LINK.URL"
+      XREF_LINK:
+        *RN:
+        *child:
+          DB:
+            *tx: "XREF_LINK.DB"
+          ID:
+            *tx: "XREF_LINK.ID"
+          #! Nobody used QUERY in an XREF link, there's literally no data for it so far in ERAPRO,
+          #     and there's little to no documentation about it. 
+          # QUERY:
+          #   *tx: "XREF_LINK.Query"
+          LABEL:
+            *tx: "XREF_LINK.label"
+      ENTREZ_LINK:
+        *RN:
+        *child:
+          DB:
+            *tx: "ENTREZ_LINK.DB"
+          ID:
+            *tx: "ENTREZ_LINK.ID"
+          #! Just like with XREF: not a single entry of QUERY here.   
+          # QUERY:
+          #   *tx: "ENTREZ_LINK.query"
+          LABEL:
+            *tx: "ENTREZ_LINK.label"
 
   # Node used in RUN and EXPERIMENT objects
   platform_multichoice_node: &platform_multichoice_node
@@ -257,10 +260,11 @@
         DESCRIPTION:
           *tx: "Description"
         #! To be uncommented once EE-1841
-        # SAMPLE_LINKS:
-        #   *child:
-        #     SAMPLE_LINK:
-        #       <<: *URL_XREF_ENTREZ_links_node
+        SAMPLE_LINKS:
+          *child:
+            SAMPLE_LINK:
+              *RN-father:
+              <<: *URL_XREF_ENTREZ_links_node
         sample_attributes:
           *child:
             # Bear in mind that subject_id, gender and phenotype are mandatory
Index: Star2xml/XML_creator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import lxml.etree as etree\r\nfrom datetime import datetime\r\nimport sys\r\nimport yaml\r\nimport pandas as pd\r\nimport os.path\r\n\r\n# The next tags will define every element of the schema_file (a YAML file containing XML's structure)\r\nchildren_tag = \"children\"\r\nattribute_tag = \"attributes\"\r\ntext_tag = \"text\"\r\nrepetitive_tag = \"repetitive_node\"\r\nadd_empty_node_tag = \"add_empty_node\"\r\nchoice_tag = \"choice_tag\"\r\nvalid_dict_elements = set([children_tag, attribute_tag, text_tag, repetitive_tag, add_empty_node_tag, choice_tag])\r\ntool_info_tag = \"tool_info\"\r\nversion_tag = \"version\"\r\nupdate_date_tag = \"update_date\"\r\n\r\nclass XML_creator():\r\n    \"\"\"\r\n    XML creation class using a YAML file containing the XML's schema and a dataframe containing its\r\n        information (attributes and text).\r\n    \"\"\"\r\n\r\n    def __init__(self, schema_filename, input_dataframe, schema_key, output_xml, verbose = False, debug_mode = False):\r\n        \"\"\"\r\n        Initialization (constructor) of an instance.\r\n\r\n        Parameters:\r\n            - self: not explicitly given, it's the instance itself.\r\n            - schema_filename (str): a filepath to the YAML file containing the structure of the output XML\r\n                                     (e.g. 'path/to/schema_file.yaml').\r\n            - input_dataframe (df): a dataframe object (from Pandas) containing the information that will be put into\r\n                                    the XML. This dataframe can be obtained from an input file using Input_reader().\r\n            - schema_key (str): key string that defines the metadata object (e.g. \"sample\" or \"run\") within the YAML file.\r\n            - output_xml (str): filepath of the output XML file where it will be saved (e.g. 'output/sample.xml').\r\n        \"\"\"\r\n        self.verbose = verbose\r\n        self.debug_mode = debug_mode\r\n        self.schema_key = schema_key\r\n        self.schema_filename = schema_filename\r\n        self.output_xml = output_xml\r\n\r\n        if self.debug_mode:\r\n            self.log_filename = \"XML_creator.log\"\r\n\r\n        # We (try to) load the YAML schema (that contains XML element's dependencies, attributes, etc.)\r\n        try:\r\n            with open(schema_filename, \"r\") as schema_file:\r\n                self.schema_general_dict = yaml.safe_load(schema_file)\r\n        except FileNotFoundError:\r\n            print(\"ERROR in XML_creator(): given schema filepath '%s' does not exist or could not be found.\" \\\r\n                  % schema_filename, file=sys.stderr)\r\n            sys.exit()\r\n\r\n        except yaml.scanner.ScannerError as ScannerError:\r\n            print(\"ERROR in XML_creator(): in the given schema '%s' there was a scanning issue.\" \\\r\n                  % schema_filename, file=sys.stderr)\r\n            print(\"\\t - Problem: %s\" \\\r\n                  % ScannerError.problem, file=sys.stderr)\r\n            print(\"\\t - Problem's location: %s\" \\\r\n                  % ScannerError.context_mark, file=sys.stderr)\r\n            sys.exit()\r\n        except:\r\n            print(\"ERROR in XML_creator(): unknown error happened trying to yaml.safe_load() the given schema filepath '%s'.\" \\\r\n                  % schema_filename, file=sys.stderr)\r\n            sys.exit()\r\n\r\n        # We narrow the general dictionary to the one specific for our configuration key (e.g. \"sample\")\r\n        try:\r\n            self.schema_dict = self.schema_general_dict[self.schema_key]\r\n        except:\r\n            print(\"ERROR in XML_creator(): given schema file '%s' does not contain the given schema key '%s' in its first layer\" \\\r\n                  % (schema_filename, self.schema_key), file=sys.stderr)\r\n            sys.exit()\r\n\r\n        # We check that the given input_dataframe is a dataframe (following Pandas' standards)\r\n        if not isinstance(input_dataframe, pd.DataFrame):\r\n            print(\"ERROR in XML_creator(): given dataframe was of type '%s' instead of a dataframe (%s)\" \\\r\n                  % (type(input_dataframe), pd.DataFrame), file=sys.stderr)\r\n            sys.exit()\r\n\r\n        self.input_dataframe = input_dataframe\r\n        # We remove empty rows (full of NaNs)\r\n        self.input_dataframe.dropna(axis = 0, how = \"all\", inplace = True)\r\n\r\n        # We store the number of rows (number of metadata object repetitions) the dataframe contains\r\n        self.dataframe_nrows = len(self.input_dataframe.index)\r\n\r\n    def print_basic_info(self):\r\n        \"\"\"\r\n        Function to print some basic information about the tool, its schema file, etc.\r\n        \"\"\"\r\n        # We store the version of the schema file (from the schema itself)\r\n        schema_version = self.schema_general_dict[tool_info_tag][version_tag]\r\n        schema_update_date = self.schema_general_dict[tool_info_tag][update_date_tag]\r\n        date_now = datetime.today().isoformat()\r\n\r\n        General_info = \"\"\"\\n######----------------------------######\\n### Starting the XML_creator() class ###\\n######----------------------------######\r\n        General information:\r\n          - Execution datetime: {date_now}\r\n          - Class object's instance: {object_instance}\r\n          - Schema filepath: {schema_filename}\r\n          - Schema file version: {schema_version}\r\n          - Schema file last oficial update: {schema_update_date}\r\n          - Metadata object (schema key): {schema_key}\r\n          - Number of rows (number of {schema_key}s) in the given dataframe: {dataframe_nrows}\r\n          - Number of columns (attributes or text) in the given dataframe: {dataframe_ncols}\r\n        \"\"\".format(date_now = date_now,\r\n                   object_instance = self,\r\n                   schema_filename = self.schema_filename,\r\n                   schema_version = schema_version,\r\n                   schema_update_date = schema_update_date,\r\n                   schema_key = self.schema_key,\r\n                   dataframe_nrows = self.dataframe_nrows,\r\n                   dataframe_ncols = self.input_dataframe.shape[1])\r\n\r\n        self.print_or_save_log(General_info)\r\n\r\n    def print_or_save_log(self, string_to_print):\r\n        \"\"\"\r\n        Function to print a string to standard output, and save into a log.file if debug_mode = True.\r\n\r\n        Parameters:\r\n            - string_to_print (str): string that will be printed or saved to a log file.\r\n        \"\"\"\r\n        if self.verbose or self.debug_mode:\r\n            print(string_to_print)\r\n\r\n        if self.debug_mode:\r\n            with open(self.log_filename, \"a\") as log_filename:\r\n                log_filename.write(string_to_print)\r\n\r\n\r\n    def construct_xml(self):\r\n        \"\"\"\r\n        Function that will create an XML file based on the instance's dataframe and schema.yaml file.\r\n        \"\"\"\r\n\r\n        # We create the root of the XML tree, and its root_tag (e.g. SAMPLE_SET) will be used as\r\n        #     father element for its children (e.g. SAMPLE)\r\n        self.construct_xml_root()\r\n        father_element = self.root_tag\r\n\r\n        # The following list will be populated with nodes that have the add_empty_node_tag. These nodes will not be removed\r\n        #   by the prunning function, since they have a meaning by themselves, although they are empty (e.g. SINGLE in LIBRARY_LAYOUT)\r\n        self.nodesThatNeedToBe_empty_list = []\r\n\r\n        # We create the elements of the set (the whole XML tree).\r\n        self.construct_xml_elements(schema_tag = self.schema_key,\r\n                                    dict_element = self.schema_general_dict,\r\n                                    father_element = father_element)\r\n\r\n        # We prune empty nodes recursively\r\n        self.prune_empty_nodes()\r\n\r\n        if self.verbose or self.debug_mode:\r\n            self.print_or_save_log(\"\\n- Conversion completed! The generated XML is the following:\")\r\n            self.save_xml(to_print = True)\r\n\r\n        self.save_xml()\r\n\r\n    def save_xml(self, to_print = False, schema_tag = False):\r\n        \"\"\"\r\n        Function to save the (pretty-fied) XML tree into a file. It can also be used to print it into the standard output.\r\n\r\n        Parameters:\r\n            - to_print (bool): if True the function prints the XML into the standard output.\r\n                               if False the XML is saved into the output XML file.\r\n            - schema_tag (str): a string with the schema tag, it's only used if given, and for printing.\r\n        \"\"\"\r\n        xml_tree_toPrint = \"etree.tostring(self.{}, pretty_print=True, encoding='UTF-8', xml_declaration=True).decode('UTF-8')\".format(self.xml_root_tag)\r\n\r\n        # If we only want to print the tree:\r\n        if to_print:\r\n            # If schema_tag was given, we add another line to ease interpretation\r\n            if isinstance(schema_tag, str):\r\n                print_tag = \"\\n____Adding the node '%s'____\" % schema_tag.upper()\r\n                self.print_or_save_log(print_tag)\r\n\r\n            exec(\"self.print_or_save_log({})\".format(xml_tree_toPrint))\r\n\r\n        # If, instead, we want to save the XML tree to a file:\r\n        else:\r\n            # Check if output_dir where the output_xml will reside exists, create it if not\r\n            output_dir = os.path.dirname(self.output_xml)\r\n            dir_exists = os.path.isdir(output_dir)\r\n            if not dir_exists and output_dir != '':\r\n                os.makedirs(output_dir)\r\n            try:\r\n                with open(self.output_xml, \"w\") as xml_file:\r\n                    exec(\"xml_file.write({})\".format(xml_tree_toPrint))\r\n            except:\r\n                print(\"ERROR in XML_creator() - save_xml(): couldn not save the XML tree into the given filename '%s'\" \\\r\n                  % (self.output_xml), file=sys.stderr)\r\n                sys.exit()\r\n\r\n    def construct_xml_root(self):\r\n        \"\"\"\r\n        Function to construct the root of the metadata XML. It is important to bare in mind that this part\r\n            of an XML is very specific: if the schema validator of ENA changes, this part may need to change\r\n            accordingly.\r\n        \"\"\"\r\n\r\n        # We store the first line of the XML file, which will contain the schema_key with \"_SET\", and two attributes:\r\n        #    - xmlns:xsi                      (the schema instance, e.g. http://www.w3.org/2001/XMLSchema-instance)\r\n        #    - xsi:noNamespaceSchemaLocation  (where the schema for that object resides, e.g. ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_5/SRA.sample.xsd)\r\n        self.root_tag = (self.schema_key + \"_SET\").upper()\r\n        self.xml_root_tag = \"xmlVar_\" + self.root_tag\r\n        schema_instance = self.schema_general_dict[\"XML_schemas_info\"][\"schema_instance\"]\r\n        object_schema = self.schema_general_dict[\"XML_schemas_info\"][\"object_schemas\"][self.schema_key]\r\n        schema_instance_reference = self.schema_general_dict[\"XML_schemas_info\"][\"schema_instance_reference\"]\r\n\r\n        # We need to specify the namespaces of the root element. For example, the following lines added to the root:\r\n        #     - xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n        #     - xsi:noNamespaceSchemaLocation=\"ftp://ftp.sra.ebi.ac.uk/meta/xsd/sra_1_5/SRA.<OBJECT>.xsd\"\r\n        attributes_qname = etree.QName(schema_instance, schema_instance_reference)\r\n        exec(\"self.%s = etree.Element(self.root_tag, {attributes_qname: object_schema}, nsmap = {'xsi': schema_instance})\" \\\r\n             % self.xml_root_tag)\r\n\r\n        self.print_or_save_log(\"- Constructed the root '{}' with variable name '{}'\".format(self.root_tag, self.xml_root_tag))\r\n\r\n    def construct_xml_elements(self, schema_tag, dict_element, father_element, is_children = False):\r\n        \"\"\"\r\n        Function that will iterate through a given dataframe and construct a XML file with its information.\r\n            The XML structure will be defined in a YAML file, with the given tags (e.g. for every element\r\n            in the XML there could be some attributes, children (elements), text tags and if it's repetitive).\r\n            Note that the field names in the dataframe shall match the values of these tags in the schema file\r\n            for indexing purposes. E.g.:\r\n                attributes:\r\n                    alias: \"Sample_alias\"           (alias: attribute tag in the XML; Sample_alias: column header in dataframe)\r\n                    center_name: \"Center_name\"      (center_name: attribute tag in the XML; Center_name: column header in dataframe)\r\n\r\n        In the first iteration we will consider the whole dictionary for each metadata object, given its\r\n            schema_tag (e.g. taking the whole sample schema given \"sample\" as schema_tag). In the subsequent\r\n            iterations we will get deeper into the XML tree using a restricted dictionary (dict_element) of\r\n            only one of their children (e.g. sample_name as schema_tag), until we reach a child with no more\r\n            children elements (we reach a leaf of the XML tree).\r\n\r\n        Parameters:\r\n            - schema_tag (str): a string with the schema_tag (e.g. sample_name or taxon_id) used to index the dictionary.\r\n            - dict_element (dict): dictionary element obtained loading the YAML schema file. It will have\r\n                                   3 additional elements itself: attributes, text and children. More\r\n                                   information about the nature of these elements can be found within\r\n                                   the YAML schema file.\r\n            - father_element (str): the father element's variable name. If we are iterating over children elements, their\r\n                                    father_element will be the schema_tag of their father's element (e.g. sample_name for\r\n                                    common_name).\r\n            - is_children (bool): specifies if we are iterating over children elements (and thus the father element is\r\n                                  not a common root, having to add indexes, etc.)\r\n        \"\"\"\r\n        # We save the current step in the YAML file (dictionary) XML hierarchy\r\n        current_level_dict = dict_element[schema_tag]\r\n\r\n        # We save a comprobations list of the current node (i.e. if it has children, attributes, etc.)\r\n        comprobations_list = self.each_node_comprobations(current_level_dict = current_level_dict, schema_tag = schema_tag)\r\n\r\n        # Based on the comprobation list's content, we add the node and all of its characteristics\r\n        self.additionOf_Node(schema_tag = schema_tag,\r\n                             comprobations_list = comprobations_list,\r\n                             father_element = father_element,\r\n                             is_children = is_children)\r\n\r\n    def additionOf_Node(self, schema_tag, comprobations_list, father_element, is_children = False):\r\n        \"\"\"\r\n        Function that deals with the addition of a node and all of its characteristics. If the node has children,\r\n            this function will also call construct_xml_elements() with the next level of depth in the hierarchy.\r\n\r\n        Parameters:\r\n            - schema_tag (str): a string with the schema_tag (e.g. sample_name or taxon_id) used to instance the node.\r\n            - comprobations_list (list): a list of dictionaries, boolean values and strings from the YAML file, returned\r\n                                         from executing each_node_comprobations() over the current node.\r\n            - father_element (str): the father element's name, which will be the variable name of the father.\r\n            - is_children (bool): specifies if we are iterating over children elements.\r\n        \"\"\"\r\n        # We assign each variable of the comprobation list\r\n        is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column = comprobations_list\r\n\r\n        # We use another variable to avoid overwritting the father_element (e.g. SAMPLE_SET)\r\n        given_father_element = father_element            \r\n            \r\n        # We get the number of repetitions of this node (default is 1 unless it's a repetitive node)\r\n        n_repetitions = self.retrieve_numberOf_repetitions(comprobations_list)\r\n\r\n        # Given the number of repetitions for this node, we add as many identical nodes (and their children)\r\n        for repetition_index in range(int(n_repetitions)):\r\n\r\n            # For this node (in the XML structure) we iterate through the dataframe rows and add this node for them all\r\n            #     at the same time (i.e. all SAMPLE at once; then all TAXON_ID at once, etc.)\r\n            for dataframe_index in range(self.dataframe_nrows):\r\n                # This variable will be used to create the element's instance in the XML tree\r\n                element_name = schema_tag + \"_\" + str(dataframe_index)\r\n                \r\n                # If the node is one of a possible choice, we need for each row to skip this children of the schema (e.g. REFERENCE_ALIGNMENT)\r\n                #     if the value of choice_column does not include it \r\n                if is_choices:\r\n                    is_included = self.choices_subset(schema_tag, dataframe_index, choice_column)\r\n                    \r\n                    # If the element we are in right now (e.g. REFERENCE_ALIGNMENT) is not within the chosen elements (e.g. SEQUENCE_VARIATION)\r\n                    #    for this row we skip it\r\n                    if not is_included:                       \r\n                        continue\r\n\r\n                # If we are dealing with a child's node (e.g. taxon_id_12 - 12 due to the 12th index of the dataframe),\r\n                #     the father needs to be created using the father's tag and the dataframe index (e.g. sample_name_12).\r\n                if is_children:\r\n                    given_father_element = father_element + \"_\" + str(dataframe_index)\r\n                    \r\n                # If we skipped its father node because it was not chosen, we need first to check if that node exists\r\n                #     to continue with the process of adding its children. \r\n                try: \r\n                    exec('self.%s' % \"xmlVar_\" + str(given_father_element))\r\n                    father_exists = True\r\n                except AttributeError:\r\n                    father_exists = False    \r\n                    \r\n                if not father_exists:\r\n                    continue\r\n\r\n                # We add the node itself, with no characteristics so far\r\n                self.add_one_node(father_element = given_father_element,\r\n                                  element_name = element_name,\r\n                                  schema_tag = schema_tag, \r\n                                  needsToBe_empty = needsToBe_empty)\r\n\r\n                # If this node in the YAML file have attributes or text defined, we add them to the node\r\n                if has_attributes:\r\n                    self.set_attributes(element_name = element_name,\r\n                                  attributes_dict = element_attributes,\r\n                                  dataframe_index = dataframe_index)\r\n                if has_text:\r\n                    self.set_text(element_name = element_name,\r\n                             column_name = text_column_name,\r\n                             dataframe_index = dataframe_index)\r\n\r\n            # If debug was given, we print (and write to logfile) the current step of the XML creation\r\n            if self.debug_mode:\r\n                self.save_xml(to_print = True, schema_tag = schema_tag)\r\n\r\n            # If we found out this node has children nodes, we call construct_xml_elements() recursively with them\r\n            if has_children:\r\n                # The new \"child\" will be the key to the next level of depth in the dictionary (e.g. \"taxon_id\")\r\n                #     while the children_elements will be the dictionary containing the \"child\" and their siblings.\r\n                for child in children_elements.keys():\r\n                    self.construct_xml_elements(schema_tag = child,\r\n                                                dict_element = children_elements,\r\n                                                father_element = schema_tag,\r\n                                                is_children = True) # It's a child, so the father element has to be modified with the index.\r\n\r\n    def choices_subset(self, schema_tag, dataframe_index, choice_column):\r\n        \"\"\"\r\n        Function that will check for the Nth (N = dataframe_index) row wether the schema tag is within its value of the column name \"choice_column\"\r\n            and will return True/False based on such veredict. \r\n        \r\n        Parameters:\r\n            - schema_tag (str): a string with the schema_tag (e.g. sample_name or taxon_id) used to instance the node.\r\n            - dataframe_index (int): the index of the dataframe (e.g. 13), which represents the row of the dataframe\r\n                                     (i.e. the repetition of a metadata object)\r\n            - choice_column (str): the column name in which the value to look for is (e.g. \"Analysis_type\")\r\n        \"\"\"\r\n        # We check that there is indeed a column with such name, just in case (since several will be optional and not mandatory)\r\n        if not self.check_column_exists(self.input_dataframe, choice_column):\r\n            print(\"ERROR in XML_creator() - choices_subset(): given column name ('%s') at row '%s' with possible choices for a node could not be found within the input dataframe.\" \\\r\n                  % (choice_column, dataframe_index + 1), file=sys.stderr)\r\n            sys.exit()\r\n        \r\n        # We retireve the value with the choices list and split it following specified format (\";\") as delimiter for each child\r\n        #     (e.g. \"SEQUENCE_VARIATION;SEQUENCE_ANNOTATION;...\")\r\n        choices_value = self.input_dataframe[choice_column][dataframe_index]\r\n        possible_choices_list = choices_value.split(\";\")\r\n        \r\n        # Just in case there are additional spaces at the start/end: \r\n        possible_choices_list = [x.upper().strip() for x in possible_choices_list]\r\n        \r\n        # If one of the possible choices is the schema tag we are in currently, we return True. Otherwise False.\r\n        if schema_tag in possible_choices_list:\r\n            return True\r\n        else:\r\n            return False    \r\n    \r\n    def retrieve_numberOf_repetitions(self, comprobations_list):\r\n        \"\"\"\r\n        Function to retrieve how many repetitions of a repetitive node there are.\r\n\r\n        Parameters:\r\n            - comprobations_list (list): a list of dictionaries, boolean values and strings from the YAML file, returned\r\n                                         from executing each_node_comprobations() over the current node.\r\n        \"\"\"\r\n        # We assign each variable of the comprobation list\r\n        is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column = comprobations_list\r\n\r\n        if is_repetitive:\r\n            # If it has text/attributes, we count how many columns they have\r\n            if has_attributes or has_text:\r\n                n_repetitions = self.get_numberOf_fields(comprobations_list)\r\n\r\n            # If it's a node with only children, we need to count the number of times a child attribute/text appears\r\n            else:\r\n                # We iterate over its children to get the number of repetitions\r\n                n_repetitions = self.iterate_over_children(children_elements = children_elements)\r\n        else:\r\n            n_repetitions = 1\r\n\r\n        return n_repetitions\r\n\r\n    def iterate_over_children(self, children_elements):\r\n        \"\"\"\r\n        Function to iterate over a children hierarchy to find out which has fields of attributes/text\r\n            that will indicate how many times a repetitive node (one of its fathers) is repeated.\r\n\r\n        Parameters:\r\n            - children_elements (dict): dictionary of the current node and its siblings (e.g. if its father\r\n                                        is sample_name, this dict would contain taxon_id and common_name)\r\n        \"\"\"\r\n        # We iterate over children dictionaries to check which one has attributes/text\r\n        for child in children_elements.keys():\r\n            # If the children doesn't have attributes/text we skip it\r\n            children_comprobation_list = self.each_node_comprobations(current_level_dict = children_elements[child], schema_tag = child)\r\n            child_has_children = children_comprobation_list[2]\r\n            child_has_attributes = children_comprobation_list[3]\r\n            child_has_text = children_comprobation_list[6]\r\n\r\n            # If we reached a child with attributes/text, we use it to infer the number of repetitions of its fathers\r\n            if child_has_attributes or child_has_text:\r\n                n_repetitions = self.get_numberOf_fields(children_comprobation_list)\r\n                return n_repetitions\r\n\r\n            # If this child only has other children we iterate over them to check if some have attributes/text\r\n            elif child_has_children:\r\n                n_repetitions = self.iterate_over_children(children_elements = children_elements[child][children_tag])\r\n                return n_repetitions\r\n\r\n        # If we iterated over the whole subelements and none have attributes/text, then little information is within\r\n        #     the dataframe, and thus we only add one (empty) repetitive node\r\n        n_repetitions = 1\r\n        return n_repetitions\r\n\r\n    def get_numberOf_fields(self, comprobations_list):\r\n        \"\"\"\r\n        Function that, given a comprobation_list, retrieves the ammount of fields of a dataframe that represent\r\n            a node's (1) text or (2) its attributes.\r\n\r\n        Parameters:\r\n            - comprobations_list (list): a list of dictionarioes, boolean values and strings from the YAML file, returned\r\n                                         from executing self.each_node_comprobations() over the current node.\r\n        \"\"\"\r\n        # We assign each variable of the comprobation list\r\n        is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column = comprobations_list\r\n\r\n        if has_text:\r\n            field_toLookFor = text_column_name\r\n\r\n        elif has_attributes:\r\n            # We take the first value of the attributes (its column name). It shouldn't matter if it's the first\r\n            #     or not, since all of their attribute columns SHOULD be present (even if empty).\r\n            field_toLookFor = next(iter(element_attributes.values()))\r\n\r\n        else:\r\n            # If the node has no attributes nor text, little information is in the df, so we only add one node (n_repetitions = 1)\r\n            return 1\r\n\r\n        # The following regular expression is used to get one individual block of repetition for this node. if a column\r\n        #     is repeated in a dataframe, pandas will add an index at its end \".[0-9]*\", and with this regexp we will\r\n        #     find out how many repeated columns with this column_name are.\r\n        regexp_field = '^{}\\.?[0-9]*$'.format(field_toLookFor)\r\n\r\n        # We save the number of fields in the df that refer to ONE repetition of this node (text or attribute)\r\n        n_repetitions = len(self.input_dataframe.filter(regex = regexp_field, axis = 1).columns)\r\n\r\n        if n_repetitions == 0:\r\n            print(\"ERROR in XML_creator() - get_numberOf_fields(): field '%s' could not be found in the input dataframe\" \\\r\n                  % field_toLookFor, file=sys.stderr)\r\n            sys.exit()\r\n\r\n        return n_repetitions\r\n\r\n\r\n    def each_node_comprobations(self, current_level_dict, schema_tag = None):\r\n        \"\"\"\r\n        Function to check the characteristics of each node from the YAML file. This function will return dictionaries,\r\n            strings and booleans (e.g. if the node has no attributes has_attributes = False)\r\n\r\n        Parameters:\r\n            - current_level_dict (dict): dictionary of the current element - i.e. if we are at \"sample_name\"\r\n                                         as the current node, the current_level_dict would contain up to 5\r\n                                         additional elements: children, text, attributes, repetitive_node and add_empty_node.\r\n            - schema_tag (str): the schema tag (e.g. sample or taxon_id) corresponding to the key of the current_level_dict.\r\n        \"\"\"\r\n        children_elements = {}\r\n        element_attributes = {}\r\n        text_column_name = None\r\n        choice_column = None\r\n\r\n        # We first check that the current dictionary has some elements (e.g. \"children\" or \"text\")\r\n        try:\r\n            current_dict_set = set(current_level_dict.keys())       # e.g. {\"children\", \"text\"}\r\n        except:\r\n            # If the dictionary is empty, the node was left empty in the schema, and thus has no information (common mistake)\r\n            print(\"ERROR in XML_creator() - each_node_comprobations(): the given schema dictionary for schema tag '%s' is empty. This reflects an error (unused node) in the configuration file '%s', check the said schema tag within it.\" \\\r\n                  % (schema_tag, self.schema_filename), file=sys.stderr)\r\n            sys.exit()\r\n\r\n        # Now we check if the keys of the current_element are (a subset of) the valid ones (children, text...)\r\n        if not current_dict_set.issubset(valid_dict_elements):\r\n            print(\"ERROR in XML_creator() - each_node_comprobations(): the given schema dictionary for schema tag '%s' contains non valid keys.\\n\\t - Valid keys: %s\\n\\t - Given keys: %s\" \\\r\n                  % (schema_tag, valid_dict_elements, current_dict_set), file=sys.stderr)\r\n            sys.exit()\r\n\r\n        # In each step, we check for the valid keys, associating its corresponding part of the dictionary\r\n        if children_tag in current_dict_set:\r\n            children_elements = current_level_dict[children_tag]\r\n            if children_elements is None:\r\n                print(\"ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had children characteristic, but was found empty.\" \\\r\n                      % schema_tag, file=sys.stderr)\r\n                sys.exit()\r\n            has_children = True\r\n        else:\r\n            has_children = False\r\n\r\n        if attribute_tag in current_dict_set:\r\n            element_attributes = current_level_dict[attribute_tag]\r\n            if element_attributes is None:\r\n                print(\"ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had attributes characteristic, but was found empty.\" \\\r\n                      % schema_tag, file=sys.stderr)\r\n                sys.exit()\r\n            has_attributes = True\r\n        else:\r\n            has_attributes = False\r\n\r\n        if text_tag in current_dict_set:\r\n            text_column_name = current_level_dict[text_tag]\r\n            if text_column_name is None:\r\n                print(\"ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had text characteristic, but was found empty.\" \\\r\n                      % schema_tag, file=sys.stderr)\r\n                sys.exit()\r\n            has_text = True\r\n        else:\r\n            has_text = False\r\n\r\n        # We check if this node is one of the repetitive ones (e.g. repetitive_node: True)\r\n        if repetitive_tag in current_dict_set:\r\n            is_repetitive = True\r\n        else:\r\n            is_repetitive = False\r\n        \r\n        if add_empty_node_tag in current_dict_set:\r\n            needsToBe_empty = True\r\n        else:\r\n            needsToBe_empty = False\r\n            \r\n        # We check if this node has a choice statement (will be used to index one or more of its childrens)\r\n        if choice_tag in current_dict_set:            \r\n            # choice_column can be one single element or a list of elements (child;child;child...) to choose from \"children\"\r\n            choice_column = current_level_dict[choice_tag]\r\n            if choice_column is None:\r\n                print(\"ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had 'choice' characteristic, but it was found empty.\" \\\r\n                      % schema_tag, file=sys.stderr)\r\n                sys.exit()\r\n            is_choices = True\r\n        else:\r\n            is_choices = False\r\n        \r\n        # We return the list of possible comprobations within a node. Some will be a dictionary, some will be boolean and others will be strings        \r\n        return is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column\r\n\r\n    def add_one_node(self, father_element, element_name, schema_tag, needsToBe_empty):\r\n        \"\"\"\r\n        Function that adds one node to the XML tree.\r\n\r\n        Parameters:\r\n            - father_element (str): the father element's name, which will be the variable name of the father\r\n                                    etree.Element (a XML node) of the current node (e.g. SAMPLE_SET).\r\n            - element_name (str): the name of the current node (e.g. sample_13)\r\n            - schema_tag (str): the schema tag (e.g. sample or taxon_id) that is written within the YAML file.\r\n            - needsToBe_empty (bool): a boolean that specifies if the node has a meaning by itself although\r\n                                      being empty which, if True, will prevent from its removal (after the tree has been \r\n                                      created) by the prunning function. \r\n        \"\"\"\r\n        # We add \"xmlVar\" first so that no other fixed variable of this scripts coincidentally is the element_name\r\n        # We create the pair \"node name\" + \"father's node name\" so that it's a unique identifier we use in the counter. Otherwise\r\n        #   repeated node names (e.g. LABEL) between different father nodes would lead to errors.\r\n        xml_node_tag = \"xmlVar_\" + str(element_name)\r\n        xml_fatherNode_tag = \"xmlVar_\" + str(father_element)\r\n        \r\n        # Using the element's variable content (str) as a variable we create the current node\r\n        exec(\"self.%s = etree.SubElement(self.%s, schema_tag.upper())\" % (xml_node_tag, xml_fatherNode_tag))\r\n\r\n        # Avoid being prunned in the future. \r\n        if needsToBe_empty:\r\n            exec(\"self.nodesThatNeedToBe_empty_list.append(self.%s)\" % xml_node_tag)\r\n    \r\n    def get_SameNodes_repetitions(self, xml_node_tag):\r\n        \"\"\"\r\n        Function that will return the number of repetitions of a specific node within the XML tree. For instance, in the \r\n            node \"ANALYSIS\" with an XPath \"/ANALYSIS_SET/ANALYSIS/DESCRIPTOR[3]\", the function would return \"3\". It is \r\n            important to notice that the last index of the XPath is what defines the number of repetitions of a node. For\r\n            instance, if we have three <ANALYSIS_ATTRIBUTE>, its XPath would be /ANALYSIS_SET/ANALYSIS[1]/ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3],\r\n            but if we were interested in how many tyimes <TAG> from an <ANALYSIS_ATTRIBUTE> is repeated, the repetition\r\n            index will not be within <TAG> itself, but within its father node <ANALYSIS_ATTRIBUTE>: \r\n                7ANALYSIS_SET/ANALYSIS[1]/ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3]/TAG\r\n            \r\n            We could have issues if there were several repetitions within repetitions, beside the base node (e.g. ANALYSIS),\r\n            since the base node repetition derives from the Y axis (rows) of the input file, and other repetitions of the same XPath\r\n            derive from the X axis (columns) of the input file. Therefore, as we do not allow for repetitions within repetitions,\r\n            it should work properly. \r\n        \r\n        Parameters:\r\n            - xml_node_tag (string): the name of the node within our function (e.g. xmlVar_DESCRIPTOR_0)\r\n        \"\"\"\r\n        # In case we are given the node beneath the root (e.g. ANALYSIS_SET/ANALYSIS[2]), its repetition index (e.g. 2) will\r\n        #    not come from different columns, but from different rows (different dimension), and thus we skip it if the root\r\n        #    is its parent.\r\n        exec('global getRepetitions_root; getRepetitions_root = self.%s.getparent()' % xml_node_tag)\r\n        exec('global getRepetitions_equalRoots; getRepetitions_equalRoots = getRepetitions_root == self.%s' % self.xml_root_tag)\r\n\r\n        if getRepetitions_equalRoots:   \r\n            return 0\r\n        \r\n        # We use lxml.etree wrapper (ElementTree()) with the node and extract its xpath\r\n        exec('global getRepetitions_tree; getRepetitions_tree = etree.ElementTree(self.%s)' % xml_node_tag)\r\n        exec('global getRepetitions_xpath; getRepetitions_xpath = getRepetitions_tree.getpath(self.%s)' % xml_node_tag)\r\n        \r\n        modified_getRepetitions_xpath = getRepetitions_xpath\r\n\r\n        # We parse the complete XPath to remove the repetition of a base metadata object (e.g. from /ANALYSIS_SET/ANALYSIS[1]/ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3]/TAG \r\n        #      to /ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3]/TAG). This is to avoid getting indexes from the base tag, or only accounting for the last tag (which would lead to errors)\r\n        for null in range(3):\r\n            slash_start = modified_getRepetitions_xpath.find(\"/\")\r\n            modified_getRepetitions_xpath = modified_getRepetitions_xpath[slash_start + 1:]\r\n\r\n        # And now we get the repetition index from the XPath\r\n        start = modified_getRepetitions_xpath.rfind(\"[\")\r\n        end = modified_getRepetitions_xpath.rfind(\"]\")\r\n        \r\n        # If \"[\" was not found within the last part of the XPath, we return a 0\r\n        if start == -1:\r\n            return 0\r\n        \r\n        # If we did find an index (e.g. [2]) we return such index (e.g. 2), which will be used as index in the dataframe\r\n        repetition_index = modified_getRepetitions_xpath[start + 1 : end]    \r\n               \r\n        return int(repetition_index)\r\n        \r\n\r\n    def set_attributes(self, element_name, attributes_dict, dataframe_index):\r\n        \"\"\"\r\n        Function to set the attributes of an XML node.\r\n\r\n        Parameters:\r\n            - element_name (str): the name of the current node (e.g. sample_13)\r\n            - attributes_dict (dict): dictionary containing the attribute names (keys) and their corresponding\r\n                                      column names in the dataframe.\r\n                                      (e.g. {'alias': 'Sample_ID', 'center_name': 'center_name'})\r\n            - dataframe_index (int): the index of the dataframe (e.g. 13), which represents the row of the df\r\n                                     (i.e. the repetition of a metadata object)\r\n        \"\"\"\r\n        # We create the pair \"node name\" + \"father's node name\" so that it's a unique identifier we use in the counter. Otherwise\r\n        #   repeated node names (e.g. LABEL) between different father nodes would lead to errors.\r\n        xml_node_tag = \"xmlVar_\" + str(element_name)\r\n\r\n        # Here we add a \".X\" to every value (which represents the field of the dataframe to search for the attribute)\r\n        #     of the attributes dictionary, since every subsequent repeated column in the dataframe will have \".X\"\r\n        #     where X is the times that same node is repeated across the XML (minus 1, since it starts at 0).\r\n        # Except the first index, which will not be \".0\" but the column name itself.\r\n        repetitions = self.get_SameNodes_repetitions(xml_node_tag)\r\n        if repetitions > 0:\r\n            attributes_dict = {k: v+'.{}'.format(repetitions - 1) for k, v in attributes_dict.items()}\r\n\r\n        # We iterate over the different attributes of this node:\r\n        for attribute_name, column_name in attributes_dict.items():\r\n            # If the column does not exist within the dataframe it could be that the same name was given to different nodes\r\n            #     and that will lead to errors, so we skip it. \r\n            if not self.check_column_exists(self.input_dataframe, column_name):\r\n                return\r\n            \r\n            attribute_value = self.input_dataframe[column_name][dataframe_index]\r\n            # If the value in the dataframe is empty, NaN, None or only contains white spaces we skip adding this attribute\r\n            if (not attribute_value and attribute_value != 0) or attribute_value is None or pd.isnull(attribute_value) or str.isspace(str(attribute_value)):\r\n                continue\r\n            exec(\"self.%s.set('''%s''','''%s''')\" % (xml_node_tag, str(attribute_name), str(attribute_value)))\r\n\r\n    def set_text(self, element_name, column_name, dataframe_index):\r\n        \"\"\"\r\n        Function to set the text of an XML node.\r\n\r\n        Parameters:\r\n            - element_name (str): the name of the current node (e.g. title_13)\r\n            - column_name (str): the name of the column of the dataframe where the text is stored (e.g. Title_text)\r\n            - dataframe_index (int): the index of the dataframe (e.g. 13), which represents the row of the df\r\n                                     (i.e. the repetition of a metadata object)\r\n        \"\"\"\r\n        # We create the pair \"node name\" + \"father's node name\" so that it's a unique identifier we use in the counter. Otherwise\r\n        #   repeated node names (e.g. LABEL) between different father nodes would lead to errors.\r\n        xml_node_tag = \"xmlVar_\" + str(element_name)\r\n\r\n        # We add \".X\" at the end of the column name, just like with the attributes           \r\n        repetitions = self.get_SameNodes_repetitions(xml_node_tag)\r\n        if repetitions > 0:\r\n            column_name = column_name + '.{}'.format(repetitions - 1)\r\n\r\n        # If the column does not exist within the dataframe it could be that the same name was given to different nodes\r\n        #     and that will lead to errors, so we skip it. \r\n        if not self.check_column_exists(self.input_dataframe, column_name):\r\n            return\r\n        \r\n        # We extract the node's text from the dataframe\r\n        nodes_text = self.input_dataframe[column_name][dataframe_index]\r\n\r\n        # If the value in the dataframe is empty, NaN, None or only contains white spaces we skip setting its text\r\n        if (not nodes_text and nodes_text != 0) or nodes_text is None or pd.isnull(nodes_text) or str.isspace(str(nodes_text)):\r\n            return\r\n\r\n        exec(\"self.%s.text = '''%s'''\" % (xml_node_tag, str(nodes_text)))\r\n    \r\n    def check_column_exists(self, dataframe, column_name):\r\n        \"\"\"\r\n        Function that will check that the given column-name exists within the given dataframe, and return\r\n            True if so, or False otherwise.\r\n        \r\n        Parameters:\r\n            - dataframe (pd.DataFrame): dataframe in which the column could exist.\r\n            - column_name (string): column name to search within the dataframe.\r\n        \"\"\"\r\n        if column_name in dataframe.columns:\r\n            return True\r\n        else:\r\n            return False\r\n        \r\n\r\n    def prune_empty_nodes(self, empty_list = None):\r\n        \"\"\"\r\n        Function that removes empty nodes (with no attributes, no children and no text) of an XML tree recursively.\r\n            Why prune instead of avoid adding empty nodes? Because we don't know if they are empty until we have filled\r\n            the XML tree.\r\n        \r\n        Parameters:\r\n            - empty_list (list): list of empty nodes (of class etree.Element) that needs to be removed from the tree. If\r\n                                 no list is passed, the function gets such list by itself. \r\n        \"\"\"        \r\n        if not empty_list:\r\n            # Using XPATH we save a list of the empty nodes ('not(node())') with no attributes ('not(@*)')\r\n            exec(\"self.empty_nodes_list = self.%s.xpath('.//*[not(@*) and not(node())]')\" % self.xml_root_tag)\r\n            \r\n            # We remove from the empty_nodes_list all the nodes that have to be left empty and hold a meaning like that. \r\n            self.empty_nodes_list = self.remove_betweenLists(self.empty_nodes_list, self.nodesThatNeedToBe_empty_list)\r\n            \r\n        else:\r\n            self.empty_nodes_list = empty_list        \r\n        \r\n        # We iterate over the list and remove empty nodes\r\n        for empty_element in self.empty_nodes_list:\r\n            empty_element.getparent().remove(empty_element)\r\n\r\n        # If, after pruning, new nodes are left empty, we prune again\r\n        exec(\"self.new_empty_nodes_list = self.%s.xpath('.//*[not(@*) and not(node())]')\" % self.xml_root_tag)\r\n        # Bare in mind that we again remove all nodes that have to be left empty from the list of nodes to prune\r\n        self.new_empty_nodes_list = self.remove_betweenLists(self.new_empty_nodes_list, self.nodesThatNeedToBe_empty_list)\r\n        \r\n        if self.new_empty_nodes_list:\r\n            self.prune_empty_nodes(empty_list = self.new_empty_nodes_list)\r\n    \r\n    def remove_betweenLists(self, first_list, sublist):\r\n        \"\"\"\r\n        Function that will remove all elements from a sublist that are in a bigger list (first_list). \r\n\r\n        Parameters:\r\n            - first_list (list): sequence of elements of the biggest list of the two\r\n            - sublist (list): contains the elements that shall be removed from first_list\r\n        \"\"\"\r\n        return list(set(first_list)-set(sublist))
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Star2xml/XML_creator.py b/Star2xml/XML_creator.py
--- a/Star2xml/XML_creator.py	(revision 9341fc22df47681c560f68520d9a896f7645394b)
+++ b/Star2xml/XML_creator.py	(date 1617095979897)
@@ -12,7 +12,8 @@
 repetitive_tag = "repetitive_node"
 add_empty_node_tag = "add_empty_node"
 choice_tag = "choice_tag"
-valid_dict_elements = set([children_tag, attribute_tag, text_tag, repetitive_tag, add_empty_node_tag, choice_tag])
+repetitiveNode_Father_Tag = "repetitiveNode_Father_Tag"
+valid_dict_elements = set([children_tag, attribute_tag, text_tag, repetitive_tag, add_empty_node_tag, choice_tag, repetitiveNode_Father_Tag])
 tool_info_tag = "tool_info"
 version_tag = "version"
 update_date_tag = "update_date"
@@ -146,12 +147,20 @@
         # The following list will be populated with nodes that have the add_empty_node_tag. These nodes will not be removed
         #   by the prunning function, since they have a meaning by themselves, although they are empty (e.g. SINGLE in LIBRARY_LAYOUT)
         self.nodesThatNeedToBe_empty_list = []
+        
+        # The following list will also be populated through the creation of the XML tree. In this case, the list will contain
+        #     tuples of nodes that are fathers of multiple choice repetitive nodes (e.g. SAMPLE_LINK), and their fathers (e.g
+        #     SAMPLE_LINKS)
+        self.nodesThatAreFathersOfRepetitiveNode = []
 
         # We create the elements of the set (the whole XML tree).
         self.construct_xml_elements(schema_tag = self.schema_key,
                                     dict_element = self.schema_general_dict,
                                     father_element = father_element)
 
+        # We re-structure the nodes that were father's of multiple choice repetitive nodes
+        self.reconfigure_FathersOfRepetitiveMultiChoice()
+        
         # We prune empty nodes recursively
         self.prune_empty_nodes()
 
@@ -254,34 +263,32 @@
         current_level_dict = dict_element[schema_tag]
 
         # We save a comprobations list of the current node (i.e. if it has children, attributes, etc.)
-        comprobations_list = self.each_node_comprobations(current_level_dict = current_level_dict, schema_tag = schema_tag)
+        comprobations_dict = self.each_node_comprobations(current_level_dict = current_level_dict, schema_tag = schema_tag)
 
         # Based on the comprobation list's content, we add the node and all of its characteristics
         self.additionOf_Node(schema_tag = schema_tag,
-                             comprobations_list = comprobations_list,
+                             comprobations_dict = comprobations_dict,
                              father_element = father_element,
                              is_children = is_children)
 
-    def additionOf_Node(self, schema_tag, comprobations_list, father_element, is_children = False):
+    def additionOf_Node(self, schema_tag, comprobations_dict, father_element, is_children = False):
         """
         Function that deals with the addition of a node and all of its characteristics. If the node has children,
             this function will also call construct_xml_elements() with the next level of depth in the hierarchy.
 
         Parameters:
             - schema_tag (str): a string with the schema_tag (e.g. sample_name or taxon_id) used to instance the node.
-            - comprobations_list (list): a list of dictionaries, boolean values and strings from the YAML file, returned
+            - comprobations_dict (dict): a dictionary of strings, boleans, other dictionaries... from the YAML file, returned
                                          from executing each_node_comprobations() over the current node.
             - father_element (str): the father element's name, which will be the variable name of the father.
             - is_children (bool): specifies if we are iterating over children elements.
         """
-        # We assign each variable of the comprobation list
-        is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column = comprobations_list
 
         # We use another variable to avoid overwritting the father_element (e.g. SAMPLE_SET)
         given_father_element = father_element            
             
         # We get the number of repetitions of this node (default is 1 unless it's a repetitive node)
-        n_repetitions = self.retrieve_numberOf_repetitions(comprobations_list)
+        n_repetitions = self.retrieve_numberOf_repetitions(comprobations_dict)
 
         # Given the number of repetitions for this node, we add as many identical nodes (and their children)
         for repetition_index in range(int(n_repetitions)):
@@ -294,8 +301,8 @@
                 
                 # If the node is one of a possible choice, we need for each row to skip this children of the schema (e.g. REFERENCE_ALIGNMENT)
                 #     if the value of choice_column does not include it 
-                if is_choices:
-                    is_included = self.choices_subset(schema_tag, dataframe_index, choice_column)
+                if comprobations_dict["is_choices"]:
+                    is_included = self.choices_subset(schema_tag, dataframe_index, comprobations_dict["choice_column"])
                     
                     # If the element we are in right now (e.g. REFERENCE_ALIGNMENT) is not within the chosen elements (e.g. SEQUENCE_VARIATION)
                     #    for this row we skip it
@@ -322,29 +329,30 @@
                 self.add_one_node(father_element = given_father_element,
                                   element_name = element_name,
                                   schema_tag = schema_tag, 
-                                  needsToBe_empty = needsToBe_empty)
+                                  comprobations_dict = comprobations_dict)
 
                 # If this node in the YAML file have attributes or text defined, we add them to the node
-                if has_attributes:
+                if comprobations_dict["has_attributes"]:
                     self.set_attributes(element_name = element_name,
-                                  attributes_dict = element_attributes,
+                                  attributes_dict = comprobations_dict["element_attributes"],
                                   dataframe_index = dataframe_index)
-                if has_text:
+                
+                if comprobations_dict["has_text"]:
                     self.set_text(element_name = element_name,
-                             column_name = text_column_name,
-                             dataframe_index = dataframe_index)
+                             column_name = comprobations_dict["text_column_name"],
+                             dataframe_index = dataframe_index)                    
 
             # If debug was given, we print (and write to logfile) the current step of the XML creation
             if self.debug_mode:
                 self.save_xml(to_print = True, schema_tag = schema_tag)
 
             # If we found out this node has children nodes, we call construct_xml_elements() recursively with them
-            if has_children:
+            if comprobations_dict["has_children"]:
                 # The new "child" will be the key to the next level of depth in the dictionary (e.g. "taxon_id")
                 #     while the children_elements will be the dictionary containing the "child" and their siblings.
-                for child in children_elements.keys():
+                for child in comprobations_dict["children_elements"].keys():
                     self.construct_xml_elements(schema_tag = child,
-                                                dict_element = children_elements,
+                                                dict_element = comprobations_dict["children_elements"],
                                                 father_element = schema_tag,
                                                 is_children = True) # It's a child, so the father element has to be modified with the index.
 
@@ -379,26 +387,24 @@
         else:
             return False    
     
-    def retrieve_numberOf_repetitions(self, comprobations_list):
+    def retrieve_numberOf_repetitions(self, comprobations_dict):
         """
         Function to retrieve how many repetitions of a repetitive node there are.
 
         Parameters:
-            - comprobations_list (list): a list of dictionaries, boolean values and strings from the YAML file, returned
+            - comprobations_dict (dict): a dictionary of strings, boleans, other dictionaries... from the YAML file, returned
                                          from executing each_node_comprobations() over the current node.
         """
-        # We assign each variable of the comprobation list
-        is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column = comprobations_list
-
-        if is_repetitive:
+        
+        if comprobations_dict["is_repetitive"]:
             # If it has text/attributes, we count how many columns they have
-            if has_attributes or has_text:
-                n_repetitions = self.get_numberOf_fields(comprobations_list)
+            if comprobations_dict["has_attributes"] or comprobations_dict["has_text"]:
+                n_repetitions = self.get_numberOf_fields(comprobations_dict)
 
             # If it's a node with only children, we need to count the number of times a child attribute/text appears
             else:
                 # We iterate over its children to get the number of repetitions
-                n_repetitions = self.iterate_over_children(children_elements = children_elements)
+                n_repetitions = self.iterate_over_children(children_elements = comprobations_dict["children_elements"])
         else:
             n_repetitions = 1
 
@@ -416,14 +422,14 @@
         # We iterate over children dictionaries to check which one has attributes/text
         for child in children_elements.keys():
             # If the children doesn't have attributes/text we skip it
-            children_comprobation_list = self.each_node_comprobations(current_level_dict = children_elements[child], schema_tag = child)
-            child_has_children = children_comprobation_list[2]
-            child_has_attributes = children_comprobation_list[3]
-            child_has_text = children_comprobation_list[6]
+            comprobations_dict = self.each_node_comprobations(current_level_dict = children_elements[child], schema_tag = child)
+            child_has_children = comprobations_dict["has_children"]
+            child_has_attributes = comprobations_dict["has_attributes"]
+            child_has_text = comprobations_dict["has_text"]
 
             # If we reached a child with attributes/text, we use it to infer the number of repetitions of its fathers
             if child_has_attributes or child_has_text:
-                n_repetitions = self.get_numberOf_fields(children_comprobation_list)
+                n_repetitions = self.get_numberOf_fields(comprobations_dict)
                 return n_repetitions
 
             # If this child only has other children we iterate over them to check if some have attributes/text
@@ -436,25 +442,22 @@
         n_repetitions = 1
         return n_repetitions
 
-    def get_numberOf_fields(self, comprobations_list):
+    def get_numberOf_fields(self, comprobations_dict):
         """
         Function that, given a comprobation_list, retrieves the ammount of fields of a dataframe that represent
             a node's (1) text or (2) its attributes.
 
         Parameters:
-            - comprobations_list (list): a list of dictionarioes, boolean values and strings from the YAML file, returned
-                                         from executing self.each_node_comprobations() over the current node.
+            - comprobations_dict (dict): a dictionary of strings, boleans, other dictionaries... from the YAML file, returned
+                                         from executing each_node_comprobations() over the current node.
         """
-        # We assign each variable of the comprobation list
-        is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column = comprobations_list
+        if comprobations_dict["has_text"]:
+            field_toLookFor = comprobations_dict["text_column_name"]
 
-        if has_text:
-            field_toLookFor = text_column_name
-
-        elif has_attributes:
+        elif comprobations_dict["has_attributes"]:
             # We take the first value of the attributes (its column name). It shouldn't matter if it's the first
             #     or not, since all of their attribute columns SHOULD be present (even if empty).
-            field_toLookFor = next(iter(element_attributes.values()))
+            field_toLookFor = next(iter(comprobations_dict["element_attributes"].values()))
 
         else:
             # If the node has no attributes nor text, little information is in the df, so we only add one node (n_repetitions = 1)
@@ -479,7 +482,7 @@
     def each_node_comprobations(self, current_level_dict, schema_tag = None):
         """
         Function to check the characteristics of each node from the YAML file. This function will return dictionaries,
-            strings and booleans (e.g. if the node has no attributes has_attributes = False)
+            strings and booleans (e.g. if the node has no attributes has_attributes = False) within the returned comprobations_dict.
 
         Parameters:
             - current_level_dict (dict): dictionary of the current element - i.e. if we are at "sample_name"
@@ -487,10 +490,12 @@
                                          additional elements: children, text, attributes, repetitive_node and add_empty_node.
             - schema_tag (str): the schema tag (e.g. sample or taxon_id) corresponding to the key of the current_level_dict.
         """
+        comprobations_dict = {}
+
         children_elements = {}
         element_attributes = {}
-        text_column_name = None
-        choice_column = None
+        comprobations_dict["text_column_name"] = None
+        comprobations_dict["choice_column"] = None
 
         # We first check that the current dictionary has some elements (e.g. "children" or "text")
         try:
@@ -509,62 +514,69 @@
 
         # In each step, we check for the valid keys, associating its corresponding part of the dictionary
         if children_tag in current_dict_set:
-            children_elements = current_level_dict[children_tag]
-            if children_elements is None:
+            comprobations_dict["children_elements"] = current_level_dict[children_tag]
+            if comprobations_dict["children_elements"] is None:
                 print("ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had children characteristic, but was found empty." \
                       % schema_tag, file=sys.stderr)
                 sys.exit()
-            has_children = True
+            comprobations_dict["has_children"] = True
         else:
-            has_children = False
+            comprobations_dict["has_children"] = False
 
         if attribute_tag in current_dict_set:
-            element_attributes = current_level_dict[attribute_tag]
-            if element_attributes is None:
+            comprobations_dict["element_attributes"] = current_level_dict[attribute_tag]
+            if comprobations_dict["element_attributes"] is None:
                 print("ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had attributes characteristic, but was found empty." \
                       % schema_tag, file=sys.stderr)
                 sys.exit()
-            has_attributes = True
+            comprobations_dict["has_attributes"] = True
         else:
-            has_attributes = False
+            comprobations_dict["has_attributes"] = False
 
         if text_tag in current_dict_set:
-            text_column_name = current_level_dict[text_tag]
-            if text_column_name is None:
+            comprobations_dict["text_column_name"] = current_level_dict[text_tag]
+            if comprobations_dict["text_column_name"] is None:
                 print("ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had text characteristic, but was found empty." \
                       % schema_tag, file=sys.stderr)
                 sys.exit()
-            has_text = True
+            comprobations_dict["has_text"] = True
         else:
-            has_text = False
+            comprobations_dict["has_text"] = False
 
         # We check if this node is one of the repetitive ones (e.g. repetitive_node: True)
         if repetitive_tag in current_dict_set:
-            is_repetitive = True
+            comprobations_dict["is_repetitive"] = True
         else:
-            is_repetitive = False
+            comprobations_dict["is_repetitive"] = False
         
         if add_empty_node_tag in current_dict_set:
-            needsToBe_empty = True
+            comprobations_dict["needsToBe_empty"] = True
         else:
-            needsToBe_empty = False
+            comprobations_dict["needsToBe_empty"] = False
             
         # We check if this node has a choice statement (will be used to index one or more of its childrens)
         if choice_tag in current_dict_set:            
             # choice_column can be one single element or a list of elements (child;child;child...) to choose from "children"
-            choice_column = current_level_dict[choice_tag]
-            if choice_column is None:
+            comprobations_dict["choice_column"] = current_level_dict[choice_tag]
+            if comprobations_dict["choice_column"] is None:
                 print("ERROR in XML_creator() - each_node_comprobations(): the given schema tag '%s' had 'choice' characteristic, but it was found empty." \
                       % schema_tag, file=sys.stderr)
                 sys.exit()
-            is_choices = True
+            comprobations_dict["is_choices"] = True
+        else:
+            comprobations_dict["is_choices"] = False
+            
+        # We check if the node is of special type "father of a multiple choice repetitive node". An example would be
+        #     the SAMPLE_LINK, which is repeated itself, but it has different possible children in each iteration.
+        if repetitiveNode_Father_Tag in current_dict_set:
+            comprobations_dict["repetitiveNode_Father_Tag"] = True
         else:
-            is_choices = False
+            comprobations_dict["repetitiveNode_Father_Tag"] = False
         
         # We return the list of possible comprobations within a node. Some will be a dictionary, some will be boolean and others will be strings        
-        return is_repetitive, children_elements, has_children, element_attributes, has_attributes, text_column_name, has_text, needsToBe_empty, is_choices, choice_column
+        return comprobations_dict
 
-    def add_one_node(self, father_element, element_name, schema_tag, needsToBe_empty):
+    def add_one_node(self, father_element, element_name, schema_tag, comprobations_dict):
         """
         Function that adds one node to the XML tree.
 
@@ -573,9 +585,8 @@
                                     etree.Element (a XML node) of the current node (e.g. SAMPLE_SET).
             - element_name (str): the name of the current node (e.g. sample_13)
             - schema_tag (str): the schema tag (e.g. sample or taxon_id) that is written within the YAML file.
-            - needsToBe_empty (bool): a boolean that specifies if the node has a meaning by itself although
-                                      being empty which, if True, will prevent from its removal (after the tree has been 
-                                      created) by the prunning function. 
+            - comprobations_dict (dict): a dictionary of strings, boleans, other dictionaries... from the YAML file, returned
+                                         from executing each_node_comprobations() over the current node.
         """
         # We add "xmlVar" first so that no other fixed variable of this scripts coincidentally is the element_name
         # We create the pair "node name" + "father's node name" so that it's a unique identifier we use in the counter. Otherwise
@@ -587,8 +598,12 @@
         exec("self.%s = etree.SubElement(self.%s, schema_tag.upper())" % (xml_node_tag, xml_fatherNode_tag))
 
         # Avoid being prunned in the future. 
-        if needsToBe_empty:
+        if comprobations_dict["needsToBe_empty"]:
             exec("self.nodesThatNeedToBe_empty_list.append(self.%s)" % xml_node_tag)
+        
+        # We add the node to a list that will be reconfigured at the end.
+        if comprobations_dict["repetitiveNode_Father_Tag"]:
+            exec("self.nodesThatAreFathersOfRepetitiveNode.append((self.%s, self.%s))" % (xml_node_tag, xml_fatherNode_tag))
     
     def get_SameNodes_repetitions(self, xml_node_tag):
         """
@@ -598,7 +613,7 @@
             instance, if we have three <ANALYSIS_ATTRIBUTE>, its XPath would be /ANALYSIS_SET/ANALYSIS[1]/ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3],
             but if we were interested in how many tyimes <TAG> from an <ANALYSIS_ATTRIBUTE> is repeated, the repetition
             index will not be within <TAG> itself, but within its father node <ANALYSIS_ATTRIBUTE>: 
-                7ANALYSIS_SET/ANALYSIS[1]/ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3]/TAG
+                /ANALYSIS_SET/ANALYSIS[1]/ANALYSIS_ATTRIBUTES/ANALYSIS_ATTRIBUTE[3]/TAG
             
             We could have issues if there were several repetitions within repetitions, beside the base node (e.g. ANALYSIS),
             since the base node repetition derives from the Y axis (rows) of the input file, and other repetitions of the same XPath
@@ -768,4 +783,49 @@
             - first_list (list): sequence of elements of the biggest list of the two
             - sublist (list): contains the elements that shall be removed from first_list
         """
-        return list(set(first_list)-set(sublist))
\ No newline at end of file
+        return list(set(first_list)-set(sublist))
+    
+    def reconfigure_FathersOfRepetitiveMultiChoice(self):
+        """
+        Function that will reconfigure the resulting XML tree by moving the children of a particular type of node: the father
+            node of a repeated and multiple choice node. To avoid messing with a lot of other functions, the way the XML is
+            created when a node like this appears is to add all children nodes within the same father node (e.g. SAMPLE_LINK).
+            Then, this function will move all those children to different father nodes, as independent leaves with independent
+            father elements. As an example, we would go from the XML tree of the left, to the XML tree of the right: 
+              <SAMPLE_LINK>                              <SAMPLE_LINK>
+                <URL_LINK>                                   <URL_LINK>
+                  <LABEL>Text </LABEL>                            <LABEL>Text </LABEL>
+                  <URL>Text </URL>                                <URL>Text </URL>
+                </URL_LINK>                                  </URL_LINK>
+                                                         </SAMPLE_LINK>
+                                                         <SAMPLE_LINK>
+                <XREF_LINK>                                  <XREF_LINK>
+                  <DB>Text </DB>                                  <DB>Text </DB>
+                  <ID>Text </ID>                                  <ID>Text </ID>
+                  <LABEL>Text </LABEL>                            <LABEL>Text </LABEL>
+                </XREF_LINK>                                 </XREF_LINK>
+              </SAMPLE_LINK>                             </SAMPLE_LINK>
+              
+            The function will use the list nodesThatAreFathersOfRepetitiveNode that was populated with tuples of this type of 
+                nodes (e.g. SAMPLE_LINK) and their father node (e.g. SAMPLE_LINKS)
+        """
+        
+        # We iterated over all the stored nodes of this type:
+        for tuple_element in self.nodesThatAreFathersOfRepetitiveNode:
+            child_to_reconfigure = tuple_element[0]
+            father_node = tuple_element[1]
+            
+            # We get the list of children nodes (e.g. XREF_LINK) the children to reconfigure (e.g. SAMPLE_LINK) has.
+            #     In our example the list would have 2 elements: the accession of URL_LINK and XREF_LINK. 
+            list_of_children = child_to_reconfigure.findall("./")
+            number_of_children = len(list_of_children)
+            
+            # We iterate over all the children (e.g. XREF_LINK) of the "children_to_reconfigure" (e.g. SAMPLE_LINK)
+            for child_of_list in list_of_children:
+                # We create a new father (e.g. SAMPLE_LINK) for this child (e.g. XREF_LINK), which will be the child
+                #     of the original child_to_reconfigure's father (e.g. SAMPLE_LINKS)
+                reconfigure_new_father = etree.SubElement(father_node, child_to_reconfigure.tag)
+                
+                # Now we move the current child_of_list into the newly created father node through etree's own "append()" function
+                reconfigure_new_father.append(child_of_list)            
+            
\ No newline at end of file
